\documentclass{llncs}

\usepackage{listings}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
%\usepackage{amsmath}
\usepackage{mathpartir}

\lstdefinestyle{custom_lang}{
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\ttfamily,
  keywordstyle=\bfseries
}

\lstset{emph={%  
    var, def, type, new, self%
    },emphstyle={\bfseries \tt}%
}

\begin{document}





\section{Type Members}

\section{Counter Examples to Preservation}
	\label{s:examples}

\subsection{Term Membership Restriction}
Figure \ref{f:mem} gives the \emph{Membership} judgement. 
$\Gamma \vdash e \ni \sigma$ says that an expression $e$ 
has $\sigma_i$ as a member of its type in environment $\Gamma$. 
There are two rules for membership. By \textsc{M-Path} a 
variable $x$ has a member of type $[x/\texttt{self}]\sigma_i$ 
if $\sigma_i$ is a member of the type of $x$. By \textsc{M-Exp}
an expression $e$ has member $\sigma_i$ if $\sigma_i$ is 
a member of $e$'s type, and \texttt{self} does not occur 
within $\sigma_i$.

This is reasonable since we cannot substitute a non-value 
expression into a selection type such as $\texttt{self}.L$. 
This does however present a counter-example to preservation. 
Given two types $X$ and $Y$,

\begin{lstlisting}[mathescape, style=custom_lang]
Y = {self $\Rightarrow$
     var l : $\top$
     def m : Y(y:Y){
       var a = new {};
       y
     }
    }
\end{lstlisting}
\begin{lstlisting}[mathescape, style=custom_lang]
X = {self $\Rightarrow$
     type L : $\top$ .. $\top$
     var l : self.L
     def m : Y(y:Y){
       y
     }
    }
\end{lstlisting}

the following expression is well typed.
\begin{lstlisting}[mathescape, style=custom_lang]
var x = new X(l = z);
var y = new Y(l = (var z = new {}; z));
y.m(x).l
\end{lstlisting}
We can see that this is well-typed, and in particular that membership 
holds for \texttt{y.m(x)} and \texttt{l}. This reduces to 
\begin{lstlisting}[mathescape, style=custom_lang]
(var a = new {}; x).l
\end{lstlisting}
which is not well-typed since \texttt{var a = new {}; x} has type 
\texttt{X}, and \texttt{X.l} contains a \texttt{self} reference 
\texttt{self.L}.

\subsection{Expansion Lost}
\subsection{Well-Formedness Lost}

\subsection{Path Equality}

\begin{lstlisting}[mathescape, style=custom_lang]
var b = new {self $\Rightarrow$
             type L : $\top$ .. $\top$
             var l : self.L = b};
var a = new {self $\Rightarrow$
             var i : {self $\Rightarrow$
                      type L : $\bot$ .. $\top$
                      var l : self.L} = b};
var x = new {self $\Rightarrow$}

\end{lstlisting}



\section{Type System}
	\label{s:type_sys}


\subsection{Syntax}


\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expression \\
& | & \texttt{var} \; x = \texttt{new} \; \{\texttt{self} \Rightarrow \overline{d}\}; \; e&\\
%& | & \lambda x:T = e\\
%& | & e(e)\\
& | & e.m(e) &\\
& | & e.f &\\
& | & e.f = e&\\
& | & e \unlhd T&\\
%& | & l &\\
&&\\
p & ::= & x & paths \\
& | & p.f &\\
&&\\
v & ::= & p & value \\
&&\\
d & ::= & \texttt{var} \; f : T = e & declaration \\
  & |   & \texttt{def} \; m : T(x:T) = e &\\
  & |   & \texttt{type} \; L : T .. T = T &\\
&&\\
d_v & ::= & \texttt{var} \; f : T = v & declaration \; value \\
  & |   & \texttt{def} \; m : T(x:T) = e &\\
  & |   & \texttt{type} \; L : T .. T = T &\\
&&\\
%p & ::= & x & path \\
%  & | & l & \\
&&\\
\Gamma & :: = & \varnothing \; | \; \Gamma, \; x : T & context \\
&&\\
\mu & :: = & \varnothing \; | \; \mu,\; l \mapsto \{\texttt{self} \Rightarrow \overline{d}\} & store \\
\end{array}
& ~~~~~~
&
\begin{array}{lllr}
%T & ::= & \{\texttt{self} \Rightarrow \overline{\sigma}\} & type \\
T & ::= & \{\texttt{self} \Rightarrow \overline{\sigma}\} & type \\
& | & p.L &\\
& | & \top & \\
& | & \bot & \\
&&\\
\sigma & ::= & \texttt{var} \; f:T & decl \; type\\
       & |   & \texttt{def} \; m:T \rightarrow T \\
		 & |   & \texttt{type} \; L : T .. T &\\
&&\\
E & :: = & [\;] & evaluation \; context \\
       & | & \texttt{var} \; x = \texttt{new} \; \{\texttt{self} \Rightarrow \overline{D}\}; \; e& \\
       & | & E.m(e)\\
       & | & v.m(E)\\
       & | & E.f\\
       & | & E.f = e\\
       & | & v.f = E\\
       & | & E \unlhd T\\
&&\\
D & :: = & [\;] & decl \; evaluation \; context \\
       & | & \texttt{var} \; f : T = E\\
&&\\
\Delta & :: = & \varnothing \; | \; \Delta,\; x \mapsto l & substitution \; context \\
&&\\
\Sigma & :: = & \varnothing \; | \; \Sigma,\; l : T & store \; context \\
\end{array}
\end{array}
\]

\subsection{Semantics}
%\subsubsection{Subtyping}

\input{subtype}

\input{wf}

\input{exp}

%\subsubsection{Typing}

\input{typing}

\input{reduction}


%\section{Type Safety}
%
%\subsection{Subject Reduction}
%
%
%\begin{theorem}[Subject Reduction]
%If $\Sigma; \Gamma;  \vdash e : T$, 
%   	$\Delta; \; \mu \; | \; e \rightarrow \Delta'; \; \mu' \; | \; e'$ where
%	$\Gamma \vdash \mu : \Sigma$ then 
% 	$\exists \Gamma', \Sigma', T'$ s.t. 
%	$\Sigma'$ extends $\Sigma$,
%	$\Gamma'$ extends $\Gamma$,
%	$\Sigma'; \Gamma';  \vdash e' : T'$
%	and $\Gamma' \vdash T'<:T$.
%\end{theorem}
%\begin{proof}
%By induction on 	$\Delta; \; \mu \; | \; e \rightarrow \Delta'; \; \mu' \; | \; e'$.
%\begin{case}[\textsc{R-New}]
%%\\ \fbox{
%\begin{mathpar}
%\inferrule
%  {}
%  {e := \texttt{var} \; y = \texttt{new} \; \{\texttt{self} \Rightarrow \overline{d}\}; e \\
%	e' := e\\
%	\mu' = \mu, l \mapsto \{\texttt{self} \Rightarrow \overline{d}\} \\
%  	\Delta' = \Delta, y \mapsto l\\
%	\Delta; \; \Sigma; \; \Gamma, \texttt{self} : \{\texttt{self} \Rightarrow \overline{\sigma}\} \vdash \overline{d} : \overline{\sigma}\\
%	\Sigma; \; \Gamma, y : \{\texttt{self} \Rightarrow \overline{\sigma}\} \vdash e : T}
%\end{mathpar}
%
%Let $\Sigma' = \Sigma, l \mapsto \{\texttt{self} \Rightarrow \overline{\sigma}\}$ and 
%$\Gamma' = \Gamma, y : \{\texttt{self} \Rightarrow \overline{\sigma}\}$. 
%$\therefore \Sigma'; \Gamma';  \vdash e' : T$ and
%$\Gamma' \vdash T<:T$ by reflexivity.
%%}
%\end{case}
%\begin{case}[\textsc{R-Meth}]
%\begin{mathpar}
%\inferrule
%  {}
%  {e := y.m(z)\\
%	e' := [y/\texttt{self},z'/x]e\\
%	\mu(\Delta(y)) = \{\texttt{self} \Rightarrow ...,m:T(x:S)=e,...\}\\
%   \Delta(z) = l' \\
%  	z' \notin dom(\Delta)\\
%  	\Delta' = \Delta,z' \mapsto l'}
%\end{mathpar}
%
%Let $\Gamma' = \Gamma, z' : S$, $\Sigma' = \Sigma$ and $T' = T$. Since 
%$\Sigma; \Gamma;  \vdash y.m(z) : T$, the following hold (\textsc{T-Meth}):
%\begin{mathpar}
%\inferrule
%  {}
%  {\Sigma; \; \Gamma \vdash z : S \\
%  	\Sigma; \; \Gamma \vdash y : T_0 \\
%  	T_0 \ni \texttt{def} \; m:S \rightarrow T}
%\end{mathpar}
%
%Since $\Gamma \vdash \mu : \Sigma$ and $\Sigma \; \textbf{wf}$ it
%follows that $\Gamma \vdash T : \textbf{wf}$, and thus that 
%$\Gamma, z' : S \vdash T : \textbf{wf}$. 
%
%\end{case}
%\begin{case}[\textsc{R-Var}]
%\end{case}
%\begin{case}[\textsc{R-Var}]
%\end{case}
%\begin{case}[\textsc{R-Assign}]
%\end{case}
%\begin{case}[\textsc{R-Context}]
%\end{case}
%\end{proof}
%
%\subsection{Progress}
%\begin{theorem}[Progress]
%If $\Delta; \Sigma; \Gamma;  \vdash e : T$, then either
%\begin{enumerate}
%\item e is a value, or
%\item $\forall \mu$ s.t.
%		   $\Delta; \; \Gamma \vdash \mu : \Sigma$,
%         $\exists e', \mu', \Delta'$ s.t. 
%         $\Delta; \; \mu \; | \; e \rightarrow \Delta'; \; \mu' \; | \; e'$
%\end{enumerate}
%\end{theorem}



\bibliographystyle{plain}
\bibliography{bib}

\end{document}