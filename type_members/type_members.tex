\documentclass{llncs}

\usepackage{listings}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
%\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{mathpartir}




\lstdefinestyle{custom_lang}{
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\ttfamily,
  keywordstyle=\bfseries
}

\lstset{emph={%  
    var, def, type, new, z%
    },emphstyle={\bfseries \tt}%
}

\begin{document}





\section{Type Members}

\section{Counter Examples to Preservation}
	\label{s:examples}

\subsection{Term Membership Restriction}
Figure \ref{f:mem} gives the \emph{Membership} judgement. 
$\Gamma \vdash e \ni \sigma$ says that an expression $e$ 
has $\sigma_i$ as a member of its type in environment $\Gamma$. 
There are two rules for membership. By \textsc{M-Path} a 
variable $x$ has a member of type $[x/\texttt{z}]\sigma_i$ 
if $\sigma_i$ is a member of the type of $x$. By \textsc{M-Exp}
an expression $e$ has member $\sigma_i$ if $\sigma_i$ is 
a member of $e$'s type, and \texttt{z} does not occur 
within $\sigma_i$.

This is reasonable since we cannot substitute a non-value 
expression into a selection type such as $\texttt{z}.L$. 
This does however present a counter-example to preservation. 
Given two types $X$ and $Y$,

\begin{lstlisting}[mathescape, style=custom_lang]
Y = {z $\Rightarrow$
     var l : $\top$
     def m : Y(y:Y){
       var a = new {};
       y
     }
    }
\end{lstlisting}
\begin{lstlisting}[mathescape, style=custom_lang]
X = {z $\Rightarrow$
     type L : $\top$ .. $\top$
     var l : z.L
     def m : Y(y:Y){
       y
     }
    }
\end{lstlisting}

the following expression is well typed.
\begin{lstlisting}[mathescape, style=custom_lang]
var x = new X(l = z);
var y = new Y(l = (var z = new {}; z));
y.m(x).l
\end{lstlisting}
We can see that this is well-typed, and in particular that membership 
holds for \texttt{y.m(x)} and \texttt{l}. This reduces to 
\begin{lstlisting}[mathescape, style=custom_lang]
(var a = new {}; x).l
\end{lstlisting}
which is not well-typed since \texttt{var a = new {}; x} has type 
\texttt{X}, and \texttt{X.l} contains a \texttt{z} reference 
\texttt{z.L}.

\subsection{Expansion Lost}
\subsection{Well-Formedness Lost}

\subsection{Path Equality}
The example below illustrates the problem with path equality.
\begin{lstlisting}[mathescape, style=custom_lang]
var b = new {z $\Rightarrow$
             type L : $\top$ .. $\top$
             var l : z.L = b};
var a = new {z $\Rightarrow$
             var i : {z $\Rightarrow$
                      type L : $\bot$ .. $\top$
                      var l : z.L} = b
             def meth : $\top$ (x : z.i.L)z.i};
a.meth(b.l)
\end{lstlisting}
Even though we initialize a.i as b, we are unable to determine if
a.i and b are equivalent paths, hence we cannot ensure that b.L subtypes 
a.i.L.

\subsection{Path Equality Redux}
\begin{lstlisting}[mathescape, style=custom_lang]
var n = new {z $\Rightarrow$ type X : $\top$ .. $\top$};
var a = new {z $\Rightarrow$
             type Y : {z $\Rightarrow$ type X : $\bot$ .. $\top$} .. {z $\Rightarrow$ type X : $\bot$ .. $\top$}
             var i : z.Y = n};
var b = new {z $\Rightarrow$
             type L : $\bot$ .. {z $\Rightarrow$ type Y : {z $\Rightarrow$ type X : $\bot$ .. $\top$} .. 
                                          {z $\Rightarrow$ type X : $\bot$ .. $\top$}
                                 var i : z.Y}
             var j : z.L = a};
var c = new {z $\Rightarrow$
             var k : {z $\Rightarrow$
                      type L : $\bot$ .. {z $\Rightarrow$ type Y : {z $\Rightarrow$ type X : $\bot$ .. $\top$} .. 
                                                   {z $\Rightarrow$ type X : $\bot$ .. $\top$}
                                          var i : z.Y}
                      var j : z.L} = b
             def m : $\top$ (x : z.k.L){
                 var y = new {z $\Rightarrow$ var l : x.Y = x.i 
                            var m : x.i.X = new {z $\Rightarrow$}}; y
             }};
c.m(b.j)
\end{lstlisting}
%\begin{lstlisting}[mathescape, style=custom_lang]
%c.m(c.k.j) $\rightarrow$ c.m(b.j)
%\end{lstlisting} 
\texttt{b.j} has type \texttt{b.L}, therefore we need 
$\texttt{b.L} <: \texttt{c.k.L}$
\begin{lstlisting}[mathescape, style=custom_lang]
c.m(b.j) $\rightarrow$ c.m(a)
c.m(a) $\rightarrow$ (var y = new {z $\Rightarrow$ var l : (a $\unlhd$ c.k.L).Y = (a $\unlhd$ c.k.L).i 
                            var m : (a $\unlhd$ c.k.L).i.X = new {z $\Rightarrow$}}; y) $\unlhd$ $\top$
\end{lstlisting}
\section{Type System}
	\label{s:type_sys}


\subsection{Syntax}


\begin{figure}[h]
\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expression \\
& | & \texttt{var} \; x = \texttt{new} \; \{\texttt{z} \Rightarrow \overline{d}\}; \; e&\\
%& | & \lambda x:T = e\\
%& | & e(e)\\
& | & e.m(e) &\\
& | & e.f &\\
%& | & e.f = e&\\
& | & e \unlhd T&\\
%& | & l &\\
&&\\
p & ::= & x & paths \\
& | & p.f &\\
& | & p \unlhd T &\\
&&\\
v & ::= & x & value \\
& | & v.f &\\
&&\\
d & ::= & \texttt{var} \; f : T = e & declaration \\
  & |   & \texttt{def} \; m : T(x:T) = e &\\
  & |   & \texttt{type} \; L : T .. T = T &\\
&&\\
d_v & ::= & \texttt{var} \; f : T = x & declaration \; value \\
  & |   & \texttt{def} \; m : T(x:T) = e &\\
  & |   & \texttt{type} \; L : T .. T = T &\\
&&\\
%p & ::= & x & path \\
%  & | & l & \\
&&\\
\Gamma & :: = & \varnothing \; | \; \Gamma, \; x : T & context \\
&&\\
\mu & :: = & \varnothing \; | \; \mu,\; x \mapsto \{\texttt{z} \Rightarrow \overline{d}\} & store \\
\end{array}
& ~~~~~~
&
\begin{array}{lllr}
%T & ::= & \{\texttt{z} \Rightarrow \overline{\sigma}\} & type \\
T & ::= & \{\texttt{z} \Rightarrow \overline{\sigma}\} & type \\
& | & p.L &\\
& | & T \wedge T & \\
& | & \top & \\
& | & \bot & \\
&&\\
\sigma & ::= & \texttt{var} \; f:T & decl \; type\\
       & |   & \texttt{def} \; m:T \rightarrow T \\
		 & |   & \texttt{type} \; L : T .. T &\\
&&\\
E & :: = & \bigcirc & eval \; context\\
       & | & E.m(e)\\
       & | & v.m(E)\\
       & | & E.f\\
%       & | & E.f = e\\
%       & | & v.f = E\\
       & | & E \unlhd T\\
       & | & \texttt{var} \; x = \texttt{new} \; \{\texttt{z} \Rightarrow \overline{D}\}; \; e & eval \; context \\
       & | & \texttt{var} \; x = \texttt{new} \; \{\texttt{z} \Rightarrow \overline{d_v}\}; \; E& \\
&&\\
D & :: = & \texttt{var} \; f : T = E & decl \; eval \; context \\
  & |   & \texttt{def} \; m : T(x:T) = e &\\
  & |   & \texttt{type} \; L : T .. T = T &\\
%&&\\
%K & :: = & \varnothing \; | \; K, \; E & evaluation \; stack \\
%\Delta & :: = & \varnothing \; | \; \Delta,\; x \mapsto l & substitution \; context \\
%&&\\
%\Sigma & :: = & \varnothing \; | \; \Sigma,\; l : T & store \; context \\
\end{array}
\end{array}
\]
\caption{Syntax}
\label{f:syntax}
\end{figure}


\begin{figure}[h]
\begin{mathpar}
\inferrule
  {}
  {path(\mu, x) = \mu(x)}
	\and
\inferrule
  {}
  {path(\mu, p \unlhd T) = path(\mu, p)}
	\and
\inferrule
  {\mu(path(\mu, p)) = \{z \Rightarrow \overline{d}\} \\
	\texttt{var} \; f : T = x \in \overline{d}}
  {path(\mu, p.f) = x}
\end{mathpar}
\caption{Path Function}
\label{f:path}
\end{figure}
%\begin{figure}[h]
%\begin{mathpar}
%\inferrule
%  {}
%  {narrow(x) = x \\ narrow(v \unlhd T) = narrow(v)}
%\end{mathpar}
%\caption{Narrow Function}
%\label{f:narrow}
%\end{figure}

\subsection{Semantics}
%\subsubsection{Subtyping}

\input{subtype}

\input{wf}

\input{exp}

%\subsubsection{Typing}

\input{typing}

\input{reduction}


\section{Type Safety}

\subsection{Subject Reduction}

\begin{theorem}[Subtype Reflexivity]
 	If $\Gamma \vdash T \; \textbf{\tt{wfe}}$ then $\Gamma \vdash T <: T$
\end{theorem}
\begin{proof}
This is easy to demonstrate using \textsc{S-Struct}.
\end{proof}

\begin{theorem}[Subtype Transitivity]
If $\Gamma \vdash S, T, U \; \textbf{\tt{wfe}}$,
	$\Gamma \vdash S <: T$ and 
   	$\Gamma \vdash T <: U$ then
	$\Gamma \vdash S <: U$
\end{theorem}
\begin{proof}
Proceed by mutual induction $\Gamma \vdash S <: T$  and declaration subtyping.
\begin{case}[\textsc{S-Struct}]
\begin{mathpar}
\inferrule
  {\Gamma \vdash S \prec \overline{\sigma} \\
  	\Gamma \vdash T \prec \overline{\sigma'} \\
  	\forall \sigma'_i \in \overline{\sigma'}, \; 
  	\exists \sigma_i \in \overline{\sigma}, \; s.t. \;
  	\Gamma \vdash \sigma_i \; <: \; \sigma'_i \\
	\Gamma \vdash T <: U }
  {}
\end{mathpar}
With our induction hypothesis:
\begin{mathpar}
\inferrule
  {\forall \sigma, \; \Gamma \vdash \sigma'_i <: \sigma \; \Rightarrow
	\Gamma \vdash \sigma_i <: \sigma}
  {}
\end{mathpar}
By induction on $\Gamma \vdash T <: U$.
\begin{itemize}
\item[]  \textit{Subcase 1} (\textsc{S-Struct}): 
\begin{mathpar}
\inferrule
  {\Gamma \vdash U \prec \overline{\sigma''} \\
  	\forall \sigma''_i \in \overline{\sigma''}, \; 
  	\exists \sigma'_i \in \overline{\sigma'}, \; s.t. \;
  	\Gamma \vdash \sigma'_i \; <: \; \sigma''_i}
  {}
\end{mathpar}
Let $\sigma''_i \in \overline{\sigma''}$. 
It follows from above that there exists a 
$\sigma'_i \in \overline{\sigma'}$ such that 
$\Gamma \vdash \sigma'_i \; <: \; \sigma''_i$.
By our original assumption there exists some 
$\sigma_i \in \overline{\sigma}$ such that 
$\Gamma \vdash \sigma_i \; <: \; \sigma'_i$. 
It follows by our induction hypothesis that 
$\Gamma \vdash \sigma_i \; <: \; \sigma''_i$. 
Therefore by \textsc{S-Struct} $\Gamma \vdash S <: U$.
\\
\item[]  \textit{Subcase 2} (\textsc{S-Select-Lower}): 
\begin{mathpar}
\inferrule
  {U = p.L \\
	\Gamma \vdash p \ni \texttt{type} \; L : S' .. U' \\
  	\Gamma \vdash T <: S'}
  {}
\end{mathpar}
With our induction hypothesis:
\begin{mathpar}
\inferrule
  {\Gamma \vdash S <: S'}
  {}
\end{mathpar}
Therefore, by \textsc{S-Select-Lower}, $\Gamma \vdash S <: p.L$, i.e. 
$\Gamma \vdash S <: U$
\\
\item[]  \textit{Subcase 3} (\textsc{S-Bottom}): 
\begin{mathpar}
\inferrule
  {T = \bot}
  {}
\end{mathpar}
This forms a contradiction since $T$ is well-formed and expanding,
and $\bot$ is not.
\\
\end{itemize}
\end{case}
%\begin{case}[\textsc{S-Refl}]
%\begin{mathpar}
%\inferrule
%  {}
%  {S = T \\
%	\Gamma \vdash T\; <: \; T \\
%	\Gamma \vdash T <: U}
%\end{mathpar}
%This follows automatically from our assumption.
%\end{case}
%\begin{case}[\textsc{S-Rec}]
%\begin{mathpar}
%\inferrule
%  {S = \{\texttt{z} \Rightarrow \overline{\sigma}\} \\
%	T = \{\texttt{z} \Rightarrow \overline{\sigma'}\} \\
%	\forall \sigma_i' \in \overline{\sigma}', \; \exists \; \sigma_i \in \overline{\sigma} \; 
%	st \; \Gamma, \texttt{z} : \{\texttt{z} \Rightarrow \overline{\sigma}\} \vdash 
%	\sigma_i <:\; \sigma_i' \\
%	\Gamma \vdash T <: U}
%  {}
%\end{mathpar}
%\end{case}
%\begin{case}[\textsc{S-Select-Upper}]
%\end{case}
\begin{case}[\textsc{S-Select-Lower}]
\begin{mathpar}
\inferrule
  {T = p.L \\
	\Gamma \vdash p \ni \texttt{type} \; L : S' .. U' \\
  	\Gamma \vdash S <: S' \\
	\Gamma \vdash p.L <: U}
  {}
\end{mathpar}
With our induction hypothesis:
\begin{mathpar}
\inferrule
  {\forall U'', \Gamma \vdash S' <: U'' \Rightarrow \Gamma \vdash S <: U''}
  {}
\end{mathpar}
%Complete proof for S-Select-Lower
\end{case}
%\begin{case}[\textsc{S-Top}]
%\begin{mathpar}
%\inferrule
%  {T = \top \\
%	\Gamma \vdash \top <: U}
%  {}
%\end{mathpar}
%\end{case}
\begin{case}[\textsc{S-Bottom}]
\begin{mathpar}
\inferrule
  {S = \bot\\
	\Gamma \vdash T <: U}
  {}
\end{mathpar}
This forms a contradiction since $S$ is well-formed and expanding, and 
$\bot$ is not.
\end{case}
\end{proof}

\begin{theorem}[Subject Reduction]
If $\Gamma \vdash e : T$, 
   	$\mu \; | \; e \; \rightarrow \mu' \; | \; e'$ where
	$\Gamma \vdash \mu$ then 
 	$\exists \Gamma', T'$ s.t. 
	$\Gamma'$ extends $\Gamma$, 
	$\Gamma' \vdash \mu'$, 
	$\Gamma' \vdash e' : T'$ 
	and $\Gamma' \vdash T'<:T$.
\end{theorem}
\begin{proof}
By induction on $\Delta; \; \mu \; | \; e \rightarrow \Delta'; \; \mu' \; | \; e'$.
\begin{case}[\textsc{R-New}]
\end{case}
\begin{case}[\textsc{R-Meth}]
\end{case}
\begin{case}[\textsc{R-Narrow}]
\end{case}
\begin{case}[\textsc{R-Context}]
\end{case}
\end{proof}

\subsection{Progress}
\begin{theorem}[Progress]
If $\Gamma \vdash e : T$, then either
\begin{enumerate}
\item e is a value, or
\item $\forall \mu$ s.t.
		   $\Gamma \vdash \mu$,
         $\exists e'$ and $\mu'$ s.t. 
         $\mu \; | \; e \; \rightarrow \mu' \; | \; e'$
\end{enumerate}
\end{theorem}



\bibliographystyle{plain}
\bibliography{bib}

\end{document}