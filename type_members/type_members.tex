\documentclass{llncs}

\usepackage{listings}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
%\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{mathpartir}




\lstdefinestyle{custom_lang}{
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\ttfamily,
  keywordstyle=\bfseries
}

\lstset{emph={%  
    val, def, type, new, z%
    },emphstyle={\bfseries \tt}%
}

\begin{document}





\section{Type Members}
Type members are object members that are types. 
In the same way that an object can have value or 
method members, type members define types. Similar 
to traditional method member declarations, type 
members can be either abstract or concrete. That is, 
types can include type members without specifying 
a concrete type for that type member. Using a 
familiar Java-like syntax, this can be seen below.
\begin{lstlisting}[mathescape, style=custom_lang]
Pair = {
  type F;
  type S;
  val F fst;
  val S snd;

  public void setFst(F fst){
    this.fst = fst;
  }
  public void setSnd(S snd){
    this.snd = snd;
  }
}
\end{lstlisting}
We have not specified a concrete type for \texttt{F},
yet we can still use \texttt{F} to assign a value to 
\texttt{fst}.
As seen above, type members 
can be used in much the same way as traditional Java 
generic type parameters. The above example could be 
written in Java Generics like this.
\begin{lstlisting}[mathescape, style=custom_lang]
public class Pair<F,S>{
  F fst;
  S snd;

  public Pair(F fst, S snd){
    this.fst = fst;
    this.snd = snd;
  }

  public void setFst(F fst){
    this.fst = fst;
  }
  public void setSnd(S snd){
    this.snd = snd;
  }
}
\end{lstlisting}
So then what are the differences between type members 
and type parameters?

\subsection{Type members vs Type Parameters}
When we use generic type parameters in the above example, 
if we want to use Pair, we declare  
concrete types for \texttt{F} and \texttt{S}.
\begin{lstlisting}[mathescape, style=custom_lang]
Pair<Double, Double> p1 = new Pair<Double, Double>(1, 2);
\end{lstlisting}
Because of issues with contra-variance and co-variance, 
generic type parameters are required to be invariant with 
regard to subtyping. So the example below would result in 
an error at compile time. 
\begin{lstlisting}[mathescape, style=custom_lang]
Pair<Integer, Integer> p2 = new Pair<Integer, Integer>(1, 2);
p1 = p2; \\ Compile time error
\end{lstlisting}
If we didn't restrict this, we could make the following 
ill-typed call on \texttt{p1}.
\begin{lstlisting}[mathescape, style=custom_lang]
...
p1 = p2;
p1.setFst(1.1);
\end{lstlisting}
We can construct this example using type members.
\begin{lstlisting}[mathescape, style=custom_lang]
DoublePair = {
  type F = Double;
  type S = Double;
  val F fst;
  val S snd;

  public void setFst(F fst){
    this.fst = fst;
  }
  public void setSnd(S snd){
    this.snd = snd;
  }
}
IntegerPair = {
  type F = Integer;
  type S = Integer;
  val F fst;
  val S snd;

  public void setFst(F fst){
    this.fst = fst;
  }
  public void setSnd(S snd){
    this.snd = snd;
  }
}
...
DoublePair p1 = new DoublePair{val fst = 1; val fst = 2};
IntegerPair p2 = new IntegerPair{val fst = 1; val fst = 2};
...
\end{lstlisting}
We can allow a co-variant subtyping relationship 
on type members because type members allow us to 
maintain type information at run time \cite{Bruce:1998}. So now %cite: A Statically Safe Alternative to Virtual Types
\begin{lstlisting}[mathescape, style=custom_lang]
p1 = p2;
\end{lstlisting}
is allowed, but if we subsequently make an ill-typed 
write
\begin{lstlisting}[mathescape, style=custom_lang]
p1.setFst(1.1); \\ Runtime error
\end{lstlisting}
it can be caught at run time because objects maintain 
generic type information in the form of type members.
This allows us to write more expressive code. For example 
we could construct a list of pairs without declaring 
a concrete type that all pair elements should conform to.
\begin{lstlisting}[mathescape, style=custom_lang]
public class PairList{
  ...
  public void add(p : Pair){...}
  public Pair get(i : integer){...}
  ...
}
\end{lstlisting}
Using type parameters we would have to declare all 
types as the same (e.g. \texttt{List<Pair<Integer,Integer>>}) 
which restricts us to elements only of that type. Otherwise 
we could make all elements the top level type (\texttt{Object} 
in Java) which doesn't allow us access to the members 
of our elements.

Type members also allow us to refer to generic types without explicitly 
bringing them into scope, or know the actual concrete type 
being used. As an example, suppose we want to write a method that copies  
pairs.
\begin{lstlisting}[mathescape, style=custom_lang]
...
public Pair copyPair(p : Pair){
  return new Pair{type F = p.F; 
                  type F = p.F;
                  val fst = p.fst; 
                  val snd = p.snd;}
}
...
\end{lstlisting}
If we were to try to do the same using generic type parameters
we get
\begin{lstlisting}[mathescape, style=custom_lang]
...
public Pair<F,S> copyPair(p : Pair<F,S>){
  return new Pair<F,S>(p.fst, p.snd);
}
...
\end{lstlisting}
Here we have to explicitly introduce a type parameter to the 
method signature for each unknown generic type explicitly.
So we can see how type parameters can result in large 
numbers of type parameters  \cite{odersky:2009} %cite: http://www.artima.com/weblogs/viewpost.jsp?thread=270195
depending on the unknown type variables being used.

\subsection{Type Members in Wyvern}
Wyvern is a structurally typed object oriented language. We 
include type members in the Wyvern type system to provide 
generic polymorphism. Type members in Wyvern are based on 
those in Scala \cite{Amin:2012}\cite{Amin:2014}.

\section{Counter Examples to Preservation}
	\label{s:examples}

\subsection{Term Membership Restriction}
	\label{s:term_mem}
Figure \ref{f:mem} gives the \emph{Membership} judgement. 
$\Gamma \vdash e \ni \sigma$ says that an expression $e$ 
has $\sigma_i$ as a member of its type in environment $\Gamma$. 
There are two rules for membership. By \textsc{M-Path} a 
variable $x$ has a member of type $[x/\texttt{z}]\sigma_i$ 
if $\sigma_i$ is a member of the type of $x$. By \textsc{M-Exp}
an expression $e$ has member $\sigma_i$ if $\sigma_i$ is 
a member of $e$'s type, and \texttt{z} does not occur 
within $\sigma_i$.

This is reasonable since we cannot substitute a non-value 
expression into a selection type such as $\texttt{z}.L$. 
This does however present a counter-example to preservation. 
Given two types $X$ and $Y$,

\begin{lstlisting}[mathescape, style=custom_lang]
Y = {z $\Rightarrow$
     val l : $\top$
     def m : Y(y:Y){
       val a = new {};
       y
     }
    }
\end{lstlisting}
\begin{lstlisting}[mathescape, style=custom_lang]
X = {z $\Rightarrow$
     type L : $\top$ .. $\top$
     val l : z.L
     def m : Y(y:Y){
       y
     }
    }
\end{lstlisting}

the following expression is well typed.
\begin{lstlisting}[mathescape, style=custom_lang]
val x = new X(l = z);
val y = new Y(l = (val z = new {}; z));
y.m(x).l
\end{lstlisting}
We can see that this is well-typed, and in particular that membership 
holds for \texttt{y.m(x)} and \texttt{l}. This reduces to 
\begin{lstlisting}[mathescape, style=custom_lang]
(val a = new {}; x).l
\end{lstlisting}
which is not well-typed since \texttt{val a = new {}; x} has type 
\texttt{X}, and \texttt{X.l} contains a \texttt{z} reference 
\texttt{z.L}.

After patching we allow expressions to maintain original type. 
Expressions are then typed with respect to the original type.
This is given in Figure \ref{f:syntax} as $e \unlhd T$ where 
$T$ is the original type. The patched reduction is given in 
Figure \ref{f:red}. The amended method reduction \textsc{R-Meth} is 
shown below.
\begin{mathpar}
\inferrule
  {\mu(path(\mu, v_1)) = \{\texttt{z} \Rightarrow ...,m:T(x:S)=e,...\}}
  {\mu \; | \; v_1.m(v_2) \;\rightarrow \mu \; | \; [v_1/\texttt{z},v_2 \unlhd S/x]e \unlhd T}
  \quad (\textsc {R-Meth})
\end{mathpar}
This is very similar to the standard method reduction. The two main 
differences are the introduction of the $path$ function, and the 
inclusion of the original types in the returned expression. For now 
ignore the $path$ function, this is explained in \ref{s:patheq}.

We retrieve the method for the receiver from the store, and substitute 
the method parameter into the body. The method parameter retains it's 
original type ($v_2 \unlhd S$) as does the entire returned body 
$[v_1/\texttt{z},v_2 \unlhd S/x]e \unlhd T$. Using this rule we 
can attempt to evaluate our original example.
\begin{lstlisting}[mathescape, style=custom_lang]
val x = new X(l = z);
val y = new Y(l = (val z = new {}; z));
y.m(x).l
\end{lstlisting}
reduces to
\begin{lstlisting}[mathescape, style=custom_lang]
((val a = new {}; (x $\unlhd$ Y))$\unlhd$ Y).l
\end{lstlisting}
Now we can treat the method body as having type \texttt{Y} and 
we can determine membership of \texttt{l} for \texttt{Y} rather 
than \texttt{X}.

\subsection{Expansion Lost}
For preservation to hold, we need to ensure that types are expandable 
to lists of declarations. This is captured in Figure \ref{f:wfe}. It is 
possible for expansion to be lost during environment narrowing. This is 
shown in \cite{Amin:2012}, but is briefly covered again below.
\begin{lstlisting}[mathescape, style=custom_lang]
X = {z $\Rightarrow$
     type A : $\bot$ .. z.B
     type B : $\bot$ .. $\top$
    }
Y = {z $\Rightarrow$
     type A : $\bot$ .. $\top$
     type B : $\bot$ .. z.A
    }
\end{lstlisting}
While both these types are expandable, their union is not.
\begin{lstlisting}[mathescape, style=custom_lang]
X $\wedge$ Y = {z $\Rightarrow$
         type A : $\bot$ .. z.B
         type B : $\bot$ .. z.A
        }
\end{lstlisting}
While we could not type this normally, we can create this 
scenario during environmental narrowing that results in 
an a type without an expansion, providing a counter-example 
to preservation.
\begin{lstlisting}[mathescape, style=custom_lang]
W = {z $\Rightarrow$
     type A : $\bot$ .. $\top$
     type B : $\bot$ .. $\top$
    }
\end{lstlisting}
Looking at the following expression, we can see it is well-type, 
and the type \texttt{i.L} $\wedge$ \texttt{x.K} in particular is 
well-formed and expanding.
\begin{lstlisting}[mathescape, style=custom_lang]
val x = new {z $\Rightarrow$ type K : $\bot$ .. X};
val y = new {z $\Rightarrow$ type L : $\bot$ .. Y};
val w = new {z $\Rightarrow$ type L : $\bot$ .. W};
val c = new {z $\Rightarrow$
         def meth1 : $\top$ (i : {z $\Rightarrow$ type L : $\bot$ .. W}){
           val d = new {z $\Rightarrow$
                        def meth2 : $\top$ (j : i.L $\wedge$ x.K){
                          j
                        }
                       };
           d
         }
        };
c.meth1(y)
\end{lstlisting}
Evaluating the above expression results in the following.
\begin{lstlisting}[mathescape, style=custom_lang]
val d = new {z $\Rightarrow$
             def meth2 : $\top$ (j : y.L $\wedge$ x.K){
               j
             }
            };
d
\end{lstlisting}
Now the type \texttt{y.L} $\wedge$ \texttt{x.K} gives us the loss of 
expansion we were attempting to construct. In our new patched calculus, 
this problem does not occur because the original type of the \texttt{i} 
parameter is maintained. So if we re-evaluate the original expression 
with our type system, we get the following.
\begin{lstlisting}[mathescape, style=custom_lang]
val d = new {z $\Rightarrow$
             def meth2 : $\top$ (j : (y $\unlhd$ {z $\Rightarrow$ type L : $\bot$ .. W}).L $\wedge$ x.K){
               j
             }
            };
d
\end{lstlisting}
The type \texttt{(y} $\unlhd$ \texttt{\{z} $\Rightarrow$ 
\texttt{type L :} $\bot$ \texttt{.. W\}).L} $\wedge$ \texttt{x.K} is now 
both well-formed and expanding because it is the original type 
from our original expression.



\subsection{Expansion Lost Redux}
	\label{s:term_mem2}
First we define the following types.
\begin{lstlisting}[mathescape, style=custom_lang]
X = {z $\Rightarrow$
     def m(x : $\top$){var y = new {z $\Rightarrow$}}:$\top$
    }
Y = {z $\Rightarrow$
     type L : $\bot$ .. $\top$
     def m(x : $\top$){var y = new {z $\Rightarrow$}}:z.L
    }
\end{lstlisting}
Then we attempt to evaluate the following expression.
\begin{lstlisting}[mathescape, style=custom_lang]
var a = new {z $\Rightarrow$
              def meth(x:$\top$){val b = new Y}:X
            };
val c = new {z $\Rightarrow$};
a.meth(c).m(c)
\end{lstlisting}
This reduces to \texttt{a.meth(c).m(c)} which has type $\top$. 
Applying \textsc{R-Meth} we get \texttt{(val b = new Y $\unlhd$ X).m(c)}
which has type $\top$ and so is still well typed. This eventually reduces 
to \texttt{[z/b $\unlhd$ X](var y = new \{z $\Rightarrow$\}) $\unlhd$ z.L}.
Since during reduction on a method call of the form $v \unlhd T$
we retrieve the return type of the object ($v$) and 
not the type ($T$), the reduced expression has type \texttt{b $\unlhd$ X.L}. 
This type is allowed since \texttt{b $\unlhd$ X} is a path, but 
it does present a case of narrowing.

\subsection{Well-Formedness Lost}



\subsection{Path Equality}
\label{s:patheq}
The example below illustrates the problem with path equality.
\begin{lstlisting}[mathescape, style=custom_lang]
val b = new {z $\Rightarrow$
             type L : $\top$ .. $\top$
             val l : z.L = b};
val a = new {z $\Rightarrow$
             val i : {z $\Rightarrow$
                      type L : $\bot$ .. $\top$
                      val l : z.L} = b
             def meth : $\top$ (x : z.i.L){x}};
a.meth(a.i.l)
\end{lstlisting}
\texttt{a.i.l} reduces to \texttt{b.l} which has type \texttt{b.L}. 
There is no way for us to ensure that \texttt{b.L} <: \texttt{a.i.L}.
This presents a path equality problem for preservation.

Typing paths correctly requires that we maintain some information 
about the original paths. For this reason we don't evaluate paths 
in the calculus. We still however need to retrieve the correct object 
the path is pointing to during method reduction and object initialization. 
This is done by the \emph{path} function given in Figure \ref{f:path}. 
With a path and a store, we can find the object referenced by that path.
Below is the evaluation of the above example without evaluating paths.
\begin{lstlisting}[mathescape, style=custom_lang]
val b = new {z $\Rightarrow$
             type L : $\top$ .. $\top$
             val l : z.L = b};
val a = new {z $\Rightarrow$
             val i : {z $\Rightarrow$
                      type L : $\bot$ .. $\top$
                      val l : z.L} = b
             def meth : $\top$ (x : z.i.L){x}};
a.meth(a.i.l)
\end{lstlisting}
Reduces to \texttt{a.meth(a.i.l)} which type checks. \texttt{a.meth(a.i.l)}
reduces to \texttt{a.i.l}

\subsection{Path Equality Redux}
\begin{lstlisting}[mathescape, style=custom_lang]
val n = new {z $\Rightarrow$ type X : $\top$ .. $\top$};
val a = new {z $\Rightarrow$
             type Y : {z $\Rightarrow$ type X : $\bot$ .. $\top$} .. {z $\Rightarrow$ type X : $\bot$ .. $\top$}
             val i : z.Y = n};
val b = new {z $\Rightarrow$
             type L : $\bot$ .. {z $\Rightarrow$ type Y : {z $\Rightarrow$ type X : $\bot$ .. $\top$} .. 
                                          {z $\Rightarrow$ type X : $\bot$ .. $\top$}
                                 val i : z.Y}
             val j : z.L = a};
val c = new {z $\Rightarrow$
             val k : {z $\Rightarrow$
                      type L : $\bot$ .. {z $\Rightarrow$ type Y : {z $\Rightarrow$ type X : $\bot$ .. $\top$} .. 
                                                   {z $\Rightarrow$ type X : $\bot$ .. $\top$}
                                          val i : z.Y}
                      val j : z.L} = b
             def m : $\top$ (x : z.k.L){
                 val y = new {z $\Rightarrow$ val l : x.Y = x.i 
                            val m : x.i.X = new {z $\Rightarrow$}}; y
             }};
c.m(b.j)
\end{lstlisting}
%\begin{lstlisting}[mathescape, style=custom_lang]
%c.m(c.k.j) $\rightarrow$ c.m(b.j)
%\end{lstlisting} 
\texttt{b.j} has type \texttt{b.L}, therefore we need 
$\texttt{b.L} <: \texttt{c.k.L}$
\begin{lstlisting}[mathescape, style=custom_lang]
c.m(b.j) $\rightarrow$ c.m(a)
c.m(a) $\rightarrow$ (val y = new {z $\Rightarrow$ val l : (a $\unlhd$ c.k.L).Y = (a $\unlhd$ c.k.L).i 
                            val m : (a $\unlhd$ c.k.L).i.X = new {z $\Rightarrow$}}; y) $\unlhd$ $\top$
\end{lstlisting}


\newpage


While \emph{Java} does not support Type Members, \emph{Scala} does.
This can be seen as an extension of the mechanisms already used in 
a language such as Java. In Java we can define abstract method members, but 
are unable to pass a method as a parameter. We can pass values as 
parameters, but are unable to define abstract field members. We can pass 
types as parameters, but are unable to define abstract type members.
In Scala, all three can either be defined as members of a type, or 
can be passed as parameters. 

\subsection{Why Type Members?}
We use type members in Wyvern to allow for polymorphic types. 
Languages like Java and C\# allow for type parameters to create 
"generic" types that define an interface for a collection of types. 
Below is a basic version of the common \texttt{List} example.
\begin{lstlisting}[mathescape, style=custom_lang]
public class List<T>{
  public boolean add(elem : T){
    ...
  }

  public T get(){
    ...
  }
}
\end{lstlisting}
Here we define a generic class for a collection of \texttt{List} 
types. Now we can use it to initialize lists of \texttt{String} or 
\texttt{Integer} types.
\begin{lstlisting}[mathescape, style=custom_lang]
List<String> stringList = new List<String>();
List<Integer> integerList = new List<Integer>();

stringList.add("One");
integerList.add(1);
integerList.add("One"); \\Compilation Error
\end{lstlisting}
Below we use type members in place of type parametrization. 
\begin{lstlisting}[mathescape, style=custom_lang]
...
type List : $\bot$ .. {z $\Rightarrow$ type T : $\bot$ .. $\top$
                       def $\top$ add(elem : z.T){ ...}
                       get z.L(){...}}

def $\top$ createLists(){
  stringList = new {z $\Rightarrow$ type T : String .. String
                         def $\top$ add(elem : z.T){ ...}
                         get z.L(){...}};

  intergerList = new {z $\Rightarrow$ type T : Integer .. Integer
                           def $\top$ add(elem : z.T){ ...}
                           get z.L(){...}};

  stringList.add("One");
  integerList.add(1);
  integerList.add("One"); \\Compilation Error
}
...
\end{lstlisting}


\subsection{Path Dependent Types}


\subsection{Wyvern Type Members}

In this document we present a a structurally typed language with type 
members. In a structural type system, types are defined by their structure 
as opposed to their name in nominal type systems. Normally this means the 
field and method definitions they contain. When adding type members 
we extend this to include types. This work is based on and extends 
similar work done on type members in Scala \cite{Amin:2012}.
While Amin et. al.\cite{Amin:2014} developed a big step semantics and 
proved it sound, we hope to develop an altered type system in order to maintain 
a small step semantics while providing sound type members. 

Using Java Generics, we can define an upper bound in order to restrict 
possible types used. We could easily conceive a similar bound being 
used for type members. Below is an example using the syntax of the language 
presented in this document.
\begin{lstlisting}[mathescape, style=custom_lang]
var o = new {z => type L : S .. U}
\end{lstlisting}
We have created a new object \texttt{o} that has a single member, a type member 
\texttt{L}. \texttt{L} is restricted by two bounds, a lower bound \texttt{S} 
and an upper bound \texttt{U} (Where \texttt{S} and \texttt{U} are some types). 
Using an access on \texttt{o} we can now refer to 
\texttt{L}: \texttt{o.L}.
We could allow type member accesses to not only be made on  
an object, but a path \texttt{p} constructed from a series of field accesses.
Below we can see that the type member \texttt{L} refers to 
depends entirely on the path taken to retrieve it.
\begin{lstlisting}[mathescape, style=custom_lang]
var o1 = new {z => type L : S .. U}
var o2 = new {z => type L : S' .. U'}
\end{lstlisting}
Clearly \texttt{o1.L} $\neq$ \texttt{o2.L}


\subsection{Type Members in Wyvern}
Wyvern is a structurally typed programming language being 
developed concurrently with this work. Wyvern puts an emphasis 
on secure web applications. The type members described here 
is intended to be integrated into the wider development of the 
Wyvern Programming language.




\section{Type Members Examples}

\subsection{Removing Environment Narrowing}

A central issue in similar type systems thus far is maintaining 
type soundness in the presence of environment narrowing. Our 
proposed solution is to remove environment narrowing altogether.

An environment is narrowed when during reduction a variable is 
found to have a more precise type than originally assumed. This 
is common when passing arguments to a method, or when returning 
from a method call. In fact these are the two areas that environment 
narrowing must be removed. Below is a small example where we attempt to 
remove environment narrowing.
\begin{lstlisting}[mathescape, style=custom_lang]
Food = {z $\Rightarrow$ type IsFood : $\bot$ ... $\top$}

Recipe = {z $\Rightarrow$ type F : $\bot$ .. Food;
               def cook(){ ... } : z.F;}
               
Sushi = {z $\Rightarrow$ type IsFood : $\bot$ .. $\top$
              type IsSushi : $\bot$ .. $\top$}

SushiRecipe = {z $\Rightarrow$ type F : $\bot$ .. Sushi;
                    def cook()
                    {
                      new {z $\Rightarrow$ type IsFood : $\bot$ .. $\top$
                                type IsSushi : $\bot$ .. $\top$}
                    } : z.F;}
\end{lstlisting}
Above we have defined several types. In our current syntax 
it is not possible to define types like this, we just use this 
as short hand during the following examples for brevity. Bellow 
is an example using the above types, demonstrating the evaluation 
of method calls.
\begin{lstlisting}[mathescape, style=custom_lang]
...
def prepareFood (r : Recipe){
  r.cook();
} : Food;

def main(){
  prepareFood(new SushiRecipe());
}: $\top$;
...
\end{lstlisting}
We now look at the evaluation of above \texttt{main} method.
\begin{center}
\texttt{prepareFood(new SushiRecipe());} $\rightarrow$ \texttt{prepareFood($l$);}
\end{center}
where $l$ is the location in 
the store containing the newly created \texttt{SushiRecipe} object.
\begin{center}
\texttt{prepareFood($l$);} $\rightarrow$ ($l\unlhd$\texttt{Recipe.cook()}) 
$\unlhd$ \texttt{Food}
\end{center}
Here we have substituted the argument of the \texttt{prepareFood} method 
into the method body. We attach a persistent upcast to $l$ of the original 
argument type to avoid narrowing. We also do this to the entire returned body 
of the method
\subsection{Path Equality}





\bibliographystyle{plain}
\bibliography{bib}

\end{document}