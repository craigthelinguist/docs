%% $RCSfile: proj_report_outline.tex,v $
%% $Revision: 1.2 $
%% $Date: 2010/04/23 02:40:16 $
%% $Author: kevin $

\documentclass[11pt
              , a4paper
              , twoside
              , openright
              ]{report}


\usepackage{float} % lets you have non-floating floats

\usepackage{url} % for typesetting urls

\usepackage{listings}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{color,soul}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\newtheorem{theorem}{Theorem}
\newtheorem{case}{Case}
\newtheorem{lemma}{Lemma}
\newtheorem{subcase}{Subcase}


\numberwithin{case}{theorem}
\numberwithin{subcase}{case}
%\numberwithin{case}{lemma}




\lstdefinestyle{custom_lang}{
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\ttfamily,
  keywordstyle=\bfseries
}

\lstset{emph={%  
    val, def, type, new, z%
    },emphstyle={\bfseries \tt}%
}

%
%  We don't want figures to float so we define
%
\newfloat{fig}{thp}{lof}[chapter]
\floatname{fig}{Figure}

%% These are standard LaTeX definitions for the document
%%                            
\title{Generic Wyvern}
\author{Julian Mackay}

%% This file can be used for creating a wide range of reports
%%  across various Schools
%%
%% Set up some things, mostly for the front page, for your specific document
%
% Current options are:
% [ecs|msor]              Which school you are in.
%
% [bschonscomp|mcompsci]  Which degree you are doing
%                          You can also specify any other degree by name
%                          (see below)
% [font|image]            Use a font or an image for the VUW logo
%                          The font option will only work on ECS systems
%
\usepackage[image,ecs]{vuwproject}

\supervisors{Alex Potanin, Lindsay Groves}


\otherdegree{PhD in Software Engineering}

\date{}

\begin{document}

% Make the page numbering roman, until after the contents, etc.
\frontmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
Developing reusable libraries in modern programming languages depends heavily on generic programming. The most popular form of genericity is \emph{Generic Type Parameters}. Type parameters are available in most statically typed mainstream Object Oriented languages such as Java \cite{Gosling:2014:JLS:2636997}, C\# \cite{Hejlsberg:2010:CPL:1951915} and C++ \cite{Stroustrup:2000:CPL:518791}. \emph{Type Members} are another programming construct that was suggested as an alternative to type parameters in Java \cite{Thorup97genericityin} as part of BETA\cite{Madsen:1989:VCP:74877.74919}. While type parameters derive from bounded quantification in functional languages such as ML and Haskell\cite{Canning:1989:FPO:99370.99392, Igarashi1999}, type members are more in line with object oriented principles and provide an interesting alternative to type parameters. The most prominent use of type members is in \emph{Scala}\cite{scaladocs2016}, however while it is included in the language, for a long time there was no formal proof of soundness for it despite much effort\cite{amin:fool:2012,Odersky2003}. Only recently has a soundness proof been developed using a big step semantics \cite{Amin:2014:FPT:2660193.2660216} which makes extension and further research difficult . We aim to develop a small step semantics formalism for type members in the structural setting of \emph{Wyvern}\cite{Nistor:2013:WST:2489828.2489830,Omar2014} that is both elegant and sound. We hope this will bring type members closer to the research state of type parameters. 
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\include{acknowledge}

\tableofcontents

% we want a list of the figures we defined
\listof{fig}{Figures}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% individual chapters included here
\chapter{Introduction}\label{ch:intro}
\section{Generic Programming}
Developing generic libraries such as collections generally requires support from the language. Designers of statically type checked object oriented languages have sought to solve this problem by extending their languages. Most modern mainstream languages provide support for generic programming in some capacity. The most common form of generic programming is generic type parameters. Functions and classes are parametrized with bounded generic types that are initialised at runtime, but can be type checked statically. An alternative feature to type parameters are type members. Objects can contain types as members in the same way they do fields and functions. Type parameters and type members can be used to solve similar problems \cite{Igarashi1999}. In this chapter I will describe both type parameters and type members along their relative strengths and weaknesses. I will then outline how we intend to introduce generic programming to Wyvern, a new statically type checked structural language for secure web programming \cite{Nistor:2013:WST:2489828.2489830}.

\subsection{Type Parameters}
Type parameters are a common language construct that is not limited to object oriented languages, and in fact derives from functional languages \cite{Canning:1989:FPO:99370.99392}. Type parameters in object oriented languages generally allow classes and functions to be parametrised by bounded types. Code can be checked statically while allow specific instances to define types at run time. A common example are collections.
\begin{lstlisting}[mathescape, style=custom_lang]
public interface Collection<E extends Object>{
	public abstract void add(E e);
	
	public abstract E get();
	
	public abstract iterator<E> iterator();
}
\end{lstlisting}
Using a Java-like syntax, we define a \verb|Collection| interface that is parametrised by a type parameter \verb|E| bounded by \verb|Object|. We can implement \verb|Collection| and be able to talk about generic collections of objects. We do not need to create a \verb|StringCollection| or an \verb|IntegerCollection|. Bellow we can show such an implementation.
\begin{lstlisting}[mathescape, style=custom_lang]
public class LinkedList<E extends Object> implements Collection<E>{

	private E elem;
	private LinkedList<E> next;
	
	public LinkedList (E elem, LinkedList<E> next){
		this.elem = elem;
		this.next = next;
	}
	
	public void add(E elem){
		if(next == null)
		  this.next = new LinkedList<E>(elem, null);
		else
			next.add(elem);
	}
	
	public E get(){
		return this.elem;
	}
	
	public abstract iterator<E> iterator(){
		return new Iterator<E>(...);
	}
}
\end{lstlisting}
This allows for bounded polymorphism and code that is abstracted from the implementation of specific concrete types. Without the use of generic type parameters library developers would either have to write specific classes and functions for each list type they wished to use, or write unsuitably broad lists of \verb|Object| type. A single generic class or function can be used to initialize any list while maintaining precise types at both write and read. Note that type parameters are especially powerful in a nominal language such as Java. The ability to write generic classes provides the kind of code reuse that would be unavailable in a structural setting. Below we demonstrate how we could use our \verb|LinkedList| class.
\begin{lstlisting}[mathescape, style=custom_lang]
...
LinkedList<String> l = new LinkedList<String>();
l.add(``Hello'');
l.add(``World'');
Collection<String> c1 = l; \\safe
Collection<Object> c2 = l; \\compile time error
...
\end{lstlisting}
Due to contra-variant type restrictions on write, we restrict subtyping to invariance on type parameters.

\subsection{Type Members}
Type members are an alternative to type parameters, and were suggested as part of BETA \cite{Madsen:1989:VCP:74877.74919}. Type members attempt to solve similar problems to type parameters but are not a wide spread as type parameters. Instead of parametrizing functions and classes with bounded types, types are included as object members in the same way as fields or functions. The previous \verb|Collection| example can be rewritten using type members.
\begin{lstlisting}[mathescape, style=custom_lang]
public interface Collection{
	public type E : Object;

	public abstract void add(this.E e);
	
	public abstract this.E get();
	
	public abstract iterator iterator();
}
\end{lstlisting}
Now if we want to create a concrete instance of Collection, we can simply extend the collection interface. Below we have implemented the \verb|Collection| interface to create an \verb|IntegerLinkedList| class. We are free to subtype \verb|E| on extension.
\begin{lstlisting}[mathescape, style=custom_lang]
public class StringLinkedList implements Collection{
	public type E : String;

	private this.E elem;
	private StringLinkedList next;
	
	public StringLinkedList (this.E elem, StringLinkedList next){
		this.elem = elem;
		this.next = next;
	}
	
	public void add(this.E elem){
		if(next == null)
		  this.next = new StringLinkedList(elem, null);
		else
			next.add(elem);
	}
	
	public this.E get(){
		return this.elem;
	}
	
	public abstract StringIterator iterator(){
		return new StringIterator(...);
	}
}
\end{lstlisting}
Assuming \verb|StringIterator| is otherwise appropriately defined, our new \verb|StringLinkedList| class subtypes the original \verb|Collection| type. Below we initialise a \verb|StringLinkedList| object.
\begin{lstlisting}[mathescape, style=custom_lang]
...
StringLinkedList l = new StringLinkedList();
l.add(``Hello'');
l.add(``World'');
l.add(new Object()); \\compile time error
Collection c = l; \\safe
c.add(new Object()); \\runtime error
...
\end{lstlisting}
With type members we can allow for subtype variance in type members, however this means we are potentially unable to catch certain errors statically. As can be seen in these examples, type parameters and type members provide solutions to similar problems, however each has certain strengths and weaknesses.

\subsection{Type Members vs Type Parameters}
The examples thus far have demonstrated one strength of type parameters over type members. In the \verb|Collection| examples, we need only write one \verb|LinkedList| class that can be used as common implementation for constructing \verb|LinkedList|s of any type. When using type members, we need to write a new class for each kind of \verb|LinkedList| we hope to create. This has powerful consequences for developers hoping to write generic libraries. Programmers who wish to use a library need only use the types provided, they do not need to re-implement generic types. This is further a problem when extending a type hierarchy. The following example is a modified version of one by Bruce et. al. \cite{Bruce:1998:SSA:646155.679691}. Using type parameters, we are able to treat \verb|LinkedList<String>| as \verb|Collection<String>|.
\begin{lstlisting}[mathescape, style=custom_lang]
...
Collection<String> l = new LinkedList<String>(); \\safe
...
\end{lstlisting}
This is reasonable to expect, and is quite a common requirement when writing generic code. This is not necessarily possible in a nominal type system with type members. While in our earlier example, we saw that \verb|StringLinkedList| subtypes \verb|Collection|, it does not subtype a string specific \verb|Collection|. To demonstrate this we can rewrite the earlier type members example.
\begin{lstlisting}[mathescape, style=custom_lang]
public class StringCollection extends Collection{
	public type E : String;
}

public class LinkedList implements Collection{
	public type E : Object;

	private this.E elem;
	private LinkedList next;
	
	public LinkedList (this.E elem, LinkedList next){
		this.elem = elem;
		this.next = next;
	}
	
	public void add(this.E elem){
		if(next == null)
		  this.next = new LinkedList(elem, null);
		else
			next.add(elem);
	}
	
	public this.E get(){
		return this.elem;
	}
	
	public abstract Iterator iterator(){
		return new Iterator(...);
	}
}

public class StringLinkedList extends LinkedList{
	public type E : String;
}
\end{lstlisting}
Here \verb|StringCollection| extends our original \verb|Collection| interface by subtyping the \verb|E| type member, \verb|LinkedList| implements \verb|Collection|, and \verb|StringLinkedList| extends \verb|LinkedList|. Now to provide similar functionality to type parameters, we would want \verb|StringLinkedList| to subtype \verb|StringCollection|. This is not the case since subtyping is done via inheritance and \verb|StringLinked| does not extend \verb|StringCollection|. Now this happens to be as much an artefact of nominal type systems as type members, and in Section \ref{s:intro:wyvern} I will discuss this further.

The major difference between the two approaches is the fact that generic type parameters are explicit and type members are implicit. What this means is that when dealing with generic type via parameters, each type must be explicitly defined at the top level of any class or function using it, while type members are implicitly handled by the objects containing them. Both approaches can be advantageous depending on the situation. Another example taken from Bruce et. al. \cite{Bruce:1998:SSA:646155.679691} involves introducing more types to a function. First lets modify our \verb|LinkedList| example using type parameters.
\begin{lstlisting}[mathescape, style=custom_lang]
public class Pair<Fst extends Object, Snd extends Object>{
	public Fst fst;
	public Snd snd;
}

public class LinkedList<E extends Objects> implements Collection{

	...
	
	public List<Pair<E,F>> zip <F extends Object>(List<F> listF){
		...
	}	
}
\end{lstlisting}
If we imagine that the \verb|zip| function zips a list of some type \verb|F| to the receiver we can see it is quite easy to introduce and use new generic types. The same example using type members however becomes much more difficult. Our problem now is that in order to generically define a second \verb|LinkedList| we need to know the extended subtype of that list. Again this is as much a consequence of a nominal type system where subtyping is based upon inheritance as it is type members. 


\subsection{Wyvern and Structural Typing} \label{s:intro:wyvern}
Wyvern is a new statically typed structural language being developed with an emphasis on secure web applications \cite{Wyvern Stuff}. Like many modern object oriented languages, we would like to include support for generic types. We chose to formalise virtual types in Wyvern over generic type parameters since virtual types pairs much better with Wyvern's structural type system.


\section{Formalising Type Members in Wyvern}

Unlike type parameters, there does not exist a standard extensible type system like FGJ. This makes research more difficult. There has been work done in type members, albeit less than that done for type parameters, and there are relatively few mainstream languages that use type members. Scala is one language that does, however Scala type members are not sound. There has been much work on developing a sound calculus for type members in Scala, however thus far there has only been one sound type system proposed \cite{amin 2014} using a big step semantics. While this is a significant step forward there still does not exist a sound type system featuring a small step semantics in the style of FGJ \cite{fgj}. While soundness is certainly significant, we feel that a small-step semantics is more desirable than a big-step semantics, especially in the context of designing a wider language.

\subsection{Developing Generic Wyvern}

We intend to develop a sound and extensible type system for Virtual Types in the spirit of FGJ in the context of Wyvern. We could potentially design several different forms of VIrtual Types depending on the flexibility we desire. The simplest form of virtual types is similar to the one in our first example, a single type that is invariant with subtyping. As an example we can try to model animals and food. 
\begin{lstlisting}[mathescape, style=custom_lang]
Animal = {z $\Rightarrow$	type F = Food
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
This is a common example used in Virtual Types literature, and so we will make use of it here. We define an \verb|Animal| type that contains a type member \verb|F| that is initialized to \verb|Food|, some previously defined type, and a method definition \verb|eat| that a \verb|z.F| as a parameter. This seems like a reasonable description of an animal that eats anything that qualifies as \verb|Food|, however, we might expect to want to refine this in a subtype. For instance
\begin{lstlisting}[mathescape, style=custom_lang]
Cow = {z $\Rightarrow$	type F = Grass
		val isMeat = True
		
		def void eat (x : z.F){
			...
		}}

Lion = {z $\Rightarrow$	type F = Meat
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
we would hope that both \verb|Cow| and \verb|Lion| would be \verb|Animal|s, however if this were the case, we could end up with type errors if we had what we thought we \verb|Animal|s and we attempted to feed them \verb|Meat|, but one happed to be a \verb|Cow|. The example below illustrates this.
\begin{lstlisting}[mathescape, style=custom_lang]
def void feed (a : Animal, f : Food){
	a.eat(f)
}

g = new Grass(..)
c = new Cow(...)
l = new Lion(...)

feed(l,c) \\succeeds
feed(c,g) \\succeeds
feed(c,c) \\fails at runtime
\end{lstlisting}
Without changing our type members are represented, we must make them invariant with subtyping. This still gives us some expressivity, most forms of generic types enforce invariance on the type parameters. However, we might want more flexibility.
If we want to vary type members covariantly with subtyping we can add upper and lower bounds. Now we can rewrite the \verb|Animal|, \verb|Cow| and \verb|Lion| types with bounds on the type members.
\begin{lstlisting}[mathescape, style=custom_lang]
Animal = {z $\Rightarrow$	type F = $\bot$ .. Food
		
		def void eat (x : z.F){
			...
		}}
		
Cow = {z $\Rightarrow$	type F = $\bot$ .. Grass
		val isMeat = True
		
		def void eat (x : z.F){
			...
		}}

Lion = {z $\Rightarrow$	type F = $\bot$ .. Meat
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
When we add a lower bound, types that subtype the lower bound subtype the type member. This means that we can vary the upper bound covariantly while keeping the lower bound invariant. Now \verb|Cow| and \verb|Lion| subtype \verb|Animal|. We can still however get more flexibility out of the language. If we allow the lower bound to vary contra-variantly we can get yet more expressiveness. Rewriting the  \verb|Animal|, \verb|Cow| and \verb|Lion| types we can see how.
\begin{lstlisting}[mathescape, style=custom_lang]
Animal = {z $\Rightarrow$	type F = $\bot$ .. Food
		
		def void eat (x : z.F){
			...
		}}
		
Cow = {z $\Rightarrow$	type F = Grass .. Grass
		val isMeat = True
		
		def void eat (x : z.F){
			...
		}}

Lion = {z $\Rightarrow$	type F = Meat .. Meat
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
Now a \verb|Cow| is able to eat any \verb|Grass| and a \verb|Lion|is able to eat any \verb|Meat|. While this is the most complex form of type members, and brings with it the most complexity, it is also the most expressive. For this reason we chose to formalise this form of type members.

In the rest of this document I will outline the background literature, describe the problems we face, present our work thus far and our plans for future work.

\chapter{Background}\label{ch:background}

\section{Generic Types}
Generic types are a programming language feature that allows programmers to develop code without explicitly specifying the types involved. Most modern programmers are familiar with generics in object oriented languages such as Java or C\#. These are called generic type parameters. Classes and functions can be parametrised with bounded types. A simple example is given below in a Java-like syntax.
\begin{lstlisting}[mathescape, style=custom_lang]
public class LinkedList <E extends Object>{
	E element;
	LinkedList <E> next;
	
	public LinkedList (E element, LinkedList<E> next){
		this.element = element;
		this.next = next;
	}
	
	...
}

...

public LinkedList<E> createList<E extends Object>(E element){
  return new LinkedList<E>(element, null);
}

...

LinkedList<Integer> integerList = createList<Integer>(1);  
LinkedList<String> stringList = createList<String>(``Hello World'');
\end{lstlisting}
Here classes and functions can be defined once for any list. This encourages code reuse and reduces the need for type specific and highly coupled classes. The problems solved by generic type parameters are very similar to those tackled by \emph{Virtual Types}, another programming feature.  Virtual Types are types that feature as members of objects in the same way that fields and methods do. We can rewrite the previous example using type members to demonstrate their similarities.
\begin{lstlisting}[mathescape, style=custom_lang]
public class LinkedList {
	type E : Object;
	this.E element;
	LinkedList next;
	
	public LinkedList (this.E element, LinkedList next){
		this.element = element;
		this.next = next;
	}
	
	...
}

...

public class IntegerLinkedList extends LinkedList {
	type E : Integer;
	
	public IntegerLinkedList (this.E element, IntegerLinkedList next){
		super(element, next);
	}
	
	...
}

...

public class StringLinkedList extends LinkedList {
	type E : String;
	
	public StringLinkedList (this.E element, StringLinkedList next){
		super(element, next);
	}
	
	...
}

...

LinkedList integerList = 
  new IntegerLinkedList(1, new IntegerLinkedList(2,null));
LinkedList  stringList= 
  new StringLinkedList(``Hello'', 
    new StringLinkedList(``World'',null));
\end{lstlisting}
While this syntax does not necessarily represent a sound language, it does demonstrate the kinds of things we would like to do with Virtual Types and how they relate to type parameters. Here instead of parametrising classes and functions, a bounded type is defined within the class, and thus any instance of that class.
In this Section I will discuss these two approaches to generic code, their similarities and differences and the setting for this PhD. 


\subsection{Type Parameters}
Type parameters in object oriented languages derives from bounded quantification in functional programming \cite{Cardelli 86, Odersky 89, System F}. Many modern object oriented languages provide functionality for generic type parameters, and much work has been done formalising type systems containing type parameters. Java is a widely used language, and many programmers are familiar with Java Generics. Generics in Java is the result of much research into type parameters in object oriented languages. As mentioned before, type parameters derive from type polymorphic functions in functional programming languages.

Bounded polymorphism in object oriented languages uses subtyping to write generic code for a family of types. Looking at our \verb|LinkedList| example, we defined the general structure of a list of objects. The only restriction is that any instance of the generic type parameter subtype \verb|Object|, however what kind of relationship can we expect from different instances of \verb|LinkedList|? We might expect \verb|LinkedList<Integer>| to subtype \verb|LinkedList<Object>|, however this this could result in runtime errors. The following example demonstrates this.
\begin{lstlisting}[mathescape, style=custom_lang]
LinkedList<Object> objectList = createList<Integer>(1);
objectList.add(new Object()); \\ fails at runtime
\end{lstlisting}
If we allow for covariant subtyping on type parameters, our example fails at runtime on the second line since \verb|objectList| is actually a list of Integers, and we cannot add an object of \verb|Object| type to a list of Integers. For this reason we have to enforce invariance at type parameter subtyping.

\emph{Pizza} is an early proposal for adding generic type parameters, higher order functions and algebraic data types to Java \cite{Pizza to Java}. The form of type parameters proposed by Pizza was indeed largely adopted by Java. The goal of Pizza was to construct a sound proposal for type parameters as a super set to an existing mainstream language (Java). In \emph{Pizza} the authors dealt with similar problems outlined here, the contra-variance problem. That is \verb|LinkedList<String>| does not subtype \verb|LinkedList<Object>|. Odersky and Wadler \cite{Pizza Stuff} proposed translating Pizza to Java in order to ensure Pizza was a superset of Java. They provided 2 kinds of transformations, heterogeneous and homogeneous. Heterogeneous transformations act as macros, rewriting generic classes as multiple classes, each with a different type parameter instance. Homogeneous transformations rewrite Pizza classes replacing generic type parameters with \verb|Object|, and then applying appropriate upcasts throughout the code. It was found that each transformation provided different advantages, heterogeneous transformations had fast execution while homogeneous transformations provided cleaner code.

\emph{FGJ} is a small step semantics formalism for a core calculus for  Java with generic type parameters developed by Igarashi and Pierce \cite{FGJ}. FGJ, as a minimal core calculus, provides an easy way to reason about extensions to generic Java. The FGJ syntax is given in Figure \ref{f:fgj_syntax}. 
\begin{figure}[h]
\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expression \\
& | & e.f &\\
& | & e.m<\overline{T}>(e) &\\
& | & \texttt{new} \; T(\overline{e})&\\
& | & (T) e &\\
&&\\
v & ::= & \texttt{new} \; T(\overline{e})&\\
&&\\
\Gamma & :: = & \varnothing \; | \; \Gamma,\; x : T & env \\
&&\\
\Delta & :: = & \varnothing \; | \; \Delta,\; X \lhd T & type \; env \\
 \end{array}
& ~~~~~~
&
\begin{array}{lllr}
C, D &  &  & classes \\
&&\\
N & ::= & C <\overline{T}> & class \; type\\
&&\\
T & ::= & X & type \\
       & | & N\\
&&\\
E & :: = & \bigcirc & eval \; context\\
       & | & E.f\\
       & | & E.m(e)\\
       & | & v.m(E)\\
	   & | & \texttt{new} \; C(\overline{E})\\
       & | & (T)E\\
\end{array}
\end{array}
\]
\[
\begin{array}{lllr}
CL & ::= & \verb|class| \; C <\overline{X} \lhd \overline{N}> \lhd N \{\overline{T} \; \overline{f}; \; K \; \overline{M}\}  & class \; declaration\\
$$\\
K & ::= & C(\overline{T}\; \overline{f})\{\verb|super|(\overline{f}); \; \verb|this|.\overline{f} = \overline{f}\}  & constructor\\
$$\\
M & ::= & <\overline{X} \lhd \overline{N}> \; T \; m \; (\overline{T}\; \overline{x})\{e\}  & method \; declaration\\
\end{array}
\]
\caption{FGJ Syntax}
\label{f:fgj_syntax}
\end{figure}
The simplicity of the FGJ syntax allows for the easy extension of Java with generics \cite{OGJ FOIGJ} by limiting the language to only the core properties that interact with generics. FGJ is limited to variables, field accesses, method calls, new expressions and casts. The semantics are similarly simple although not given. 

The key contribution of \emph{FGJ} was that calculi for future extensions and innovations to generic Java could be easily constructed and investigated. As a result, \emph{FGJ} has become a standard core calculus used in research on Java.

\subsection{Virtual Types}
As described earlier, virtual types or type members are object members that are types. This allows us to write similar code to what we might with generic type parameters. It does however present different problems, and there are several potential flavours of Virtual Types. I will present different versions of Virtual Types in the setting of a structurally typed language. I use a structural type system as opposed to the Java-like nominal type system I used in earlier examples because our proposed type system is structurally typed.

\subsubsection{Single Bound, Invariant Virtual Types}
The most basic form of Virtual Types would be a single type identified by member name. Below is the translation of our earlier \verb|LinkedList| example.
\begin{lstlisting}[mathescape, style=custom_lang]
ObjectLinkedList = {
  type E : Object;
  this.E element;
  ObjectLinkedList next;
	
  public void add (this.E element){
    if (this.next == null){
      this.next = new ObjectLinkedList(element, null);
    } else{
      this.next.add(element);
    }
  }
}

...

NumberLinkedList = {
  type E : Number;
  this.E element;
  NumberLinkedList next;
	    
  public void add (this.E element){
    if (this.next == null){
      this.next = new NumberLinkedList(element, null);
    } else{
      this.next.add(element);
    }
  }
}
\end{lstlisting}
This is perhaps the simplest form of Virtual Types, however it has some restrictions.  For the same reasons that we enforce subtype invariance on type parameters, we have to enforce subtype invariance on type members. For this reason, \verb|NumberLinkedList| cannot subtype \verb|ObjectLinkedList| despite how intuitive this might feel. If we allowed covariant type members, we would have write errors and contra-variance would create read errors.

\subsubsection{Double Bound, Covariant Virtual Types}
To allow for covariance we could introduce a lower bound. Subtyping can now allow covariance in type member upper bounds. To demonstrate this, we can rewrite the \verb|LinkedList| example.
\begin{lstlisting}[mathescape, style=custom_lang]
ObjectLinkedList = {
  type E : Integer .. Object;
  this.E element;
  ObjectLinkedList next;
	
  public void add (this.E element){
    if (this.next == null){
      this.next = new ObjectLinkedList(element, null);
    } else{
      this.next.add(element);
    }
  }
}

...

NumberLinkedList = {
  type E : Integer .. Number;
  this.E element;
  IntegerLinkedList next;
	    
  public void add (this.E element){
    if (this.next == null){
      this.next = new NumberLinkedList(element, null);
    } else{
      this.next.add(element);
    }
  }
}
\end{lstlisting}
Subtyping of type members must subtype their lower bound, which means as long as the lower bound subtypes the upper bound, we can vary the upper bound as much as we like. So now, \verb|NumberLinkedList| subtypes \verb|ObjectLinkedList|. We are still restricted by the invariance of the lower bound, so while we can treat the objects read from the list as numbers, we can still only write integers. To extend this, we can allow for covariance of lower bounds.

\subsubsection{Double Bound, Covariant and Contra-Variant Virtual Types}
Allowing 

\section{Type Parameters vs Virtual Types}

\section{Virtual Types in Scala}

\section{Wyvern}

\section{Type Systems and Operational Semantics}
Static type systems are designed to prevent type errors in typed code \cite{Felleisen 1994}. Type errors vary according to the type system, but can be classified as errors that violate the interface of a data type. An example may be calling a method on an object that does not contain an implementation for that method \cite{Felleisen 1994}. We can make two further distinctions for type systems. A \emph{sound} type system is one that ensures that accepted programs contain no type errors. A \emph{complete} type system 

In this document I present the syntax and semantics for 

\subsection{Big Step Semantics}

\subsection{Smal Step Semantics}



\chapter{Generic Wyvern}\label{ch:wyvern}

We have already developed a type system that while not sound solves several of the recurring issues that other work has encountered. In this section I will present our current type system (Generic Wyvern).

Wyvern is a new statically typed programming language being developed for secure web applications. There are two popular and well-documented methods \cite{Virtual Types stuff, generic java etc} for implementing generic types.
\begin{itemize}
\item \emph{Type Parameters}: Types are parametrised by generic type names that are defined at runtime. This allows programmers to reuse generic code. Many popular languages use generic type parameters such as \emph{Java}, \emph{C\#} and \emph{Scala}.
\item \emph{Type Members}: Types and objects may contain type members in the same manner as normal field or method members. These can be subtyped by more precise types to provide generic behaviour.
\end{itemize}
There have long been attempts to formalise a sound small-step semantics for type members in a structural setting for Scala, which have as yet all been unsuccessful due to issues where well-typed expressions are lost during subject reduction. In 2014 Amin et.al. were able to formalise a big step semantics for Scala style type members. While this demonstrates the soundness of the kinds of programs we wish to type check, a small-step semantics offers powerful advantages when reasoning about the behaviour of programs. For this reason we formalise type members with a small step semantics.
We build upon the work of Amin et. al. \cite{Scala stuff} to formalise type members in structurally typed languages using a small step semantics. 

\subsection{Transitivity, Narrowing and Type Members}
\label{sec:trans_narow}
Two properties that one might reasonably expect 
to occur naturally in a structurally typed language are 
\emph{Subtype Transitivity} and \emph{Environment Narrowing}
(Figure \ref{f:trans_narrowing}).
\begin{figure}[h]
\begin{mathpar}
\inferrule
	{\Gamma \vdash S <: T \\
	 \Gamma \vdash T <: U}
	{\Gamma \vdash S <: U}
  \quad (\textsc {Subtype Transitivity})
	\and
\inferrule
  {\Gamma, (x : U) \vdash T <: T'\\
   \Gamma \vdash S <: U}
  {\Gamma, (x : S) \vdash T <: T'}
  \quad (\textsc {Environment Narrowing})
\end{mathpar}
\caption{Subtype Transitivity and Environment Narrowing}
\label{f:trans_narrowing}
\end{figure}
Subtype transitivity is a familiar property, 
and environment narrowing simply expresses the 
expectation that we can treat a variable in an 
environment as having a more precise type without 
changing the type relationships within that environment.

Since transitivity is often used in proving subject 
reduction, it is a problem if a type system lacks this 
property. The issue with transitivity arises from the 
introduction of type member lower bounds, and their 
contra-variance. The following example demonstrates this.
\begin{lstlisting}[mathescape, style=custom_lang]
A = {z $\Rightarrow$ type N : $\bot$ .. $\top$}

B = {z $\Rightarrow$ type N : $\bot$ .. $\top$
          def meth1(x : $\top$){return new{z $\Rightarrow$}}:$\top$}
         
S = {z $\Rightarrow$ type L : A .. $\top$
          val f : A}
         
T = {z $\Rightarrow$ type L : A .. $\top$
          val f : z.L}
         
U = {z $\Rightarrow$ type L : B .. $\top$
          val f : z.L}
\end{lstlisting}
Here \texttt{S} subtypes \texttt{T} and \texttt{T} subtypes 
\texttt{U}, but \texttt{S} does not subtype \texttt{U}. Because 
of the contra-variance of the lower bound of type member \texttt{L}, 
\texttt{A} subtypes \texttt{z.L} in \texttt{T} but not \texttt{U}. 
Amin et al. \cite{Amin 2014} attempt to reconcile this by narrowing 
the type of \texttt{z} in the larger types \texttt{T} and \texttt{U} 
by using the subtype rule in Figure \ref{f:sub_amin}.
\begin{figure}[h]
\begin{mathpar}
\inferrule
  {\Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; \overline{\sigma}_2}
  {\Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
  \quad (\textsc {Structural Subtyping})
\end{mathpar}
\caption{Subtype Transitivity and Environment Narrowing}
\label{f:sub_amin}
\end{figure}
Here we type check the declaration types of the larger type with a smaller receiver. While this allows for subtype transitivity, it introduces environment narrowing that proves unsound in a small step semantics. Amin et. al. were however able to reconcile both transitivity and narrowing within a big step semantics.

\subsection{Path Equality}
To further complicate matters, well-formedness can be lost when reducing field accesses. 

\hl{Julian: Example?}


\section{Type System}

\subsection{Syntax} \label{s:syntax}
In this section we present the Wyvern Type Members Syntax 
in Figure \ref{f:syntax}. 

\begin{figure}[h]
\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expression \\
& | & \texttt{new} \; \{z \Rightarrow \overline{d}\}&\\
& | & e.m(e) &\\
& | & e.f &\\
& | & e \unlhd T&\\
& | & l &\\
&&\\
p & ::= & x & paths \\
& | & l &\\
& | & p \unlhd T &\\
&&\\
v & ::= & l & value \\
& | & v \unlhd T &\\
&&\\
d & ::= & \texttt{val} \; f : T = p & declaration \\
  & |   & \texttt{def} \; m(x:T) = e : T &\\
  & |   & \texttt{type} \; L : T .. T&\\
&&\\
\Gamma & :: = & \varnothing \; | \; \Gamma,\; x : T & Environment \\
&&\\
A & :: = & \varnothing \; | \; A,\;  <: T & Assumption \; Context \\
 \end{array}
& ~~~~~~
&
\begin{array}{lllr}
T & ::= & \{z \Rightarrow \overline{\sigma}\} & type \\
& | & p.L &\\
%& | & T \wedge T & \\
%& | & T \vee T & \\
& | & \top & \\
& | & \bot & \\
&&\\
\sigma & ::= & \texttt{val} \; f:T & decl \; type\\
       & |   & \texttt{def} \; m:T \rightarrow T \\
		 & |   & \texttt{type} \; L : T .. T &\\
&&\\
E & :: = & \bigcirc & eval \; context\\
       & | & E.m(e)\\
       & | & p.m(E)\\
       & | & E.f\\
       & | & E \unlhd T\\
&&\\
d_v & ::= & \texttt{val} \; f : T = v & declaration \; value \\
  & |   & \texttt{def} \; m(x:T) = e : T &\\
  & |   & \texttt{type} \; L : T .. T = T &\\
&&\\
\mu & :: = & \varnothing \; | \; \mu,\; l \mapsto \{z \Rightarrow \overline{d}\} & store \\
\Sigma & :: = & \varnothing \; | \; \Sigma,\; l : \{\texttt{z} \Rightarrow \overline{\sigma}\} & store \; type \\
\end{array}
\end{array}
\]
\caption{Syntax}
\label{f:syntax}
\end{figure}

\textbf{Expressions} ($e$): Expressions are variables ($x$), new 
expressions ($\texttt{new} \; \{z \Rightarrow \overline{d}\}$), 
method calls ($e.m(e)$), field accesses ($e.f$), expression 
upcasts ($e \unlhd T$) and locations ($l$) in the store. The 
only expression that differs from tradition is the explicit upcasts on expressions. 
We use upcasts to avoid the narrowing issues described in Section
We employ a similar strategy with regard to the explicitly 
upcast expression $e \unlhd T$. Here $e$ may have a more precise 
type than $T$, but to avoid narrowing we maintain the type $T$.

\textbf{Types} ($T$): Types are restricted to structural types 
($\{z \Rightarrow \overline{\sigma}\}$), type member selections on 
paths ($p.L$), ($\top$) the top type at the top of the type lattice 
that represents the empty type and $\bot$ the bottom type at the 
bottom of the type lattice that represents the type containing 
al possible declaration labels with $\top$ in the contra-variant 
type position, and $\bot$ in the covariant type position.

\textbf{Paths} ($p$): Paths are expressions that type selections may be 
made on. We restrict these to variables ($x$), locations ($l$) and upcast paths ($p \unlhd T$).

\textbf{Values} ($v$): Values in our type system are locations ($l$) and upcast values ($v \unlhd T$). 

\textbf{Declarations} ($d$): Declarations may be fields (\texttt{val}), 
methods (\texttt{def}) or type members (\texttt{type}). These are all
standard.

\textbf{Declaration Types} ($\sigma$): Declaration types may be field 
(\texttt{val}), method (\texttt{def}) or type members (\texttt{type}). 

\textbf{Declaration Values} ($d_v$): Declaration values are similar to 
declarations, except we require field initializers to be values.

On top of these, we also include an evaluation context $E$, an environment 
$\Gamma$ that maps variables to types, a store $\mu$ that maps locations 
to objects, a store type $\Sigma$ used to type check the store and an 
assumption context $A$ that is used to type check recursive types (\cite{Amber Rules etc})
that consists of a list of type pairs.



\subsection{Semantics}
In this section we describe the Wyvern Type Members semantics.
\subsubsection{Path Functions}

\hl{Julian: I'll finish describing these functions later once they are finalized.}

\begin{figure}[h]
\begin{mathpar}
\inferrule
  {}
  {p \equiv p}
  \quad (\textsc{Eq-Refl})
  \and
\inferrule
  {p_1 \equiv p_2}
  {p_2 \equiv p_1}
  \quad (\textsc{Eq-Sym})
  \and
\inferrule
  {p_1 \equiv p_2 \\
   p_2 \equiv p_3}
  {p_1 \equiv p_3}
  \quad (\textsc{Eq-Trans})
  \and
\inferrule
  {p_1 \equiv p_2}
  {p_1 \equiv p_2 \unlhd T}
  \quad (\textsc{Eq-Path})
\end{mathpar}
\caption{Path Equivalence}
\label{f:path_equiv}
\end{figure}
In Figure \ref{f:path_equiv} we describe our path equivalence judgement. Two paths are equivalent if they wrap up the same variable or location. This is useful when trying to compare two types that are not technically the same types, but are derived from the same object.

\subsubsection{Subtyping}
Subtyping is given in Figure \ref{f:subtype}. We use a 
modified version of the subtyping relation 
described by Amin et. al. \cite{Scala stuff}. We remove the reflexivity rule, however this can be inferred from the other subtyping rules. We modify the \textsc{S-Struct} rule for structural subtyping by upcasting the self variable of the larger type to avoid narrowing. This can be seen in \textsc{S-Struct} in Figure \ref{f:subtype}.
If we didn't do this, we would have to type check the declaration types of the larger type with a smaller receiver, resulting in narrowing. We also need to be able subtype two path equivalent selection types(\textsc{S-Path} in Figure \ref{f:subtype}). Since we can have two paths that are equivalent in that they lead to the same location or variable while having different types, we need a way to subtype path equivalent type selections. We require that they have the appropriate contra-variant and covariant relationships between their lower and upper bounds respectively. To deal with recursive types, we use an assumption context $A$ which we use to type check the bounds of the selection type. For this we introduce the \textsc{S-Assume} rule. \textsc{S-Select-Upper} and \textsc{S-Select-Lower} are our rules for subtyping selection types. To supertype or subtype a selection type, a type needs to supertype or subtype its upper or lower bounds respectively. We then use \textsc{S-Top} and \textsc{S-Bottom} to type check the subtyping and supertyping of the top ($\top$) and bottom ($\bot$) types.

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash S <: T$}
\begin{mathpar}
\inferrule
  {(S <: T) \in A}
  {A; \Sigma; \Gamma \vdash S\; \texttt{<:}\; T}
  \quad (\textsc {S-Assume})
	\and
\inferrule
	{A; \Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; [z \unlhd \{z \Rightarrow \overline{\sigma}_2\} / z]\overline{\sigma}_2}
	{A; \Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
	\quad (\textsc {S-Struct})
	\and
\inferrule
	{p_1 \equiv p_2 \\
	 A; \Sigma; \Gamma \vdash p_1 \ni \texttt{type} \; L : S_1 .. U_1 \\
	 A; \Sigma; \Gamma \vdash p_2 \ni \texttt{type} \; L : S_2 .. U_2 \\
	 A, (p_1.L <: p_2.L); \Sigma; \Gamma \vdash S_2 <:\; S_1 \\
	 A, (p_1.L <: p_2.L); \Sigma; \Gamma \vdash U_1\; <:\; U_2}
	{A; \Sigma; \Gamma \vdash p_1.L\; <:\; p_2.L}
	\quad (\textsc {S-Path})
	\and
\inferrule
	{A; \Sigma; \Gamma \vdash p \ni \texttt{type} \; L : S .. U\\
	 A; \Sigma; \Gamma \vdash S <: U \\
	 A; \Sigma; \Gamma \vdash U <: T}
	{A; \Sigma; \Gamma \vdash p.L\; <:\; T}
	\quad (\textsc {S-Select-Upper})
	\and
\inferrule
	{A; \Sigma; \Gamma \vdash p \ni \texttt{type} \; L : S .. U \\
	 A; \Sigma; \Gamma \vdash S <: U \\
	 A; \Sigma; \Gamma \vdash T <: S}
	{A; \Sigma; \Gamma \vdash T \; <:\; p.L}
	\quad (\textsc {S-Select-Lower})
	\and
\inferrule
	{}
	{A; \Sigma; \Gamma \vdash T\; \texttt{<:}\; \top}
	\quad (\textsc {S-Top})
	\and
\inferrule
	{}
	{A; \Sigma; \Gamma \vdash \bot\; \texttt{<:}\; T}
	\quad (\textsc {S-Bottom})
\end{mathpar}
\hfill \fbox{$A; \Sigma; \Gamma \vdash \sigma <: \sigma'$}
\begin{mathpar}
\inferrule
	{}
	{A; \Sigma; \Gamma \vdash \texttt{val} \; f:T <: \texttt{val} \; f:T}
	\quad (\textsc {S-Decl-Val})
	\and
\inferrule
	{A; \Sigma; \Gamma \vdash S' <: S \\
	 A; \Sigma; \Gamma \vdash T <: T'}
	{A; \Sigma; \Gamma \vdash \texttt{def} \; m:S \rightarrow T <: \texttt{def} \; m:S' \rightarrow T'}
	\quad (\textsc {S-Decl-Def})
	\and
\inferrule
	{A; \Sigma; \Gamma \vdash S' <: S \\
	 A; \Sigma; \Gamma \vdash U <: U'}
	{A; \Sigma; \Gamma \vdash \texttt{type} \; L : S .. U \; <:\; \texttt{type} \; L : S' .. U'}
	\quad (\textsc {S-Decl-Type})
\end{mathpar}
\caption{Subtyping}
\label{f:subtype}
\end{figure}

\subsubsection{Well-Formedness}

\hl{Julian: Do we need to worry about this?}

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash T \;  \textbf{wf}$}
\begin{mathpar}
\inferrule
  {A; \Sigma; \Gamma \vdash p \ni \texttt{type} \; L : S .. U \\
  	A; \Sigma; \Gamma \vdash \texttt{type} \; L : S .. U \; \textbf{wf} }
  {A; \Sigma; \Gamma \vdash p.L \; \textbf{wf}}
  \quad (\textsc {WF-Sel})
	\and
\inferrule
  {A; \Sigma; \Gamma,z:\{z \Rightarrow \overline{\sigma}\} \vdash \overline{\sigma} \; \textbf{wf} \\
  	\forall j \neq i, \; dom(\sigma_j) \neq dom(\sigma_i)}
  {A; \Gamma; \Sigma \vdash \{z \Rightarrow \overline{\sigma}\} \; \textbf{wf}}
  \quad (\textsc {WF-Struct})
	\and
\inferrule
  {}
  {A; \Sigma; \Gamma \vdash \top \;  \textbf{wf}}
  \quad (\textsc {WF-Top})
	\and
\inferrule
  {}
  {A; \Sigma; \Gamma \vdash \bot \;  \textbf{wf}}
  \quad (\textsc {WF-Bot})
\end{mathpar}
\hfill \fbox{$A; \Sigma; \Gamma \vdash \sigma \;  \textbf{wf}$}
\begin{mathpar}
\inferrule
  {A; \Sigma; \Gamma \vdash T : \textbf{wf}}
  {A; \Sigma; \Gamma \vdash \texttt{val} \; f:T \;  \textbf{wf}}
  \quad (\textsc {WF-Val})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash T : \textbf{wf} \\
  	A; \Sigma; \Gamma \vdash S : \textbf{wf}}
  {A; \Sigma; \Gamma \vdash \texttt{def} \; m:S \rightarrow T \;  \textbf{wf}}
  \quad (\textsc {WF-Def})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash S : \textbf{wfe} \; \vee \; S = \bot\\
  	A; \Sigma; \Gamma \vdash U : \textbf{wfe} \\
  	A; \Sigma; \Gamma \vdash S <: U}
  {A; \Sigma; \Gamma \vdash \texttt{type} \; L : S .. U \; \textbf{wf}}
  \quad (\textsc {WF-Type})
\end{mathpar}
\hfill \fbox{$A; \Sigma \vdash \Gamma \;  \textbf{wf}$}
\begin{mathpar}
\inferrule
  {\forall x \in dom(\Gamma), A; \Sigma; \Gamma \vdash \Gamma(x) \; \textbf{wf}}
  {\Sigma \vdash \Gamma \;  \textbf{wf}}
  \quad (\textsc {WF-Environment})
\end{mathpar}
\hfill \fbox{$\Sigma \;  \textbf{wf}$}
\begin{mathpar}
\inferrule
  {\forall l \in dom(\Sigma), \varnothing; \Sigma; \varnothing \vdash \Sigma(l) \; \textbf{wf}}
  {\Sigma \;  \textbf{wf}}
  \quad (\textsc {WF-Store-Context})
\end{mathpar}
\begin{mathpar}
\inferrule
  {\forall l \in dom(\mu), \varnothing; \Sigma; \varnothing \vdash \mu(l) : \Sigma(l)}
  {\Sigma \vdash \mu \; \textbf{wf}}
  \quad (\textsc {WF-Store})
\end{mathpar}
\caption{Well-Formedness}
\label{f:wf}
\end{figure}

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash T \;  \textbf{wfe}$}
\begin{mathpar}
\inferrule
  {A; \Sigma; \Gamma \vdash T \; \textbf{wf} \\
  	A; \Sigma; \Gamma \vdash T \prec \overline{\sigma}}
  {A; \Sigma; \Gamma \vdash T \; \textbf{wfe}}
  \quad (\textsc {WFE})
\end{mathpar}
\caption{Well-Formed and Expanding Types}
\label{f:wfe}
\end{figure}

\subsubsection{Type Expansion and Membership}

We use a modified version of the type expansion (Figure \ref{f:exp}) definition and the same membership (Figure \ref{f:mem}) definition from Amin et al \cite{Scala stuff}. Expansion of types is used to extract the set of declaration types for a type. \textsc{E-Struct} is the expansion rule for structural types. Structural types simply expand to their defined types. The expansion of selection types (\textsc{E-Sel}) are slightly more complicated. Selection types expand to the expansion of the upper bound. The expansion of the upper bound is type checked with a less precise type (the upper bound) that the selection type. As with our subtyping rule for structural types, we need to prevent narrowing of types at type expansion. For this reason we upcast the self variable $z$ to the original type $U$. The top type expands to the empty set (\textsc{E-Top}). The membership judgement is used to determine the membership of a declaration type for an expression. We type check the expression, expand the expression's type and in the case of path expansion, substitute out the self variable.

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash T \prec \overline{\sigma}$}
\begin{mathpar}
\inferrule
  {}
  {A; \Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}\} \prec_z \overline{\sigma}}
  \quad (\textsc {E-Struct})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash p \ni \texttt{type} \; L : S..U \\
  	A; \Sigma; \Gamma \vdash U \prec_z \overline{\sigma}}
  {A; \Sigma; \Gamma \vdash p.L \prec_z [z \unlhd U/z]\overline{\sigma}}
  \quad (\textsc {E-Sel})
	\and
\inferrule
  {}
  {A; \Sigma; \Gamma \vdash \top \prec_z \varnothing}
  \quad (\textsc {E-Top})
\end{mathpar}
\caption{Expansion}
\label{f:exp}
\end{figure}

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash e \ni \sigma$}
\begin{mathpar}
\inferrule
  {A; \Sigma; \Gamma \vdash p : T \\
  	A; \Sigma; \Gamma \vdash T \prec_z \overline{\sigma}\\
  	A; \sigma_i \in \overline{\sigma}}
  {A; \Sigma; \Gamma \vdash p \ni [p/z]\sigma_i}
  \quad (\textsc {M-Path})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash e : T \\
  	A; \Sigma; \Gamma \vdash T \prec_z \overline{\sigma}\\
  	\sigma_i \in \overline{\sigma} \\
  	z \notin \sigma_i}
  {A; \Sigma; \Gamma \vdash e \ni \sigma_i}
  \quad (\textsc {M-Exp})
\end{mathpar}
\caption{Membership}
\label{f:mem}
\end{figure}

\subsubsection{Expression Typing}
Expression typing is fairly straight forward and is 
given in Figure \ref{f:e_typ}. Variables (\textsc{T-Var})
are typed with their types in the environment and 
locations (\textsc{T-Loc})in the store type. New 
expressions (\textsc{T-New}) are typed as a collection 
of declaration types that correspond to their declarations. 
Method calls (\textsc{T-Meth}) are typed as their 
return type provided the arguments 
subtype the method parameter types. Field accesses 
(\textsc{T-Field}) are typed as the field type for the receiver. 
Upcasts (\textsc{T-Type}) are typed as the upcast type if the 
upcast expression appropriately subtypes the upcast type.
\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash e:T$}
\begin{mathpar}
\inferrule
  {x \in dom(\Gamma)}
  {	A; \Sigma; \Gamma \vdash x : \Gamma(x)}
  \quad (\textsc {T-Var})
	\and
\inferrule
  {	l \in dom(\Sigma)}
  {	A; \Sigma; \Gamma \vdash l : \Sigma(l)}
  \quad (\textsc {T-Loc})
	\and
\inferrule
  {A; \Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}\} 
  \vdash \overline{d} : \overline{\sigma}}
  {A; \Sigma; \Gamma \vdash \texttt{new} \; \{z \Rightarrow \overline{d}\} : 
  \{z \Rightarrow \overline{\sigma}\}}
  \quad (\textsc {T-New})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash e_0 \ni \texttt{def} \; m:S \rightarrow T \\
  	A; \Sigma; \Gamma \vdash e_0 : T_0 \\
  	A; \Sigma; \Gamma \vdash e_1 : S' \\
  	A; \Sigma; \Gamma \vdash S' <: S}
  {A; 	\Sigma; \Gamma \vdash e_0.m(e_1) : T}
  \quad (\textsc {T-Meth})
	\and
\inferrule
  {	A; \Sigma; \Gamma \vdash e : S \\
  	A; \Sigma; \Gamma \vdash e \ni \texttt{val} \; f:T}
  {	A; \Sigma; \Gamma \vdash e.f : T}
  \quad (\textsc {T-Field})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash e : S \\
   A; \Sigma; \Gamma \vdash S <: T}
  {A; \Sigma; \Gamma \vdash e \unlhd T : T}
  \quad (\textsc {T-Type})
\end{mathpar}
\caption{Expression Typing}
\label{f:e_typ}
\end{figure}

\subsubsection{Reduction}

Reduction is given in Figure \ref{f:red}. Reduction is new (\textsc{R-New}), method (\textsc{R-meth}), field (\textsc{R-Field}) and context (\textsc{R-Context}) reduction. New expressions are reduced (\textsc{R-New}) once field initializers are reduced to values. Method calls on values with a value type parameter are reduced (\textsc{R-Meth}) using the \emph{Leadsto\textsubscript{m}} judgement. We use the \emph{Leadsto\textsubscript{m}} judgement to extract the method body from the store, and wrap it up in well-formed type layers. Field reduction (\textsc{R-Field}) is performed the same way, using the \emph{Leadsto\textsubscript{f}} judgement. Context reduction (\textsc{R-Context}) is standard.
\begin{figure}[h]
\hfill \fbox{$\mu \; | \; e \; \rightarrow \mu' \; | \; e'$}
\begin{mathpar}
\inferrule
  {l \notin dom(\mu) \\
  	\mu' = \mu, l \mapsto \{\texttt{z} \Rightarrow \overline{d_v}\}}
  {\mu \; | \; \texttt{new} \; \{\texttt{z} \Rightarrow \overline{d_v}\} \; \rightarrow \mu' \; | \; l}
  \quad (\textsc {R-New})
  \and
\inferrule
  {\mu : \Sigma \\
   \mu; \Sigma \vdash v_1 \leadsto_{m(v_2)} e}
  {\mu \; | \; v_1.m(v_2) \;\rightarrow \mu \; | \; e}
  \quad (\textsc {R-Meth})
  \and
\inferrule
  {\mu : \Sigma \\
   \mu; \Sigma \vdash v_1 \leadsto_{f} v_2}
  {\mu \; | \; v_1.f \;\rightarrow \mu \; | \; v_2}
  \quad (\textsc {R-Field})
  \and
\inferrule
  {	\mu \; | \; e \; \rightarrow \; \mu' \; | \; e'}
  {\mu \; | \; E[e] \; \rightarrow \mu' \; | \; E[e']}
  \quad (\textsc {R-Context})
\end{mathpar}
\caption{Reduction}
\label{f:red}
\end{figure}

\chapter{Proving Virtual Types Sound}
Proving type systems containing Virtual Types sound presents some problems. Depending on the type system, these are due to the either the  interplay between \emph{Subtype Transitivity} and \emph{Environment Narrowing} and path dependant types.

\section{Proving Subtype Transitivity and Environment Narrowing}
The main difficulty with constructing a soundness proof for Generic Wyvern proving the subtype transitivity and environment narrowing proofs. These lemmas are given in Figure \ref{f:trans_narrowing}. The property that we would like is subtype transitivity (Theorem \ref{th:trans}), however this relies mutually on the existence of environment narrrowing. To demonstrate this, lets take a naive approach to the Subtype Transitivity proof, by induction on the derivation of $\Sigma; \Gamma \vdash S <: T$. Theorem \ref{th:trans} uses an unpatched subtype relation. this is identical to the subtype relation described in Section \ref{ch:wyvern}, except we replace the \textsc{S-Struct} rule with that in Figure \ref{f:struct_naive}.
\begin{figure}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; \overline{\sigma}_2}
	{\Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
\end{mathpar}
\caption{Unpatched \textsc{S-Struct}}
\label{f:struct_naive}
\end{figure}
\begin{theorem}[Subtype Transitivity]\label{th:trans}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma \vdash S <: T \\
	 \Sigma; \Gamma \vdash T <: U}
	{\Sigma; \Gamma \vdash S <: U}
\end{mathpar}
\end{theorem}
\begin{proof}
By induction on the derivation of $\Sigma; \Gamma \vdash S <: T$.
\begin{case}[S-Struct]
\begin{mathpar}
\inferrule
	{}
	{S = \{z \Rightarrow \overline{\sigma}_1\} \\
	 T = \{z \Rightarrow \overline{\sigma}_2\}}
\end{mathpar}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; \overline{\sigma}_2}
	{\Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
\end{mathpar}
Now, by inversion on the derivation of $\Sigma; \Gamma \vdash T <: U$ we have
\begin{subcase}[S-Struct]
\begin{mathpar}
\inferrule
	{}
	{U = \{z \Rightarrow \overline{\sigma}_3\}}
\end{mathpar}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_2\} \vdash \overline{\sigma}_2 <:\; \overline{\sigma}_3}
	{\Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_2\}\; <:\; \{z \Rightarrow \overline{\sigma}_3\}}
\end{mathpar}
Now we would like to use the induction hypothesis to show that
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; \overline{\sigma}_3}
	{\Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_3\}}
\end{mathpar}
However, clearly this dosn't follow since we have different environments.
\end{subcase}
\end{case}
\end{proof}
So, in order to continue, we need to be able to narrow the environment. This means, without patching the type system, we have to introduce a narrowing theorem. 
\begin{theorem}[Narrowing]\label{th:narrow}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash T <: T' \\
	 \Sigma; \Gamma \vdash S <: U}
	{\Sigma; \Gamma, (x : S) \vdash T <: T'}
\end{mathpar}
\end{theorem}
It turns out that Narrowing (Theorem \ref{th:narrow}) is dependent on Subtype Transitivity (Theorem \ref{th:trans}). It is yet more complex, since subtyping is defined mutually with expansion (Figure \ref{f:exp}), membership (Figure \ref{f:mem}) and expression typing (Figure \ref{f:e_typ}). So the full statement of environment narrowing is 
\begin{theorem}[Narrowing]\label{th:narrow}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash T <: T' \\
	 \Sigma; \Gamma \vdash S <: U}
	{\Sigma; \Gamma, (x : S) \vdash T <: T'}
	\and
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash T \prec_z \overline{\sigma}_1 \\
	 \Sigma; \Gamma \vdash S <: U}
	{\exists \overline{\sigma}_2,  \Sigma; \Gamma, (x : S) \vdash T \prec_z \overline{\sigma}_2 \\
	  \Sigma; \Gamma, (x : S) \vdash \overline{\sigma}_2 <: \overline{\sigma}_1}
	\and
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash e \ni \sigma_1 \\
	 \Sigma; \Gamma \vdash S <: U}
	{\exists \sigma_2,  \Sigma; \Gamma, (x : S) \vdash e \ni \sigma_2 \\
	  \Sigma; \Gamma, (x : S) \vdash \sigma_2 <: \sigma_1}
	\and
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash e: T \\
	 \Sigma; \Gamma \vdash S <: U}
	{\exists T',  \Sigma; \Gamma, (x : S) \vdash e : T' \\
	  \Sigma; \Gamma, (x : S) \vdash T' <: T}
\end{mathpar}
\end{theorem}
All of these mutually defined properties create a complex set of proofs. This was our reason for attempting to remove subtype transitivity altogether.





\chapter{Future Work}\label{ch:future}

As part of the development of Generic Wyvern, we simplified the concept of paths in the same way that Amin et. al. \cite{Amin 2014} did. This was due to the complexity of both the path equality and narrowing problems. In the future we hope to expand the notion of paths to include field accesses. We also intend to introduce \emph{Intersection} and \emph{Union} types. 

While the Generic Wyvern type system outlined in the previous section is a good start to a sound type system, there is still some work that needs to be done to achieve my stated goals. In this section I shall cover the topic, and time line and contributions of the final thesis.

\section{Simplification of path resolution at evaluation}
While our current type system appears to be a step toward sound virtual types, it does introduce complexity when attempting to resolve field and method accesses on paths and subsequently construct well-formed expressions at evaluation. this is related to the absence of \emph{Subtype Transitivity}. This added complexity does not help in our goal of creating the easily extensible core type system we want for Wyvern. It also may prove too complex when we attempt to extend paths to include field accesses. For these reasons we hope to simplify the way we deal with the transitivity problem.

\section{Explicit Subtype Transitivity Rule}
One potential solution is to introduce an explicit rule for Subtype Transitivity. This has other

\section{Timeline of PhD}
\begin{itemize}
\item
Develop Type Members Type System with simplified paths
\item
Introduce Path Dependence
\item

\end{itemize}•



\chapter{Conclusion}\label{ch:conclusion}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\backmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\bibliographystyle{ieeetr}
\bibliographystyle{acm}
\bibliography{bibl}


\end{document}
