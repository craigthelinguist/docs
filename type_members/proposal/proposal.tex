%% $RCSfile: proj_report_outline.tex,v $
%% $Revision: 1.2 $
%% $Date: 2010/04/23 02:40:16 $
%% $Author: kevin $

\documentclass[11pt
              , a4paper
              , twoside
              , openright
              ]{report}


\usepackage{float} % lets you have non-floating floats

\usepackage{url} % for typesetting urls

\usepackage{listings}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{color,soul}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\newtheorem{theorem}{Theorem}
\newtheorem{case}{Case}
\newtheorem{lemma}{Lemma}
\newtheorem{subcase}{Subcase}


\numberwithin{case}{theorem}
\numberwithin{subcase}{case}
%\numberwithin{case}{lemma}




\lstdefinestyle{custom_lang}{
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\ttfamily,
  keywordstyle=\bfseries
}

\lstset{emph={%  
    val, def, type, new, z%
    },emphstyle={\bfseries \tt}%
}

%
%  We don't want figures to float so we define
%
\newfloat{fig}{thp}{lof}[chapter]
\floatname{fig}{Figure}

%% These are standard LaTeX definitions for the document
%%                            
\title{Generic Wyvern}
\author{Julian Mackay}

%% This file can be used for creating a wide range of reports
%%  across various Schools
%%
%% Set up some things, mostly for the front page, for your specific document
%
% Current options are:
% [ecs|msor]              Which school you are in.
%
% [bschonscomp|mcompsci]  Which degree you are doing
%                          You can also specify any other degree by name
%                          (see below)
% [font|image]            Use a font or an image for the VUW logo
%                          The font option will only work on ECS systems
%
\usepackage[image,ecs]{vuwproject}

\supervisors{Alex Potanin, Lindsay Groves}


\otherdegree{PhD in Software Engineering}

\date{}

\begin{document}

% Make the page numbering roman, until after the contents, etc.
\frontmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
Developing reusable libraries in modern programming languages depends heavily on generic programming. The most popular form of genericity is \emph{Generic Type Parameters}. Type parameters are available in most statically typed mainstream Object Oriented languages such as Java, C\# and C++. \emph{Type Members} are another programming construct that was suggested as an alternative to type parameters in Java as part of BETA. While type parameters derive from bounded quantification in functional languages such as ML and Haskell, type members are more in line with object oriented principles and provide an interesting alternative to type parameters. The most prominent use of type members is in \emph{Scala}, however while it is included in the language, for a long time there was no formal proof of soundness for it despite much effort. Only recently has a soundness proof been developed using a big step semantics which makes extension and further research difficult . We aim to develop a small step semantics formalism for type members in the structural setting of \emph{Wyvern} that is both elegant and sound. We hope this will bring type members closer to the research state of type parameters. 
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\include{acknowledge}

\tableofcontents

% we want a list of the figures we defined
\listof{fig}{Figures}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% individual chapters included here
\chapter{Introduction}\label{ch:intro}

Developing generic libraries such as collections generally requires support from the language. Designers of statically type checked object oriented languages have sought to solve this problem by extending their languages. Most modern mainstream languages provide support for generic programming in some capacity. The most common form of generic programming is generic type parameters. Functions and classes are parametrized with bounded generic types that are initialised at runtime, but can be type checked statically. An alternative feature to type parameters are type members. Objects can contain types as members in the same way they do fields and functions. Type parameters and type members can be used to solve similar problems \cite{Igarashi1999}. In this chapter I will describe what type members are and how we intend to add them to the new structurally typed object oriented language Wyvern  \cite{Nistor:2013:WST:2489828.2489830}.

\section{Type Members}
Type members are a language feature that allows for the writing of generic libraries, and solves many of the same problems as the more familiar type parameters. While type parameters abstract functions and classes over a range of types by the addition of type parameters, type members allow types to be included as members to objects in the same way fields and methods are. A common example for type members is the \verb|Animal| example \cite{Igarashi1999, Amin:2014:FPT:2660193.2660216} given below.
\begin{lstlisting}[mathescape, style=custom_lang]
Animal = {z $\Rightarrow$	type F = Food
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
The \verb|Animal| type has two members, a function \verb|eat| that specifies the eat operation and a type member \verb|F| that specifies what type of food it can eat, in this case \verb|Food|.  Note that we refer to \verb|F| by access on the self (\verb|this| in Java) variable \verb|z.F|. Now if we wanted to subtype \verb|Animal| we can create more specific instances of \verb|Animal|s with narrower food types.
\begin{lstlisting}[mathescape, style=custom_lang]
Cow = {z $\Rightarrow$	type F = Grass
		val isMeat = True
		
		def void eat (x : z.F){
			...
		}}

Lion = {z $\Rightarrow$	type F = Meat
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
In this way we are able to abstract objects over types in a similar way to type parameters. A more in depth comparison between the two is given Chapter \ref{ch:background}.

\section{Developing Generic Wyvern}

We intend to develop a sound and extensible type system for type members in the spirit of Featherweight Generic Java \cite{Igarashi:2001:FJM:503502.503505} in the context of Wyvern, a new structurally typed object oriented language being developed with an emphasis on security \cite{Omar2014}. Wyvern has been designed with a core calculus that is purely structural and type members are intended to form part of this core calculus. For this reason it needs to be easily extensible to facilitate the development of other language features such as the Wyvern module system. Featherweight Java is a core calculus for Generic Java and this is the reason we choose it as an analogy to generic Wyvern.

\subsection{The Problem}

Type members are not a new area of investigation, on the contrary, there has been much work done on type members \cite{Madsen:1989:VCP:74877.74919, Igarashi1999, Thorup97genericityin, Bruce:1998:SSA:646155.679691}, often in the context of a comparison to type parameters. While type parameters became the more common form of generics, there is still ongoing work on type members \cite{Odersky2003, Amin:2014:FPT:2660193.2660216, amin:fool:2012}.  This work does have limitations, specifically when trying to allow for the subtype variance of type members while maintaining soundness. Amin et. al. \cite{Amin:2014:FPT:2660193.2660216, amin:fool:2012} is focused on the particular flavour of type members in Scala, one of the few mainstream languages to have type members. They were able to develop a soundness proof, however they were only able to do so using a big-step semantics. We feel that using a more standard small-step semantics would allow for a more extensible type system in line with the spirit of our core Wyvern calculus.

We aim to develop a sound type system for type member using a small-step semantics. Our type system will allow for subtype variance of type members, that is we intend to define type members using two bounds, and upper and a lower bound providing both covariance and contra-variance simultaneously. Rewriting the \verb|Animal| example using multiple bounds we get this
\begin{lstlisting}[mathescape, style=custom_lang]
Animal = {z $\Rightarrow$	type F = $\bot$ .. Food
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
Here $\bot$ is the bottom most type in the subtype lattice. When considering type members in the positive position, such as at method return, we use the upper bound, while we use the lower bound in the negative position, for example in method parameters. Proving type safety with a type system such as this happens to be fairly difficult as type wellformedness can be lost during evaluation regardless of the wellformedness of the final result of evaluation.

Another feature we intend to include is path dependent type members. That is, a distinction is made between type members of the same name, but accessed from different types. This is needed since at runtime there is no way to determine path equivalence without maintaining some type information.

In the rest of this document I will outline the background literature, describe the problems we face, present our work thus far and our plans for future work.

\chapter{Background}\label{ch:background}

In this Chapter I provide a background to the work we have already done, and will do in the future. Since we are attempting to develop a sound type system for type members in a structural language called Wyvern, I will provide a background to type systems in Section \ref{s:typesys}, generic programming and specifically type members in Section \ref{s:generics} and an overview of Wyvern in Section \ref{s:wyvern}

\section{Type systems}\label{s:typesys}
We would ideally like to only ever execute valid programs, however this is not always possible since some errors are not always catchable. We classify errors to do with the type of an object as type errors. It is the job of the type system to specify what does and does not qualify as a type error. We can then use that specification during type checking to exclude invalid programs. Static type systems are designed to prevent type errors in typed code \cite{Wright:1994:SAT:191905.191909}. Type errors vary according to the type system, but can be classified as errors that violate the interface of a data type. An example may be calling a method on an object that does not contain an implementation for that method \cite{Wright:1994:SAT:191905.191909}.

The design of modern type systems usually involves the mathematical representation of the type system which in turn allows us to prove certain properties of the type system. Before we are able to model the semantics of the type system we need to specify the syntax of the language we are dealing with. To demonstrate a basic type system we consider a simple typed $\lambda$-calculus \cite{church1940formulation, curry1959combinatory, Pierce:2002:TPL:509043}. The pure $\lambda$-calculus consists of only lambda expressions. A lambda expression is simply a function that has been abstracted over a single variable. If for example we wish to add 2 to 3, we could first define a general function for addition of 2 and then apply that function to 3.
\begin{lstlisting}[mathescape, style=custom_lang]
($\lambda$x. x + 2) 3
\end{lstlisting}
Here our lambda expression takes a variable \verb|x| and adds 2 to it. We then apply this function to 3. This is a common feature of programming languages. The typed $\lambda$-calculus is a simple calculus for a $\lambda$-calculus with types. Adding types allows us to prevent certain errors. For example we would not be able to evaluate the following expression.
\begin{lstlisting}[mathescape, style=custom_lang]
($\lambda$x. x + 2) true
\end{lstlisting}
We can now restrict the type of \verb|x| to \verb|int|.
\begin{lstlisting}[mathescape, style=custom_lang]
($\lambda$x : int. x + 2) 3
\end{lstlisting}
$\lambda$ expressions also have types. $\lambda$\verb|x : int. x + 2| has type \verb|int| $\rightarrow$ \verb|int|. 
\subsubsection{$\lambda$-Calculus Syntax}

We capture all this in our syntax for the $\lambda$-calculus in Figure \ref{f:lambda_syntax}
\begin{figure}[h]
\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expression \\
& | & \lambda x : T. e &\\
& | & e \; e &\\
&&\\
v & ::= & \lambda x : T. e & value\\
 \end{array}
& ~~~~~~
&
\begin{array}{lllr}
T & ::= & T \rightarrow T & type \\
&&\\
\Gamma & :: = & \varnothing \; | \; \Gamma,\; x : T & env \\
\end{array}
\end{array}
\]
\caption{Typed Lambda Calculus Syntax}
\label{f:lambda_syntax}
\end{figure}
Here we specify all the potential expressions ($e$), types ($T$), values ($v$) and environments ($\Gamma$). While we have mentioned expressions and types we should say what we mean by values and environments. A values is an irreducible expression, in this case $\lambda$-expressions. Environments are mappings from variables ($x$) to types. 

\subsubsection{$\lambda$-Calculus Semantics}
We use our syntax to define a semantics for both type checking and execution. Our static semantics used for type checking is given in Figure \ref{f:lambda_type}.
\begin{figure}[h]
\begin{mathpar}
\inferrule
  {x : T \in \Gamma}
  {\Gamma \vdash x : T}
  \quad (\textsc{T-Var})
  \and
\inferrule
  {\Gamma, x : T_1 \vdash e : T_2}
  {\Gamma \vdash \lambda x : T_1. e : T_1 \rightarrow T_2}
  \quad (\textsc{T-Lambda})
  \and
\inferrule
  {\Gamma \vdash e_1 : T_1 \rightarrow T_2 \\
   \Gamma \vdash e_2 : T_1}
  {\Gamma \vdash e_1 \; e_2 : T_2}
  \quad (\textsc{T-App})
\end{mathpar}
\caption{Lambda Calculus Type Rules}
\label{f:lambda_type}
\end{figure}
We read $\Gamma \vdash e : T$ as expression $e$ has type $T$ in environment $\Gamma$. We use \textsc{T-Var}, \textsc{T-Lambda} and \textsc{T-App} as the rules for type checking variables, lambda expressions and function applications respectively. Figure \ref{f:lambda_eval} gives the dynamic semantics, i.e. the rules governing the evaluation of $\lambda$-calculus expressions.
\begin{figure}[h]
\begin{mathpar}
\inferrule
  {}
  {(\lambda x : T. e) v \longrightarrow [v/x]e}
  \quad (\textsc{E-Lambda})
  \and
\inferrule
  {e_1 \longrightarrow e_1'}
  {e_1 \; e_2 \longrightarrow e_1' \; e_2}
  \quad (\textsc{E-App1})
\inferrule
  {e_2 \longrightarrow e_2'}
  {e_1 \; e_2 \longrightarrow e_1 \; e_2'}
  \quad (\textsc{E-App2})
  \and
\end{mathpar}
\caption{Lambda Calculus Type Rules}
\label{f:lambda_eval}
\end{figure}
By \textsc{E-Lambda}, the application of a lambda expression to an argument evaluates to the body of the lambda expression where we substitute $x$ for $v$. Before we can apply \textsc{E-Lambda}, we need to evaluate both the argument and the lambda expression to values. We use \textsc{E-App1} and \textsc{E-App2} respectively.

While this is a fairly simple type system, it does demonstrate how we are able to model type systems mathematically. There are generally two methods that are commonly used to model the semantics of a type system, big-step \cite{Kahn:1987:NS:28220.28222} and small-step \cite{Plotkin81astructural} semantics. The semantics of this type system are an instance of small-step semantics. The evaluation of terms is modelled incrementally in \emph{small steps}, we only evaluate an expression as a whole once all sub-expressions have been evaluated. Big step semantics on the other hand models evaluation as a single \emph{big step}. Each approach has strengths although small-step semantics is the approach used by most programming language designers, and is the approach used in our work.

\subsubsection{Soundness}
The advantage of developing a mathematical model of a type system is that we are then able to easily prove properties of that type system. The most common property that language designers seek to prove is \emph{soundness} or \emph{safety}. This means that for a type system, well typed expressions do not get stuck or go wrong. This is captured by two theorems, \emph{Progress} and \emph{Preservation} \cite{Wright:1994:SAT:191905.191909, Pierce:2002:TPL:509043}.
\begin{theorem}[Progress]\label{th:progress}
Any well-typed expression can either be evaluated to some other expression (make progress), or is a final value.
\end{theorem}
\begin{theorem}[Preservation]\label{th:preservation}
The evaluation of any well-typed expression results in a well-typed expression.
\end{theorem}
Using these two theorems, we can show that any well-formed program will evaluate to a well-formed result.


\subsubsection{Nominal vs Structural Typing}
In this document I mention the distinction between \emph{nominal} and \emph{structural} type systems. In a nominal type system types have names, and subtyping is based on the explicit inheritance of those types. A structural type system on the other hand is one where subtyping is based on the structure of the types and not the names. Most programmers will be familiar with nominal typing as it is the form of typing found in most modern object oriented languages like Java, C++ and C\#. Structural however is not as common. As an example, consider the Java \verb|print| method below.
\begin{lstlisting}[mathescape, style=custom_lang]
public void print (Printable p){
	p.print();
}
\end{lstlisting}
\verb|Printable| is some Java interface that has a print method. Any object that we want to print using \verb|print| must implement \verb|Printable|. This is a common pattern in languages that make heavy use of inheritance. However in reality all we probably want is that whatever type \verb|p| has it must contain a \verb|print| method, we don't actually care what it's called. Using a structurally typed language we could rewrite the example.
\begin{lstlisting}[mathescape, style=custom_lang]
public void print (p : {void print();}){
	p.print();
}
\end{lstlisting}
Now all we require is that \verb|p| contain some method \verb|print| that does not return anything. In fact we don't need to mention type names at all.   Structural typing means that one $S$ subtypes $T$ if $S$ contains at least the methods and fields of $T$, no matter the name.

\section{Generic Programming}
Developing generic libraries such as collections generally requires support from the language. Designers of statically type checked object oriented languages have sought to solve this problem by extending their languages. Most modern mainstream languages provide support for generic programming in some capacity. The most common form of generic programming is generic type parameters. Functions and classes are parametrized with bounded generic types that are initialised at runtime, but can be type checked statically. An alternative feature to type parameters are type members. Objects can contain types as members in the same way they do fields and functions. Type parameters and type members can be used to solve similar problems \cite{Igarashi1999}. In this section I will describe both type parameters and type members along their relative strengths and weaknesses. 

\subsection{Type Parameters}
Type parameters are a common language construct that is not limited to object oriented languages, and in fact derives from bounded quantification in functional languages \cite{Canning:1989:FPO:99370.99392, Cardelli:1985:UTD:6041.6042}. Type parameters in object oriented languages generally allow classes and functions to be parametrised by bounded types. That is types that are subtype bound to some upper bound. Code can be checked statically while allow specific instances to define types at run time. A common example are collections.
\begin{lstlisting}[mathescape, style=custom_lang]
public interface Collection<E extends Object>{
	public abstract void add(E e);
	
	public abstract E get();
	
	public abstract iterator<E> iterator();
}
\end{lstlisting}
Using a Java-like syntax, we define a \verb|Collection| interface that is parametrised by a type parameter \verb|E| bounded by \verb|Object|. We can implement \verb|Collection| and be able to talk about generic collections of objects. We do not need to create a \verb|StringCollection| or an \verb|IntegerCollection|. Below we can show such an implementation.
\begin{lstlisting}[mathescape, style=custom_lang]
public class LinkedList<E extends Object> implements Collection<E>{

	private E elem;
	private LinkedList<E> next;
	
	public LinkedList (E elem, LinkedList<E> next){
		this.elem = elem;
		this.next = next;
	}
	
	public void add(E elem){
		if(next == null)
		  this.next = new LinkedList<E>(elem, null);
		else
			next.add(elem);
	}
	
	public E get(){
		return this.elem;
	}
	
	public abstract iterator<E> iterator(){
		return new Iterator<E>(...);
	}
}
\end{lstlisting}
This allows for bounded polymorphism and code that is abstracted from the implementation of specific concrete types. Without the use of generic type parameters library developers would either have to write specific classes and functions for each list type they wished to use, or write unsuitably broad lists of \verb|Object| type. A single generic class or function can be used to initialize any list while maintaining precise types at both write and read. Note that type parameters are especially powerful in a nominal language such as Java. The ability to write generic classes provides the kind of code reuse that would be unavailable in a structural setting. Below we demonstrate how we could use our \verb|LinkedList| class.
\begin{lstlisting}[mathescape, style=custom_lang]
...
LinkedList<String> l = new LinkedList<String>();
l.add(``Hello'');
l.add(``World'');
Collection<String> c1 = l; \\safe
Collection<Object> c2 = l; \\compile time error
...
\end{lstlisting}
Due to contra-variant type restrictions on write, we restrict subtyping to invariance on type parameters.

\subsection{Type Members}
Type members are an alternative to type parameters, and were suggested as part of BETA \cite{Madsen:1989:VCP:74877.74919}. Type members attempt to solve similar problems to type parameters but are not a wide spread as type parameters. Instead of parametrizing functions and classes with bounded types, types are included as object members in the same way as fields or functions. The previous \verb|Collection| example can be rewritten using type members.
\begin{lstlisting}[mathescape, style=custom_lang]
public interface Collection{
	public type E : Object;

	public abstract void add(this.E e);
	
	public abstract this.E get();
	
	public abstract iterator iterator();
}
\end{lstlisting}
Now if we want to create a concrete instance of Collection, we can simply extend the collection interface. Below we have implemented the \verb|Collection| interface to create an \verb|IntegerLinkedList| class. We are free to subtype \verb|E| on extension.
\begin{lstlisting}[mathescape, style=custom_lang]
public class StringLinkedList implements Collection{
	public type E : String;

	private this.E elem;
	private StringLinkedList next;
	
	public StringLinkedList (this.E elem, StringLinkedList next){
		this.elem = elem;
		this.next = next;
	}
	
	public void add(this.E elem){
		if(next == null)
		  this.next = new StringLinkedList(elem, null);
		else
			next.add(elem);
	}
	
	public this.E get(){
		return this.elem;
	}
	
	public abstract StringIterator iterator(){
		return new StringIterator(...);
	}
}
\end{lstlisting}
Assuming \verb|StringIterator| is otherwise appropriately defined, our new \verb|StringLinkedList| class subtypes the original \verb|Collection| type. Below we initialise a \verb|StringLinkedList| object.
\begin{lstlisting}[mathescape, style=custom_lang]
...
StringLinkedList l = new StringLinkedList();
l.add(``Hello'');
l.add(``World'');
l.add(new Object()); \\compile time error
Collection c = l; \\safe
c.add(new Object()); \\runtime error
...
\end{lstlisting}
With type members we can allow for subtype variance in type members, however this means we are potentially unable to catch certain errors statically. As can be seen in these examples, type parameters and type members provide solutions to similar problems, however each has certain strengths and weaknesses.

\subsection{Type Members vs Type Parameters}
\subsubsection{Strengths of Type Parameters}

The examples thus far have demonstrated one strength of type parameters over type members. In the \verb|Collection| examples, we need only write one \verb|LinkedList| class that can be used as common implementation for constructing \verb|LinkedList|s of any type. When using type members, we need to write a new class for each kind of \verb|LinkedList| we hope to create. This has powerful consequences for developers hoping to write generic libraries. Programmers who wish to use a library need only use the types provided, they do not need to re-implement generic types. This is further a problem when extending a type hierarchy. The following example is a modified version of one by Bruce et. al. \cite{Bruce:1998:SSA:646155.679691}. Using type parameters, we are able to treat \verb|LinkedList<String>| as \verb|Collection<String>|.
\begin{lstlisting}[mathescape, style=custom_lang]
...
Collection<String> l = new LinkedList<String>(); \\safe
...
\end{lstlisting}
This is reasonable to expect, and is quite a common requirement when writing generic code. This is not necessarily possible in a nominal type system with type members. While in our earlier example, we saw that \verb|StringLinkedList| subtypes \verb|Collection|, it does not subtype a string specific \verb|Collection|. To demonstrate this we can rewrite the earlier type members example.
\begin{lstlisting}[mathescape, style=custom_lang]
public class StringCollection extends Collection{
	public type E : String;
}

public class LinkedList implements Collection{
	public type E : Object;

	private this.E elem;
	private LinkedList next;
	
	public LinkedList (this.E elem, LinkedList next){
		this.elem = elem;
		this.next = next;
	}
	
	public void add(this.E elem){
		if(next == null)
		  this.next = new LinkedList(elem, null);
		else
			next.add(elem);
	}
	
	public this.E get(){
		return this.elem;
	}
	
	public abstract Iterator iterator(){
		return new Iterator(...);
	}
}

public class StringLinkedList extends LinkedList{
	public type E : String;
}
\end{lstlisting}
Here \verb|StringCollection| extends our original \verb|Collection| interface by subtyping the \verb|E| type member, \verb|LinkedList| implements \verb|Collection|, and \verb|StringLinkedList| extends \verb|LinkedList|. Now to provide similar functionality to type parameters, we would want \verb|StringLinkedList| to subtype \verb|StringCollection|. This is not the case since subtyping is done via inheritance and \verb|StringLinked| does not extend \verb|StringCollection|. Now this happens to be as much an artefact of nominal type systems as type members, and in Section \ref{s:intro:wyvern} I will discuss this further.

The major difference between the two approaches is the fact that generic type parameters are explicit and type members are implicit. What this means is that when dealing with generic type via parameters, each type must be explicitly defined at the top level of any class or function using it, while type members are implicitly handled by the objects containing them. Both approaches can be advantageous depending on the situation. Another example taken from Bruce et. al. \cite{Bruce:1998:SSA:646155.679691} involves introducing more types to a function. First lets modify our \verb|LinkedList| example using type parameters.
\begin{lstlisting}[mathescape, style=custom_lang]
public class Pair<Fst extends Object, Snd extends Object>{
	public Fst fst;
	public Snd snd;
}

public class LinkedList<E extends Objects> implements Collection{

	...
	
	public List<Pair<E,F>> zip <F extends Object>(List<F> listF){
		...
	}	
}
\end{lstlisting}
If we imagine that the \verb|zip| function zips a list of some type \verb|F| to the receiver we can see it is quite easy to introduce and use new generic types. The same example using type members however becomes much more difficult. Our problem now is that in order to generically define a second \verb|LinkedList| we need to know the extended subtype of that list. Again this is as much a consequence of a nominal type system where subtyping is based upon inheritance as it is type members. 

\subsubsection{Strengths of Type Members}

\subsubsection{Featherweight Generic Java}
Featherweight Generic Java (FGJ) was developed as a minimal core calculus for Java with generic type parameters by Igarashi and Pierce \cite{Igarashi:2001:FJM:503502.503505}. As a minimal core calculus, FGJ provides an easy way to reason about extensions to generic Java. The FGJ syntax is given in Figure \ref{f:fgj_syntax}. 
The simplicity of the FGJ syntax allows for the easy extension of Java with generics \cite{Potanin:2006:GOG:1167473.1167500, Zibin:2010:OIG:1932682.1869509} by limiting the language to only the core properties that interact with generics. FGJ is limited to variables, field accesses, method calls, new expressions and casts. The semantics are similarly simple although not given. 

The key contribution of \emph{FGJ} was that calculi for future extensions and innovations to generic Java could be easily constructed and investigated. As a result, \emph{FGJ} has become a standard core calculus used in research on Java.

\section{Scala}
Scala \cite{scaladocs2016} is a superset of Java that adds several additional language features including type members. While type members are implemented in Scala, they are not strictly sound. That is there does not exist a formalism for type members in Scala as there is for type members in Java. There has however been work to formalise such a type system \cite{Amin:2014:FPT:2660193.2660216,amin:fool:2012}. Given that Scala provides not only nominal typing as in Java, but structural typing too, it is natural to use Scala as the basis for developing type members in Wyvern.

\subsection{Type Members in Scala}
In 2012, Amin et. al. \cite{amin:fool:2012} presented a type system featuring type members in a structurally typed setting. 

They identified several impediments to a soundness proof of such a type system. Most of these had to do with environments narrowing at evaluation (evaluation resulting in more precise types for expressions), and one to with incorporating path dependent types. 

\subsubsection{Term Membership Narrowing}
One restriction that is made syntactically by the Amin et al \cite{amin:fool:2012} type system is that type members selections may only be made upon paths, where paths are values (memory locations), variables and field accesses on paths. This restriction is made because path comparison between arbitrary expressions would be much harder if this included method calls. This restriction can result in well-formed expressions losing well-formedness as a result of evaluation. Consider the following example.
\begin{lstlisting}[mathescape, style=custom_lang]
X = {z $\Rightarrow$ var f : $\top$}
Y = {z $\Rightarrow$ type L : $\top$ .. $\top$}
	  var f : z.L}
A = {z $\Rightarrow$ def meth : X}
\end{lstlisting}
Using these types we can construct the following expression.
\begin{lstlisting}[mathescape, style=custom_lang]
var a = new A(def meth : X = {new Y(...)});
a.meth.f;
\end{lstlisting}
We type check this example as $\top$, the type of \verb|a.meth.f|. The method \verb|meth| has type \verb|X| in \verb|a|, however the body has type \verb|Y|, and \verb|f| has type $\top$ in \verb|X| and type \verb|z.L| in \verb|Y|, where \verb|z| is the receiver of \verb|f|. Evaluation eventually results in \verb|new Y(...).f| which has type \verb|new Y(...).L| which is not a valid type. 

\subsubsection{Loss of Expansion}
One requirement of recursively defined type members with bounds that Amin et al imposes is that the type members have some expansion. That is, there exists a set of declaration types for any well-formed type member. A record type (\verb|{z $\Rightarrow$ d1, d2, ...}|) expands to its set of declarations (\verb|d1, d2, ...|), while a type selection expands to the expansion of its upper bound. Consider the following example.
\begin{lstlisting}[mathescape, style=custom_lang]
{z $\Rightarrow$ type A : $\bot$ .. z.B
      type B : $\bot$ .. z.A}
\end{lstlisting}
In this case there does not exist an expansion for either \verb|z.A| or \verb|z.B|. While this example is not possible to write, it is possible to construct an example that evaluates to this scenario.
\subsubsection{Loss of Well-Formedness}

\subsubsection{The Path Dependency Problem}







\section{Wyvern}\label{s:wyvern}
We develop our type members type systems as an addition to the core Wyvern calculus. Wyvern is a new statically typed object oriented language with structural types and an emphasis on secure web programming \cite{wyvern2016}. Wyvern is designed with a core calculus that largely resembles the simple typed lambda calculus with objects \cite{Nistor:2013:WST:2489828.2489830}. It is then demonstrated that this core calculus can be translated to the simple type lambda calculus. Additions such as classes and modules are developed as extensions to this core calculus. Using the typed lambda calculus as the basis for the language ensures that the core is easy to demonstrate as sound. It then follows that if such extensions such as classes are no more than syntactic additions they too are sound. This is a useful way to think about languages from a practical design perspective.

Type members and type parameters are not features that would be easily included as simple syntactic extensions, they require significant extension to the semantics. For this reason type members are intended to form part of the core Wyvern calculus. As a core feature to the language, it is important that they be proven sound. Further, it is the addition to this core calculus that requires a small-semantics. If we concede the use of a big-step semantics for the core calculus, then we must develop the entire language using a big-step semantics. The standard approach of small-step semantics compliments the Wyvern idea of extensibility. Figure \ref{f:wyvern_syntax} gives the Featherweight Wyvern syntax
\begin{figure}[h]
\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expression \\
& | & \lambda x : T. e &\\
& | & e \; (e) &\\
& | & \texttt{new} \{z \Rightarrow \overline{d}\} &\\
& | & e.f &\\
& | & e.f = e &\\
& | & e.m &\\
&&\\
T & ::= & L & type \\
& | & T \rightarrow T &\\
 \end{array}
& ~~~~~~
&
\begin{array}{lllr}
d & ::= & \texttt{var} \; f : T = e &declaration\\
& | & \texttt{def} \; m : T = e &\\
& | & \texttt{type} \; m : L = \{\overline{\sigma}\} &\\
&&\\
\sigma & ::= & \texttt{var} \; f : T &declaration \; type\\
& | & \texttt{def} \; m : T &\\
& | & \texttt{type} \; m : L = \{\overline{\sigma}\} &\\
&&\\
\Gamma & :: = & \varnothing \; | \; \Gamma,\; x : T & env \\
\end{array}
\end{array}
\]
\caption{Featherweight Wyvern Syntax}
\label{f:wyvern_syntax}
\end{figure}
This syntax is very similar to that in Figure \ref{f:lambda_syntax}. The only additions are those required as support for objects. Featherweight Wyvern adds object initialisation ($\texttt{new} \{z \Rightarrow \overline{d}\}$), field access ($e.f$), field assignment ($e.f = e$) and method access ($e.m$) to the simply typed lambda calculus. While it does contain rudimentary type members ($\texttt{type} \; m : L = \{\overline{\sigma}\}$) they are not the full fledged type members we intend to have. 

%\section{Coq Proof Assistant}
%
%The Coq Proof Assistant is a mechanically checked theorem prover 






\chapter{Generic Wyvern}\label{ch:wyvern}
We could potentially design several different forms of Type Members depending on the flexibility we desire. The simplest form of virtual types is similar to the one in our first example, a single type that is invariant with subtyping. As an example we can try to model animals and food. 
\begin{lstlisting}[mathescape, style=custom_lang]
Animal = {z $\Rightarrow$	type F = Food
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
This is a common example used in Type Members literature, and so we will make use of it here. We define an \verb|Animal| type that contains a type member \verb|F| that is initialized to \verb|Food|, some previously defined type, and a method definition \verb|eat| that a \verb|z.F| as a parameter. This seems like a reasonable description of an animal that eats anything that qualifies as \verb|Food|, however, we might expect to want to refine this in a subtype. For instance
\begin{lstlisting}[mathescape, style=custom_lang]
Cow = {z $\Rightarrow$	type F = Grass
		val isMeat = True
		
		def void eat (x : z.F){
			...
		}}

Lion = {z $\Rightarrow$	type F = Meat
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
we would hope that both \verb|Cow| and \verb|Lion| would be \verb|Animal|s, however if this were the case, we could end up with type errors if we had what we thought we \verb|Animal|s and we attempted to feed them \verb|Meat|, but one happed to be a \verb|Cow|. The example below illustrates this.
\begin{lstlisting}[mathescape, style=custom_lang]
def void feed (a : Animal, f : Food){
	a.eat(f)
}

g = new Grass(..)
c = new Cow(...)
l = new Lion(...)

feed(l,c) \\succeeds
feed(c,g) \\succeeds
feed(c,c) \\fails at runtime
\end{lstlisting}
Without changing our type members are represented, we must make them invariant with subtyping. This still gives us some expressivity, most forms of generic types enforce invariance on the type parameters. However, we might want more flexibility.
If we want to vary type members covariantly with subtyping we can add upper and lower bounds. Now we can rewrite the \verb|Animal|, \verb|Cow| and \verb|Lion| types with bounds on the type members.
\begin{lstlisting}[mathescape, style=custom_lang]
Animal = {z $\Rightarrow$	type F = $\bot$ .. Food
		
		def void eat (x : z.F){
			...
		}}
		
Cow = {z $\Rightarrow$	type F = $\bot$ .. Grass
		val isMeat = True
		
		def void eat (x : z.F){
			...
		}}

Lion = {z $\Rightarrow$	type F = $\bot$ .. Meat
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
When we add a lower bound, types that subtype the lower bound subtype the type member. This means that we can vary the upper bound covariantly while keeping the lower bound invariant. Now \verb|Cow| and \verb|Lion| subtype \verb|Animal|. We can still however get more flexibility out of the language. If we allow the lower bound to vary contra-variantly we can get yet more expressiveness. Rewriting the  \verb|Animal|, \verb|Cow| and \verb|Lion| types we can see how.
\begin{lstlisting}[mathescape, style=custom_lang]
Animal = {z $\Rightarrow$	type F = $\bot$ .. Food
		
		def void eat (x : z.F){
			...
		}}
		
Cow = {z $\Rightarrow$	type F = Grass .. Grass
		val isMeat = True
		
		def void eat (x : z.F){
			...
		}}

Lion = {z $\Rightarrow$	type F = Meat .. Meat
		
		def void eat (x : z.F){
			...
		}}
\end{lstlisting}
Now a \verb|Cow| is able to eat any \verb|Grass| and a \verb|Lion|is able to eat any \verb|Meat|. While this is the most complex form of type members, and brings with it the most complexity, it is also the most expressive. For this reason we chose to formalise this form of type members.

We have already developed a type system that while not sound solves several of the recurring issues that other work has encountered. In this section I will present our current type system (Generic Wyvern).

Wyvern is a new statically typed programming language being developed for secure web applications. There are two popular and well-documented methods \cite{Virtual Types stuff, generic java etc} for implementing generic types.
\begin{itemize}
\item \emph{Type Parameters}: Types are parametrised by generic type names that are defined at runtime. This allows programmers to reuse generic code. Many popular languages use generic type parameters such as \emph{Java}, \emph{C\#} and \emph{Scala}.
\item \emph{Type Members}: Types and objects may contain type members in the same manner as normal field or method members. These can be subtyped by more precise types to provide generic behaviour.
\end{itemize}
There have long been attempts to formalise a sound small-step semantics for type members in a structural setting for Scala, which have as yet all been unsuccessful due to issues where well-typed expressions are lost during subject reduction. In 2014 Amin et.al. were able to formalise a big step semantics for Scala style type members. While this demonstrates the soundness of the kinds of programs we wish to type check, a small-step semantics offers powerful advantages when reasoning about the behaviour of programs. For this reason we formalise type members with a small step semantics.
We build upon the work of Amin et. al. \cite{Scala stuff} to formalise type members in structurally typed languages using a small step semantics. 

\subsection{Transitivity, Narrowing and Type Members}
\label{sec:trans_narow}
Two properties that one might reasonably expect 
to occur naturally in a structurally typed language are 
\emph{Subtype Transitivity} and \emph{Environment Narrowing}
(Figure \ref{f:trans_narrowing}).
\begin{figure}[h]
\begin{mathpar}
\inferrule
	{\Gamma \vdash S <: T \\
	 \Gamma \vdash T <: U}
	{\Gamma \vdash S <: U}
  \quad (\textsc {Subtype Transitivity})
	\and
\inferrule
  {\Gamma, (x : U) \vdash T <: T'\\
   \Gamma \vdash S <: U}
  {\Gamma, (x : S) \vdash T <: T'}
  \quad (\textsc {Environment Narrowing})
\end{mathpar}
\caption{Subtype Transitivity and Environment Narrowing}
\label{f:trans_narrowing}
\end{figure}
Subtype transitivity is a familiar property, 
and environment narrowing simply expresses the 
expectation that we can treat a variable in an 
environment as having a more precise type without 
changing the type relationships within that environment.

Since transitivity is often used in proving subject 
reduction, it is a problem if a type system lacks this 
property. The issue with transitivity arises from the 
introduction of type member lower bounds, and their 
contra-variance. The following example demonstrates this.
\begin{lstlisting}[mathescape, style=custom_lang]
A = {z $\Rightarrow$ type N : $\bot$ .. $\top$}

B = {z $\Rightarrow$ type N : $\bot$ .. $\top$
          def meth1(x : $\top$){return new{z $\Rightarrow$}}:$\top$}
         
S = {z $\Rightarrow$ type L : A .. $\top$
          val f : A}
         
T = {z $\Rightarrow$ type L : A .. $\top$
          val f : z.L}
         
U = {z $\Rightarrow$ type L : B .. $\top$
          val f : z.L}
\end{lstlisting}
Here \texttt{S} subtypes \texttt{T} and \texttt{T} subtypes 
\texttt{U}, but \texttt{S} does not subtype \texttt{U}. Because 
of the contra-variance of the lower bound of type member \texttt{L}, 
\texttt{A} subtypes \texttt{z.L} in \texttt{T} but not \texttt{U}. 
Amin et al. \cite{Amin 2014} attempt to reconcile this by narrowing 
the type of \texttt{z} in the larger types \texttt{T} and \texttt{U} 
by using the subtype rule in Figure \ref{f:sub_amin}.
\begin{figure}[h]
\begin{mathpar}
\inferrule
  {\Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; \overline{\sigma}_2}
  {\Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
  \quad (\textsc {Structural Subtyping})
\end{mathpar}
\caption{Subtype Transitivity and Environment Narrowing}
\label{f:sub_amin}
\end{figure}
Here we type check the declaration types of the larger type with a smaller receiver. While this allows for subtype transitivity, it introduces environment narrowing that proves unsound in a small step semantics. Amin et. al. were however able to reconcile both transitivity and narrowing within a big step semantics.

\subsection{Path Equality}
To further complicate matters, well-formedness can be lost when reducing field accesses. 

\hl{Julian: Example?}


\section{Type System}

\subsection{Syntax} \label{s:syntax}
In this section we present the Wyvern Type Members Syntax 
in Figure \ref{f:syntax}. 

\begin{figure}[h]
\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expression \\
& | & \texttt{new} \; \{z \Rightarrow \overline{d}\}&\\
& | & e.m(e) &\\
& | & e.f &\\
& | & e \unlhd T&\\
& | & l &\\
&&\\
p & ::= & x & paths \\
& | & l &\\
& | & p \unlhd T &\\
&&\\
v & ::= & l & value \\
& | & v \unlhd T &\\
&&\\
d & ::= & \texttt{val} \; f : T = p & declaration \\
  & |   & \texttt{def} \; m(x:T) = e : T &\\
  & |   & \texttt{type} \; L : T .. T&\\
&&\\
\Gamma & :: = & \varnothing \; | \; \Gamma,\; x : T & Environment \\
&&\\
A & :: = & \varnothing \; | \; A,\;  <: T & Assumption \; Context \\
 \end{array}
& ~~~~~~
&
\begin{array}{lllr}
T & ::= & \{z \Rightarrow \overline{\sigma}\} & type \\
& | & p.L &\\
%& | & T \wedge T & \\
%& | & T \vee T & \\
& | & \top & \\
& | & \bot & \\
&&\\
\sigma & ::= & \texttt{val} \; f:T & decl \; type\\
       & |   & \texttt{def} \; m:T \rightarrow T \\
		 & |   & \texttt{type} \; L : T .. T &\\
&&\\
E & :: = & \bigcirc & eval \; context\\
       & | & E.m(e)\\
       & | & p.m(E)\\
       & | & E.f\\
       & | & E \unlhd T\\
&&\\
d_v & ::= & \texttt{val} \; f : T = v & declaration \; value \\
  & |   & \texttt{def} \; m(x:T) = e : T &\\
  & |   & \texttt{type} \; L : T .. T = T &\\
&&\\
\mu & :: = & \varnothing \; | \; \mu,\; l \mapsto \{z \Rightarrow \overline{d}\} & store \\
\Sigma & :: = & \varnothing \; | \; \Sigma,\; l : \{\texttt{z} \Rightarrow \overline{\sigma}\} & store \; type \\
\end{array}
\end{array}
\]
\caption{Syntax}
\label{f:syntax}
\end{figure}

\textbf{Expressions} ($e$): Expressions are variables ($x$), new 
expressions ($\texttt{new} \; \{z \Rightarrow \overline{d}\}$), 
method calls ($e.m(e)$), field accesses ($e.f$), expression 
upcasts ($e \unlhd T$) and locations ($l$) in the store. The 
only expression that differs from tradition is the explicit upcasts on expressions. 
We use upcasts to avoid the narrowing issues described in Section
We employ a similar strategy with regard to the explicitly 
upcast expression $e \unlhd T$. Here $e$ may have a more precise 
type than $T$, but to avoid narrowing we maintain the type $T$.

\textbf{Types} ($T$): Types are restricted to structural types 
($\{z \Rightarrow \overline{\sigma}\}$), type member selections on 
paths ($p.L$), ($\top$) the top type at the top of the type lattice 
that represents the empty type and $\bot$ the bottom type at the 
bottom of the type lattice that represents the type containing 
al possible declaration labels with $\top$ in the contra-variant 
type position, and $\bot$ in the covariant type position.

\textbf{Paths} ($p$): Paths are expressions that type selections may be 
made on. We restrict these to variables ($x$), locations ($l$) and upcast paths ($p \unlhd T$).

\textbf{Values} ($v$): Values in our type system are locations ($l$) and upcast values ($v \unlhd T$). 

\textbf{Declarations} ($d$): Declarations may be fields (\texttt{val}), 
methods (\texttt{def}) or type members (\texttt{type}). These are all
standard.

\textbf{Declaration Types} ($\sigma$): Declaration types may be field 
(\texttt{val}), method (\texttt{def}) or type members (\texttt{type}). 

\textbf{Declaration Values} ($d_v$): Declaration values are similar to 
declarations, except we require field initializers to be values.

On top of these, we also include an evaluation context $E$, an environment 
$\Gamma$ that maps variables to types, a store $\mu$ that maps locations 
to objects, a store type $\Sigma$ used to type check the store and an 
assumption context $A$ that is used to type check recursive types (\cite{Amber Rules etc})
that consists of a list of type pairs.



\subsection{Semantics}
In this section we describe the Wyvern Type Members semantics.
\subsubsection{Path Functions}

\hl{Julian: I'll finish describing these functions later once they are finalized.}

\begin{figure}[h]
\begin{mathpar}
\inferrule
  {}
  {p \equiv p}
  \quad (\textsc{Eq-Refl})
  \and
\inferrule
  {p_1 \equiv p_2}
  {p_2 \equiv p_1}
  \quad (\textsc{Eq-Sym})
  \and
\inferrule
  {p_1 \equiv p_2 \\
   p_2 \equiv p_3}
  {p_1 \equiv p_3}
  \quad (\textsc{Eq-Trans})
  \and
\inferrule
  {p_1 \equiv p_2}
  {p_1 \equiv p_2 \unlhd T}
  \quad (\textsc{Eq-Path})
\end{mathpar}
\caption{Path Equivalence}
\label{f:path_equiv}
\end{figure}
In Figure \ref{f:path_equiv} we describe our path equivalence judgement. Two paths are equivalent if they wrap up the same variable or location. This is useful when trying to compare two types that are not technically the same types, but are derived from the same object.

\subsubsection{Subtyping}
Subtyping is given in Figure \ref{f:subtype}. We use a 
modified version of the subtyping relation 
described by Amin et. al. \cite{Scala stuff}. We remove the reflexivity rule, however this can be inferred from the other subtyping rules. We modify the \textsc{S-Struct} rule for structural subtyping by upcasting the self variable of the larger type to avoid narrowing. This can be seen in \textsc{S-Struct} in Figure \ref{f:subtype}.
If we didn't do this, we would have to type check the declaration types of the larger type with a smaller receiver, resulting in narrowing. We also need to be able subtype two path equivalent selection types(\textsc{S-Path} in Figure \ref{f:subtype}). Since we can have two paths that are equivalent in that they lead to the same location or variable while having different types, we need a way to subtype path equivalent type selections. We require that they have the appropriate contra-variant and covariant relationships between their lower and upper bounds respectively. To deal with recursive types, we use an assumption context $A$ which we use to type check the bounds of the selection type. For this we introduce the \textsc{S-Assume} rule. \textsc{S-Select-Upper} and \textsc{S-Select-Lower} are our rules for subtyping selection types. To supertype or subtype a selection type, a type needs to supertype or subtype its upper or lower bounds respectively. We then use \textsc{S-Top} and \textsc{S-Bottom} to type check the subtyping and supertyping of the top ($\top$) and bottom ($\bot$) types.

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash S <: T$}
\begin{mathpar}
\inferrule
  {(S <: T) \in A}
  {A; \Sigma; \Gamma \vdash S\; \texttt{<:}\; T}
  \quad (\textsc {S-Assume})
	\and
\inferrule
	{A; \Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; [z \unlhd \{z \Rightarrow \overline{\sigma}_2\} / z]\overline{\sigma}_2}
	{A; \Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
	\quad (\textsc {S-Struct})
	\and
\inferrule
	{p_1 \equiv p_2 \\
	 A; \Sigma; \Gamma \vdash p_1 \ni \texttt{type} \; L : S_1 .. U_1 \\
	 A; \Sigma; \Gamma \vdash p_2 \ni \texttt{type} \; L : S_2 .. U_2 \\
	 A, (p_1.L <: p_2.L); \Sigma; \Gamma \vdash S_2 <:\; S_1 \\
	 A, (p_1.L <: p_2.L); \Sigma; \Gamma \vdash U_1\; <:\; U_2}
	{A; \Sigma; \Gamma \vdash p_1.L\; <:\; p_2.L}
	\quad (\textsc {S-Path})
	\and
\inferrule
	{A; \Sigma; \Gamma \vdash p \ni \texttt{type} \; L : S .. U\\
	 A; \Sigma; \Gamma \vdash S <: U \\
	 A; \Sigma; \Gamma \vdash U <: T}
	{A; \Sigma; \Gamma \vdash p.L\; <:\; T}
	\quad (\textsc {S-Select-Upper})
	\and
\inferrule
	{A; \Sigma; \Gamma \vdash p \ni \texttt{type} \; L : S .. U \\
	 A; \Sigma; \Gamma \vdash S <: U \\
	 A; \Sigma; \Gamma \vdash T <: S}
	{A; \Sigma; \Gamma \vdash T \; <:\; p.L}
	\quad (\textsc {S-Select-Lower})
	\and
\inferrule
	{}
	{A; \Sigma; \Gamma \vdash T\; \texttt{<:}\; \top}
	\quad (\textsc {S-Top})
	\and
\inferrule
	{}
	{A; \Sigma; \Gamma \vdash \bot\; \texttt{<:}\; T}
	\quad (\textsc {S-Bottom})
\end{mathpar}
\hfill \fbox{$A; \Sigma; \Gamma \vdash \sigma <: \sigma'$}
\begin{mathpar}
\inferrule
	{}
	{A; \Sigma; \Gamma \vdash \texttt{val} \; f:T <: \texttt{val} \; f:T}
	\quad (\textsc {S-Decl-Val})
	\and
\inferrule
	{A; \Sigma; \Gamma \vdash S' <: S \\
	 A; \Sigma; \Gamma \vdash T <: T'}
	{A; \Sigma; \Gamma \vdash \texttt{def} \; m:S \rightarrow T <: \texttt{def} \; m:S' \rightarrow T'}
	\quad (\textsc {S-Decl-Def})
	\and
\inferrule
	{A; \Sigma; \Gamma \vdash S' <: S \\
	 A; \Sigma; \Gamma \vdash U <: U'}
	{A; \Sigma; \Gamma \vdash \texttt{type} \; L : S .. U \; <:\; \texttt{type} \; L : S' .. U'}
	\quad (\textsc {S-Decl-Type})
\end{mathpar}
\caption{Subtyping}
\label{f:subtype}
\end{figure}

\subsubsection{Well-Formedness}

\hl{Julian: Do we need to worry about this?}

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash T \;  \textbf{wf}$}
\begin{mathpar}
\inferrule
  {A; \Sigma; \Gamma \vdash p \ni \texttt{type} \; L : S .. U \\
  	A; \Sigma; \Gamma \vdash \texttt{type} \; L : S .. U \; \textbf{wf} }
  {A; \Sigma; \Gamma \vdash p.L \; \textbf{wf}}
  \quad (\textsc {WF-Sel})
	\and
\inferrule
  {A; \Sigma; \Gamma,z:\{z \Rightarrow \overline{\sigma}\} \vdash \overline{\sigma} \; \textbf{wf} \\
  	\forall j \neq i, \; dom(\sigma_j) \neq dom(\sigma_i)}
  {A; \Gamma; \Sigma \vdash \{z \Rightarrow \overline{\sigma}\} \; \textbf{wf}}
  \quad (\textsc {WF-Struct})
	\and
\inferrule
  {}
  {A; \Sigma; \Gamma \vdash \top \;  \textbf{wf}}
  \quad (\textsc {WF-Top})
	\and
\inferrule
  {}
  {A; \Sigma; \Gamma \vdash \bot \;  \textbf{wf}}
  \quad (\textsc {WF-Bot})
\end{mathpar}
\hfill \fbox{$A; \Sigma; \Gamma \vdash \sigma \;  \textbf{wf}$}
\begin{mathpar}
\inferrule
  {A; \Sigma; \Gamma \vdash T : \textbf{wf}}
  {A; \Sigma; \Gamma \vdash \texttt{val} \; f:T \;  \textbf{wf}}
  \quad (\textsc {WF-Val})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash T : \textbf{wf} \\
  	A; \Sigma; \Gamma \vdash S : \textbf{wf}}
  {A; \Sigma; \Gamma \vdash \texttt{def} \; m:S \rightarrow T \;  \textbf{wf}}
  \quad (\textsc {WF-Def})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash S : \textbf{wfe} \; \vee \; S = \bot\\
  	A; \Sigma; \Gamma \vdash U : \textbf{wfe} \\
  	A; \Sigma; \Gamma \vdash S <: U}
  {A; \Sigma; \Gamma \vdash \texttt{type} \; L : S .. U \; \textbf{wf}}
  \quad (\textsc {WF-Type})
\end{mathpar}
\hfill \fbox{$A; \Sigma \vdash \Gamma \;  \textbf{wf}$}
\begin{mathpar}
\inferrule
  {\forall x \in dom(\Gamma), A; \Sigma; \Gamma \vdash \Gamma(x) \; \textbf{wf}}
  {\Sigma \vdash \Gamma \;  \textbf{wf}}
  \quad (\textsc {WF-Environment})
\end{mathpar}
\hfill \fbox{$\Sigma \;  \textbf{wf}$}
\begin{mathpar}
\inferrule
  {\forall l \in dom(\Sigma), \varnothing; \Sigma; \varnothing \vdash \Sigma(l) \; \textbf{wf}}
  {\Sigma \;  \textbf{wf}}
  \quad (\textsc {WF-Store-Context})
\end{mathpar}
\begin{mathpar}
\inferrule
  {\forall l \in dom(\mu), \varnothing; \Sigma; \varnothing \vdash \mu(l) : \Sigma(l)}
  {\Sigma \vdash \mu \; \textbf{wf}}
  \quad (\textsc {WF-Store})
\end{mathpar}
\caption{Well-Formedness}
\label{f:wf}
\end{figure}

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash T \;  \textbf{wfe}$}
\begin{mathpar}
\inferrule
  {A; \Sigma; \Gamma \vdash T \; \textbf{wf} \\
  	A; \Sigma; \Gamma \vdash T \prec \overline{\sigma}}
  {A; \Sigma; \Gamma \vdash T \; \textbf{wfe}}
  \quad (\textsc {WFE})
\end{mathpar}
\caption{Well-Formed and Expanding Types}
\label{f:wfe}
\end{figure}

\subsubsection{Type Expansion and Membership}

We use a modified version of the type expansion (Figure \ref{f:exp}) definition and the same membership (Figure \ref{f:mem}) definition from Amin et al \cite{Scala stuff}. Expansion of types is used to extract the set of declaration types for a type. \textsc{E-Struct} is the expansion rule for structural types. Structural types simply expand to their defined types. The expansion of selection types (\textsc{E-Sel}) are slightly more complicated. Selection types expand to the expansion of the upper bound. The expansion of the upper bound is type checked with a less precise type (the upper bound) that the selection type. As with our subtyping rule for structural types, we need to prevent narrowing of types at type expansion. For this reason we upcast the self variable $z$ to the original type $U$. The top type expands to the empty set (\textsc{E-Top}). The membership judgement is used to determine the membership of a declaration type for an expression. We type check the expression, expand the expression's type and in the case of path expansion, substitute out the self variable.

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash T \prec \overline{\sigma}$}
\begin{mathpar}
\inferrule
  {}
  {A; \Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}\} \prec_z \overline{\sigma}}
  \quad (\textsc {E-Struct})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash p \ni \texttt{type} \; L : S..U \\
  	A; \Sigma; \Gamma \vdash U \prec_z \overline{\sigma}}
  {A; \Sigma; \Gamma \vdash p.L \prec_z [z \unlhd U/z]\overline{\sigma}}
  \quad (\textsc {E-Sel})
	\and
\inferrule
  {}
  {A; \Sigma; \Gamma \vdash \top \prec_z \varnothing}
  \quad (\textsc {E-Top})
\end{mathpar}
\caption{Expansion}
\label{f:exp}
\end{figure}

\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash e \ni \sigma$}
\begin{mathpar}
\inferrule
  {A; \Sigma; \Gamma \vdash p : T \\
  	A; \Sigma; \Gamma \vdash T \prec_z \overline{\sigma}\\
  	A; \sigma_i \in \overline{\sigma}}
  {A; \Sigma; \Gamma \vdash p \ni [p/z]\sigma_i}
  \quad (\textsc {M-Path})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash e : T \\
  	A; \Sigma; \Gamma \vdash T \prec_z \overline{\sigma}\\
  	\sigma_i \in \overline{\sigma} \\
  	z \notin \sigma_i}
  {A; \Sigma; \Gamma \vdash e \ni \sigma_i}
  \quad (\textsc {M-Exp})
\end{mathpar}
\caption{Membership}
\label{f:mem}
\end{figure}

\subsubsection{Expression Typing}
Expression typing is fairly straight forward and is 
given in Figure \ref{f:e_typ}. Variables (\textsc{T-Var})
are typed with their types in the environment and 
locations (\textsc{T-Loc})in the store type. New 
expressions (\textsc{T-New}) are typed as a collection 
of declaration types that correspond to their declarations. 
Method calls (\textsc{T-Meth}) are typed as their 
return type provided the arguments 
subtype the method parameter types. Field accesses 
(\textsc{T-Field}) are typed as the field type for the receiver. 
Upcasts (\textsc{T-Type}) are typed as the upcast type if the 
upcast expression appropriately subtypes the upcast type.
\begin{figure}[h]
\hfill \fbox{$A; \Sigma; \Gamma \vdash e:T$}
\begin{mathpar}
\inferrule
  {x \in dom(\Gamma)}
  {	A; \Sigma; \Gamma \vdash x : \Gamma(x)}
  \quad (\textsc {T-Var})
	\and
\inferrule
  {	l \in dom(\Sigma)}
  {	A; \Sigma; \Gamma \vdash l : \Sigma(l)}
  \quad (\textsc {T-Loc})
	\and
\inferrule
  {A; \Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}\} 
  \vdash \overline{d} : \overline{\sigma}}
  {A; \Sigma; \Gamma \vdash \texttt{new} \; \{z \Rightarrow \overline{d}\} : 
  \{z \Rightarrow \overline{\sigma}\}}
  \quad (\textsc {T-New})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash e_0 \ni \texttt{def} \; m:S \rightarrow T \\
  	A; \Sigma; \Gamma \vdash e_0 : T_0 \\
  	A; \Sigma; \Gamma \vdash e_1 : S' \\
  	A; \Sigma; \Gamma \vdash S' <: S}
  {A; 	\Sigma; \Gamma \vdash e_0.m(e_1) : T}
  \quad (\textsc {T-Meth})
	\and
\inferrule
  {	A; \Sigma; \Gamma \vdash e : S \\
  	A; \Sigma; \Gamma \vdash e \ni \texttt{val} \; f:T}
  {	A; \Sigma; \Gamma \vdash e.f : T}
  \quad (\textsc {T-Field})
	\and
\inferrule
  {A; \Sigma; \Gamma \vdash e : S \\
   A; \Sigma; \Gamma \vdash S <: T}
  {A; \Sigma; \Gamma \vdash e \unlhd T : T}
  \quad (\textsc {T-Type})
\end{mathpar}
\caption{Expression Typing}
\label{f:e_typ}
\end{figure}

\subsubsection{Reduction}

Reduction is given in Figure \ref{f:red}. Reduction is new (\textsc{R-New}), method (\textsc{R-meth}), field (\textsc{R-Field}) and context (\textsc{R-Context}) reduction. New expressions are reduced (\textsc{R-New}) once field initializers are reduced to values. Method calls on values with a value type parameter are reduced (\textsc{R-Meth}) using the \emph{Leadsto\textsubscript{m}} judgement. We use the \emph{Leadsto\textsubscript{m}} judgement to extract the method body from the store, and wrap it up in well-formed type layers. Field reduction (\textsc{R-Field}) is performed the same way, using the \emph{Leadsto\textsubscript{f}} judgement. Context reduction (\textsc{R-Context}) is standard.
\begin{figure}[h]
\hfill \fbox{$\mu \; | \; e \; \rightarrow \mu' \; | \; e'$}
\begin{mathpar}
\inferrule
  {l \notin dom(\mu) \\
  	\mu' = \mu, l \mapsto \{\texttt{z} \Rightarrow \overline{d_v}\}}
  {\mu \; | \; \texttt{new} \; \{\texttt{z} \Rightarrow \overline{d_v}\} \; \rightarrow \mu' \; | \; l}
  \quad (\textsc {R-New})
  \and
\inferrule
  {\mu : \Sigma \\
   \mu; \Sigma \vdash v_1 \leadsto_{m(v_2)} e}
  {\mu \; | \; v_1.m(v_2) \;\rightarrow \mu \; | \; e}
  \quad (\textsc {R-Meth})
  \and
\inferrule
  {\mu : \Sigma \\
   \mu; \Sigma \vdash v_1 \leadsto_{f} v_2}
  {\mu \; | \; v_1.f \;\rightarrow \mu \; | \; v_2}
  \quad (\textsc {R-Field})
  \and
\inferrule
  {	\mu \; | \; e \; \rightarrow \; \mu' \; | \; e'}
  {\mu \; | \; E[e] \; \rightarrow \mu' \; | \; E[e']}
  \quad (\textsc {R-Context})
\end{mathpar}
\caption{Reduction}
\label{f:red}
\end{figure}

\chapter{Proving Virtual Types Sound}
Proving type systems containing Virtual Types sound presents some problems. Depending on the type system, these are due to the either the  interplay between \emph{Subtype Transitivity} and \emph{Environment Narrowing} and path dependant types.

\section{Proving Subtype Transitivity and Environment Narrowing}
The main difficulty with constructing a soundness proof for Generic Wyvern proving the subtype transitivity and environment narrowing proofs. These lemmas are given in Figure \ref{f:trans_narrowing}. The property that we would like is subtype transitivity (Theorem \ref{th:trans}), however this relies mutually on the existence of environment narrrowing. To demonstrate this, lets take a naive approach to the Subtype Transitivity proof, by induction on the derivation of $\Sigma; \Gamma \vdash S <: T$. Theorem \ref{th:trans} uses an unpatched subtype relation. this is identical to the subtype relation described in Section \ref{ch:wyvern}, except we replace the \textsc{S-Struct} rule with that in Figure \ref{f:struct_naive}.
\begin{figure}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; \overline{\sigma}_2}
	{\Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
\end{mathpar}
\caption{Unpatched \textsc{S-Struct}}
\label{f:struct_naive}
\end{figure}
\begin{theorem}[Subtype Transitivity]\label{th:trans}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma \vdash S <: T \\
	 \Sigma; \Gamma \vdash T <: U}
	{\Sigma; \Gamma \vdash S <: U}
\end{mathpar}
\end{theorem}
\begin{proof}
By induction on the derivation of $\Sigma; \Gamma \vdash S <: T$.
\begin{case}[S-Struct]
\begin{mathpar}
\inferrule
	{}
	{S = \{z \Rightarrow \overline{\sigma}_1\} \\
	 T = \{z \Rightarrow \overline{\sigma}_2\}}
\end{mathpar}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; \overline{\sigma}_2}
	{\Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
\end{mathpar}
Now, by inversion on the derivation of $\Sigma; \Gamma \vdash T <: U$ we have
\begin{subcase}[S-Struct]
\begin{mathpar}
\inferrule
	{}
	{U = \{z \Rightarrow \overline{\sigma}_3\}}
\end{mathpar}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_2\} \vdash \overline{\sigma}_2 <:\; \overline{\sigma}_3}
	{\Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_2\}\; <:\; \{z \Rightarrow \overline{\sigma}_3\}}
\end{mathpar}
Now we would like to use the induction hypothesis to show that
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; \overline{\sigma}_3}
	{\Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_3\}}
\end{mathpar}
However, clearly this dosn't follow since we have different environments.
\end{subcase}
\end{case}
\end{proof}
So, in order to continue, we need to be able to narrow the environment. This means, without patching the type system, we have to introduce a narrowing theorem. 
\begin{theorem}[Narrowing]\label{th:narrow}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash T <: T' \\
	 \Sigma; \Gamma \vdash S <: U}
	{\Sigma; \Gamma, (x : S) \vdash T <: T'}
\end{mathpar}
\end{theorem}
It turns out that Narrowing (Theorem \ref{th:narrow}) is dependent on Subtype Transitivity (Theorem \ref{th:trans}). It is yet more complex, since subtyping is defined mutually with expansion (Figure \ref{f:exp}), membership (Figure \ref{f:mem}) and expression typing (Figure \ref{f:e_typ}). So the full statement of environment narrowing is 
\begin{theorem}[Narrowing]\label{th:narrow}
\begin{mathpar}
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash T <: T' \\
	 \Sigma; \Gamma \vdash S <: U}
	{\Sigma; \Gamma, (x : S) \vdash T <: T'}
	\and
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash T \prec_z \overline{\sigma}_1 \\
	 \Sigma; \Gamma \vdash S <: U}
	{\exists \overline{\sigma}_2,  \Sigma; \Gamma, (x : S) \vdash T \prec_z \overline{\sigma}_2 \\
	  \Sigma; \Gamma, (x : S) \vdash \overline{\sigma}_2 <: \overline{\sigma}_1}
	\and
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash e \ni \sigma_1 \\
	 \Sigma; \Gamma \vdash S <: U}
	{\exists \sigma_2,  \Sigma; \Gamma, (x : S) \vdash e \ni \sigma_2 \\
	  \Sigma; \Gamma, (x : S) \vdash \sigma_2 <: \sigma_1}
	\and
\inferrule
	{\Sigma; \Gamma, (x : U) \vdash e: T \\
	 \Sigma; \Gamma \vdash S <: U}
	{\exists T',  \Sigma; \Gamma, (x : S) \vdash e : T' \\
	  \Sigma; \Gamma, (x : S) \vdash T' <: T}
\end{mathpar}
\end{theorem}
All of these mutually defined properties create a complex set of proofs. This was our reason for attempting to remove subtype transitivity altogether.





\chapter{Future Work}\label{ch:future}

As part of the development of Generic Wyvern, we simplified the concept of paths in the same way that Amin et. al. \cite{Amin 2014} did. This was due to the complexity of both the path equality and narrowing problems. In the future we hope to expand the notion of paths to include field accesses. We also intend to introduce \emph{Intersection} and \emph{Union} types. 

While the Generic Wyvern type system outlined in the previous section is a good start to a sound type system, there is still some work that needs to be done to achieve my stated goals. In this section I shall cover the topic, and time line and contributions of the final thesis.

\section{Simplification of path resolution at evaluation}
While our current type system appears to be a step toward sound virtual types, it does introduce complexity when attempting to resolve field and method accesses on paths and subsequently construct well-formed expressions at evaluation. this is related to the absence of \emph{Subtype Transitivity}. This added complexity does not help in our goal of creating the easily extensible core type system we want for Wyvern. It also may prove too complex when we attempt to extend paths to include field accesses. For these reasons we hope to simplify the way we deal with the transitivity problem.

\section{Explicit Subtype Transitivity Rule}
One potential solution is to introduce an explicit rule for Subtype Transitivity. This has other

\section{Timeline of PhD}
\begin{itemize}
\item
Develop Type Members Type System with simplified paths
\item
Introduce Path Dependence
\item

\end{itemize}•



\chapter{Conclusion}\label{ch:conclusion}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\backmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\bibliographystyle{ieeetr}
\bibliographystyle{acm}
\bibliography{bibl}


\end{document}
