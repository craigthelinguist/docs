% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 

\documentclass[dvipsnames]{beamer}

\usepackage{mathpartir}
\usepackage{listings}
%\usepackage[dvipsnames]{xcolor}
\usepackage{pgfgantt}

\lstdefinestyle{customlang}{
  language = java,
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\ttfamily\scriptsize,
  otherkeywords={val, def, type, new},
  keywordstyle=\bfseries
%  keywordstyle=\color{blue},
}

%\lstset{%
%    backgroundcolor=\color{yellow!20},%
%    basicstyle=\small\ttfamily,%
%    numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt,%
%    }%

% Add your keywords here, and have this in a separate file
% and include it in your preamble
\lstset{emph={%  
    val, def, type, new%
    },emphstyle={\ttfamily\bf}
}%


%\lstset{%
%    language=[latex]tex,
%    breaklines=true}
    
\newsavebox{\tmExA}    
\newsavebox{\tmExAcont}
\newsavebox{\tmExPreservationA}
\newsavebox{\tmExPreservationB}
\newsavebox{\tmExList}
\newsavebox{\tmExPaths}
\newsavebox{\tmExTrans}
\newsavebox{\tmExWyvern}
\newsavebox{\tpExList}

% There are many different themes available for Beamer. A comprehensive
% list with examples is given here:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
% You can uncomment the themes below if you would like to use a different
% one:
%\usetheme{AnnArbor}
%\usetheme{Antibes}
%\usetheme{Bergen}
%\usetheme{Berkeley}
%\usetheme{Berlin}
%\usetheme{Boadilla}
%\usetheme{boxes}
%\usetheme{CambridgeUS}
%\usetheme{Copenhagen}
%\usetheme{Darmstadt}
%\usetheme{default}
%\usetheme{Frankfurt}
%\usetheme{Goettingen}
%\usetheme{Hannover}
%\usetheme{Ilmenau}
%\usetheme{JuanLesPins}
%\usetheme{Luebeck}
\usetheme{Madrid}
%\usetheme{Malmoe}
%\usetheme{Marburg}
%\usetheme{Montpellier}
%\usetheme{PaloAlto}
%\usetheme{Pittsburgh}
%\usetheme{Rochester}
%\usetheme{Singapore}
%\usetheme{Szeged}
%\usetheme{Warsaw}

\title{Generic Wyvern}

% A subtitle is optional and this may be deleted
\subtitle{PhD Proposal}

\author{Julian Mackay}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute[VUW] % (optional, but mostly needed)
{
%  \inst{1}%
  School of Engineering and Computer Science\\
  Victoria University of Wellington
%  \and
%  \inst{2}%
%  Department of Theoretical Philosophy\\
%  University of Elsewhere
  }
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date{}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

\subject{Theoretical Computer Science}
% This is only inserted into the PDF information catalog. Can be left
% out. 

% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
%\AtBeginSubsection[]
%{
%  \begin{frame}<beamer>{Outline}
%    \tableofcontents[currentsection,currentsubsection]
%  \end{frame}
%}

% Let's get started
\begin{document}


\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Outline}
  \tableofcontents[pausesections]
  % You might wish to add the option [pausesections]
\end{frame}

% Section and subsections will appear in the presentation overview
% and table of contents.
\section{Generic Wyvern}

\subsection{Wyvern}

\begin{frame}{Wyvern}
Wyvern is a new structurally typed object oriented language.
\begin{itemize}
\item
An emphasis on secure web programming.
\item
Developed using a minimal core calculus.
\item
Extensions modelled as syntactic transformations on the core.
\end{itemize}
\end{frame}

\subsection{Generic Programming}

% You can reveal the parts of a slide one at a time
% with the \pause command:

\begin{frame}{Generic Programming}
Developing generic libraries allows programmers to write code for a range of types. A good example is developing generic a \texttt{Collection} library.
\end{frame}

\begin{lrbox}{\tpExList}
\begin{lstlisting}[mathescape, style=customlang]
List <E extends Object> {
   val head : E
   val tail : List<E>
   def add : E $\rightarrow$ E}
\end{lstlisting}
\end{lrbox}

\begin{frame}{Generic Type Parameters}
Using type parameters we can write code that is abstracted over a range of types.
\begin{example}
\usebox{\tpExList}
\end{example}
\end{frame}

\section{Type Members}

\subsection{What are Type members?}

\begin{lrbox}{\tmExList}
\begin{lstlisting}[mathescape, style=customlang]
List = {z $\Rightarrow$ type E = $\top$
             val head : z.E
             val tail : List
             def add : z.E $\rightarrow$ z.E}
\end{lstlisting}
\end{lrbox}

\begin{frame}{Type Members}
Type members are a generic programming language feature.
\begin{example}
\usebox{\tmExList}
\end{example}
\end{frame}

\begin{lrbox}{\tmExA}
\begin{lstlisting}[mathescape, style=customlang]
Graph = {z1 $\Rightarrow$ type E = Edge
               type EdgeList = List{z2 $\Rightarrow$ type E = z1.E 
                                          val tail : EdgeList}
               type VertexList = List{z2 $\Rightarrow$ type E = z1.V
                                            val tail : VertexList}
               type V = Vertex}

Edge = {z $\Rightarrow$ type G = Graph
             type V = Vertex
             val source : V
             val target : V
             val graph : G}
             
Vertex = {z1 $\Rightarrow$ type G = Graph
                type E = Edge
                type EdgeList = List{z2 $\Rightarrow$ type E = z1.E
                                           val tail : EdgeList}
                type T = $\top$
                val edges : EdgeList
                val element : z1.T}
\end{lstlisting}
\end{lrbox}

\begin{lrbox}{\tmExAcont}
\begin{lstlisting}[mathescape, style=customlang]		      
IntegerGraph = Graph{z1 $\Rightarrow$ type E = IntegerEdge
                           type V = IntegerVertex}
		
IntegerEdge = Edge{z $\Rightarrow$ type G = IntegerGraph
                        type V = IntegerVertex}
		
IntegerVertex = Vertex{z1 $\Rightarrow$ type G = IntegerGraph
                             type E = IntegerEdge
                             type T = Integer}
\end{lstlisting}
\end{lrbox}

\begin{frame}{Type Members: Example}
\begin{example}
\usebox{\tmExA}
\end{example}
\end{frame}

\begin{frame}{Type Members: Example Continued}
\begin{example}
\usebox{\tmExAcont}
\end{example}
\end{frame}


\begin{frame}{DOT, $\mu$DOT and Scala}
The most prominent use of type members is Scala. 
\begin{itemize}
\item
We base our calculus on the work of Amin et al. (DOT and $\mu$DOT).
\item
In 2014 they developed a sound calculus for type members using a big-step semantics.
\item
We hope to develop a sound calculus using a small step semantics.
\end{itemize}
\end{frame}

\begin{lrbox}{\tmExWyvern}
\begin{lstlisting}[mathescape, style=customlang]	
List = {z $\Rightarrow$ type E = $\bot$ .. $\top$
             val head : z.E
             val tail : List
             def add : z.E $\rightarrow$ z.E}
\end{lstlisting}
\end{lrbox}

\begin{frame}{Type Members in Wyvern}
Type members in Wyvern is based on those in DOT and $\mu$DOT. 
\begin{itemize}
\item
Type Members are defined using a lower and upper bound.
\item
Type Members are accessed by making type selections on paths (\texttt{p.L}).
\item
We define paths as variables and memory locations.
\end{itemize}
\begin{example}
\usebox{\tmExWyvern}
\end{example}
For a selection type \texttt{p.L} and type \texttt{T}.
\begin{itemize}
\item
\texttt{T} subtypes \texttt{p.L} if it subtypes the lower bound.
\item
\texttt{p.L} subtypes \texttt{T} if the upper bound subtypes \texttt{T}.
\end{itemize}
\end{frame}

\subsection{Developing Sound Type Members}

\begin{frame}{Soundness}
\begin{theorem}[Preservation]
For any well-formed expression and memory pair, if we step forward the result maintains the original well-formed type.
\begin{mathpar}
\inferrule
  {\Sigma; \Gamma \vdash e : T\\
   \mu|e \longrightarrow \mu'|e'\\
   \mu : \Sigma \\
   \mu' : \Sigma'}
  {\Sigma'; \Gamma \vdash e' : T}
\end{mathpar}
\end{theorem}
\begin{theorem}[Progress]
For any well-typed expression, either it is a value (a fully reduced expression), or it can make ``progress''.
\begin{mathpar}
\inferrule
  {\Sigma; \varnothing \vdash e : T \\
   \mu : \Sigma}
  {e = v \vee (\exists \; e' \; \mu': \; \mu|e \longrightarrow \mu'|e' \wedge \mu' \; extends \; \mu)}
\end{mathpar}
\end{theorem}
\end{frame}

\begin{lrbox}{\tmExPreservationA}
\begin{lstlisting}[mathescape, style=customlang]
X = {z $\Rightarrow$ val f : $\top$}
Y = {z $\Rightarrow$ type L : $\top$ .. $\top$}
	  val f : z.L}
A = {z $\Rightarrow$ def meth : X}
...
var a = new A(def meth = {new Y(...)} : X)
a.meth.f
\end{lstlisting}
\end{lrbox}

\begin{frame}{Loss of Preservation}
Type preservation can be lost at runtime. Well-formed expressions can reduce to interim expressions that are ill-formed even if the program result is well-formed.
\begin{block}{ }
\usebox{\tmExPreservationA}
\end{block}
Preservation can also be lost in other ways too.
\begin{itemize}
\item
Loss of Type Expansion
\item
Loss of Well-Formedness
\item
Loss of Path Equality
\end{itemize}
\end{frame}

\subsection{Our Solution}

\begin{lrbox}{\tmExPreservationB}
\begin{lstlisting}[mathescape, style=customlang]
(new Y(...)$\unlhd$ X).f
\end{lstlisting}
\end{lrbox}

\begin{frame}{Avoiding Narrowing}
Problems in developing sound type members in part stem from the ``narrowing'' of expressions at runtime. That is the well-formedness of expressions is lost when they reduce to expressions with more precise types.

To avoid this we introduce a persistent upcast, and maintain the original type after reduction. Our previous example now reduces to this.
\begin{block}{ }
%\begin{center}
\usebox{\tmExPreservationB}
%\end{center}
\end{block}

\end{frame}

\begin{frame}{Avoiding Narrowing Continued}
Reduction isn't the only place narrowing occurs. Narrowing is also required as part of subtyping record types.
\begin{block}{Record Subtyping}
\begin{mathpar}
\inferrule
	{A; \Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; \overline{\sigma}_2}
	{A; \Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
	\quad (\textsc {S-Rec})
\end{mathpar}
\end{block}
We patch the semantics by using our syntactic extension for upcasts.
\begin{block}{Record Subtyping Patched}
\begin{mathpar}
\inferrule
	{A; \Sigma; \Gamma, z : \{z \Rightarrow \overline{\sigma}_1\} \vdash \overline{\sigma}_1 <:\; [z \unlhd \{z \Rightarrow \overline{\sigma}_2\} / z]\overline{\sigma}_2}
	{A; \Sigma; \Gamma \vdash \{z \Rightarrow \overline{\sigma}_1\}\; <:\; \{z \Rightarrow \overline{\sigma}_2\}}
	\quad (\textsc {S-Rec-Patched})
\end{mathpar}
\end{block}
Now subtyping is free of narrowing.
%\begin{example}
%Here is an example of an example block.
%\end{example}
\end{frame}


\begin{lrbox}{\tmExTrans}
\begin{lstlisting}[mathescape, style=customlang]
A = {z $\Rightarrow$ type N : $\bot$ .. $\top$}

B = {z $\Rightarrow$ type N : $\bot$ .. $\top$
          def meth1(x : $\top$){return new{z $\Rightarrow$}}:$\top$}
         
S = {z $\Rightarrow$ type L : A .. $\top$
          val f : A}
         
T = {z $\Rightarrow$ type L : A .. $\top$
          val f : z.L}
         
U = {z $\Rightarrow$ type L : B .. $\top$
          val f : z.L}
\end{lstlisting}
\end{lrbox}

\begin{frame}{Avoiding Transitivity}
Now that we are free of narrowing, it turns out that we have lost subtype transitivity too!
\begin{block}{ }
\usebox{\tmExTrans}
\end{block}
\begin{itemize}
\item
\texttt{S} $<:$ \texttt{T}
\item
\texttt{T} $<:$ \texttt{U}
\item
\texttt{S} $\not<:$ \texttt{U}
\end{itemize}
\end{frame}

\begin{frame}{Avoiding Transitivity Continued}
Again we use our syntactic extension for upcasts to avoid transitivity.
\begin{itemize}
\item
\texttt{s} : \texttt{S}
\item
\texttt{s} $\unlhd$ \texttt{T} $\unlhd$ \texttt{U} : \texttt{U}
\end{itemize}
\end{frame}

% Placing a * after \section means it will not show in the
% outline or table of contents.
\section{Extending Type Members}

\subsection{Path Dependent Types}


\begin{lrbox}{\tmExPaths}
\begin{lstlisting}[mathescape, style=customlang]
val b = new {z $\Rightarrow$ type L : $\top$ .. $\top$
                  val l : z.L = b}
val a = new {z $\Rightarrow$ val i : {z $\Rightarrow$ type L : $\bot$ .. $\top$
                                  val l : z.L} = b
                  def meth : $\top$ (x : z.i.L){x}}
a.meth(a.i.l)
\end{lstlisting}
\end{lrbox}

\begin{frame}{Path Dependent Types}
As a second contribution we hope to extend the definition of paths to field accesses. This presents problems at reduction.
\begin{block}{ }
\usebox{\tmExPaths}
\end{block}
%The above example initially type checks successfully since the parameter type of \texttt{a.meth} is \texttt{a.i.L} which is the exact type of \texttt{a.i.l}. After reduction \texttt{a.i.l} reduces to \texttt{b.l}. While in this case we know that \texttt{a.i} and \texttt{b} point to the same object, in general this is not possible to know.
\begin{itemize}
\item
Initially \texttt{a.meth} types as \texttt{a.i.L} $\rightarrow$ $\top$.
\item
\texttt{a.i.l} has exactly type \texttt{a.i.L}.
\item
\texttt{a.i.l} reduces to \texttt{b.l} which has type \texttt{b.L}.
\item
In general there is no way to determine if \texttt{b} and \texttt{a.i} are the same path.
\item
Type checking fails.
\end{itemize}
\end{frame}

\subsection{Decidable Subtyping}

\begin{frame}{Decidable Subtyping}
\end{frame}

\begin{frame}{Shapes, Materials and F-Bounded Polymorphism}
\end{frame}

\section{In Which we Propose a PhD}

\begin{frame}{In Which we Propose a PhD}
The Portrait of a PhD as a young man.
\begin{itemize}
\item
Sound type members calculus with small step semantics.
\item
Extend type members with complex paths.
\item
Decidable subtyping for type members.
\item
Develop machine checked proofs for soundness using Coq.
\end{itemize}
\end{frame}

\begin{frame}{Threats to Research}
\begin{itemize}
\item
We are developing a type members calculus concurrently with Amin et al.
\item
Our work takes a different approach to theirs.
\item
There is always a possibility we are unable to prove soundness.
\end{itemize}
\end{frame}

\begin{frame}{Timeline}

\begin{figure}
\noindent\resizebox{\textwidth}{!}{
\begin{ganttchart}[
y unit title=0.6cm,
y unit chart=0.8cm,
vgrid,
time slot format=isodate-yearmonth,
compress calendar,
title/.append style={draw=none, fill=RoyalBlue!50!black},
title label font=\sffamily\bfseries\color{white},
title label node/.append style={below=-1.6ex},
title left shift=.05,
title right shift=-.05,
title height=1,
bar/.append style={draw=none, fill=OliveGreen!75},
bar height=.6,
bar label font=\normalsize\color{black},
group right shift=0,
group top shift=.6,
group height=.3,
group peaks height=.2,
bar incomplete/.append style={fill=Maroon}
]{2015-03}{2018-02}
\gantttitlecalendar{year} \\
\ganttset{progress label text={}, link/.style={black, -to}}
\ganttgroup{Type Members}{2015-03}{2016-05} \\
\ganttbar[progress=100, name=T1A, 
bar progress label font=\small\color{OliveGreen!75},
bar progress label node/.append style={right=4pt},
bar label font=\normalsize\color{OliveGreen}]{Develop Type System}{2015-03}{2015-11} \\
\ganttbar[progress=100,
bar label font=\normalsize\color{OliveGreen}]{Proposal}{2015-12}{2016-02} \\
\ganttbar[progress=25]{SPLASH 2016}{2016-03}{2016-03} \\
\ganttbar[progress=0]{Intersection \& Union Types}{2016-04}{2016-05} \\
\ganttgroup{Path Dependent Types}{2016-06}{2016-012} \\
\ganttbar[progress=10]{Path Dependent Types}{2016-06}{2016-012} \\
\ganttgroup{Decidability}{2016-04}{2017-06} \\
\ganttbar[progress=2, name=T2A]{Decidability}{2016-04}{2017-06} \\
%\ganttgroup{Gradual Types}{2017-03}{2017-06} \\
%\ganttbar[progress=0, name=T2A]{Gradual Types}{2017-03}{2017-06} \\
\ganttgroup{Thesis}{2017-07}{2018-02} \\
\ganttbar[progress=0]{Thesis}{2017-07}{2018-02}
\ganttset{link/.style={OliveGreen}}
\end{ganttchart}}
%\caption{Proposed Time line for PhD}
\label{f:gantt}
\end{figure}
\end{frame}

\begin{frame}{The End}
\Huge
\begin{center}
Fin.
\end{center}
\end{frame}


% All of the following is optional and typically not needed. 
%\appendix
%\section<presentation>*{\appendixname}
%\subsection<presentation>*{For Further Reading}
%
%\begin{frame}[allowframebreaks]
%  \frametitle<presentation>{For Further Reading}
%    
%  \begin{thebibliography}{10}
%    
%  \beamertemplatebookbibitems
%  % Start with overview books.
%
%  \bibitem{Author1990}
%    A.~Author.
%    \newblock {\em Handbook of Everything}.
%    \newblock Some Press, 1990.
% 
%    
%  \beamertemplatearticlebibitems
%  % Followed by interesting articles. Keep the list short. 
%
%  \bibitem{Someone2000}
%    S.~Someone.
%    \newblock On this and that.
%    \newblock {\em Journal of This and That}, 2(1):50--100,
%    2000.
%  \end{thebibliography}
%\end{frame}

\end{document}


