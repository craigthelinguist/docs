\documentclass{llncs}

\usepackage{listings}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{color,soul}


\newtheorem{case1}{Case1}
\newtheorem{subcase}{SubCase}
\numberwithin{subcase}{case}
\numberwithin{case}{theorem}
\numberwithin{case}{lemma}




\lstdefinestyle{custom_lang}{
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\ttfamily,
  keywordstyle=\bfseries
}

\lstset{emph={%  
    val, def, type, new, z%
    },emphstyle={\bfseries \tt}%
}

\begin{document}

\section{Type Members Examples}

\subsection{Removing Environment Narrowing}

A central issue in similar type systems thus far is maintaining 
type soundness in the presence of environment narrowing. Our 
proposed solution is to remove environment narrowing altogether.

An environment is narrowed when during reduction a variable is 
found to have a more precise type than originally assumed. This 
is common when passing arguments to a method, or when returning 
from a method call. In fact these are the two areas that environment 
narrowing must be removed. Below is a small example where we attempt to 
remove environment narrowing.
\begin{lstlisting}[mathescape, style=custom_lang]
Food = {z $\Rightarrow$ def eat(){ ... } : {z $\Rightarrow$}}

Recipe = {z $\Rightarrow$ val FoodType : $\bot$ .. Food;
               def cook(){ ... } : z.FoodType;}
\end{lstlisting}

\subsection{Path Equality}


\bibliographystyle{plain}
\bibliography{bib}

\end{document} 
