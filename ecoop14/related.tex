% !TEX root = ecoop14.tex
\section{Related Work}
\label{s:related}

Language macros are the most explored way of extending programming languages, with Scheme and other Lisp-style languages' hygienic macros being the 'gold standard.' In those languages, macros are written in the language itself and benefit from the simple syntax -- parentheses universally serve as expression delimiters (although proposals for whitespace as a substitute for parentheses have been made \cite{srfi-49}). Our work is inspired by this flexibility, but aims to support richer syntax as well as static types. Wyvern's use of types to trigger parsing  avoids the overhead of needing to invoke macros explicitly by name and makes it easier to compose TSLs declaratively.

Another way to approach language extensibility is to go a level of abstraction above parsing as is done via metaprogramming facilities. For instance, OJ (previously, OpenJava)~\cite{Tatsubori00openjava:a} provides a macro system based on a meta-object protocol, and Backstage Java~\cite{Palmer:2011:BJM:2048066.2048137}, Template Haskell \cite{sheard2002template} and others employ compile-time meta-programming.  Each of these systems provide macro-style rewriting of source code, but they provide at most limited extension of language parsing.

Other systems aim at providing forms of syntax extension that change the host language, as opposed to our whitespace-delimited approach.  For example, Camlp4 \cite{camlp4} is a preprocessor for OCaml that offers the developer the ability to extend the concrete syntax of the language via the use of parsers and extensible grammars.  SugarJ \cite{Erdweg:2011:SLL:2048147.2048199} takes a library-centric approach which supports syntactic extension of the Java language by adding libraries. In Wyvern, the core language
is not extended directly, so conflicts cannot arise at link-time.

Scoping TSLs to expressions of a single type comes at the expense of some flexibility, but we believe that many uses of domain-specific languages are of this form already. A previous approach has considered type-based disambiguation of parse forests for supporting quotation and anti-quotation of arbitrary object languages~\cite{bravenboer2005generalized}. Our work is similar in spirit, but does not rely on generation of parse forests and associates grammars with types, rather than types with grammar productions. We believe that this is a more simple and flexible methodology. The remaining approaches to syntax extension, such as XJ~\cite{DBLP:conf/scam/ClarkSW08} are keyword-directed in some form. We believe that a type-directed approach is more seamless and general, sacrificing a small amount of identifiability in some cases.

Domain-specific language frameworks and language workbenches, such as Spoofax \cite{KatsVisser2010}, Ens\={o}~\cite{enso} and others~\cite{krahn2008monticore,van1992pregmatic}, also provide a possible solution for the language extension task. They provide support for generating new programming languages and tooling in a modular manner.  The Marco language \cite{lee:2012:marco} similarly provides macro definition at a level of abstraction that is largely independent of the target language. In these approaches, each TSL is \emph{external} relative to the host language; in contrast, Wyvern focuses on extensibility \emph{internal} to the language, improving interoperability and composability.

In addition, there is an ongoing work on projectional editors (e.g., \cite{mps,Diekmann:2013}) that use special graphical user interface to allow the developer to implicitly mark where the extensions are placed in the code, essential specifying directly the underlying ASTs. This solution to the language extension problem poses several challenges such as defining and implementing the semantics for the composition of the languages and the channels for communication between them. In Wyvern, we do not encounter these problems as the semantic rules for a language composition are incorporated within the host language by design.

In terms of work on safe language compositions, Schwerdfeger and van Wyk~\cite{safecompositionvanwyk} proposed a solution that make strong safety guarantees provided that the languages comply with certain grammar restrictions, concerning first and follow sets of the host language and the added new languages. Our approach does not impose any such restrictions while still making safety guarantees.

There is a relation between recent work on Active Code Completion and our approach in that
the Active Code Completion work associates code completion palettes with types~\cite{omar2012active} as well. Such palettes could be used for defining a TSL syntax for types. However, that syntax
is immediately translated to Java syntax at edit time, while this work
integrates with the core parsing facilities of the language.

Finally, C\# expression trees \cite{Csharp} come the closest to our approach and employ a similar language extension mechanism as we do. The addition of a new language to C\# is type specific; however, only one special type, called \lstinline{Expression}, supports this extension and thus the extensions are fairly limited. Wyvern allows any type to be extensible and therefore this limitation is naturally avoided.



%\begin{itemize}
%\item language boxes work discussed at Parsing workshop~\cite{Diekmann:2013}
%\item Tratt's Converge~\cite{Tratt:2005:CMD:1146841.1146846}
%\end{itemize}
