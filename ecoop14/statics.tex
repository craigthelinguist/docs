% !TEX root = ecoop14.tex
\section{Statics}
\todo{perhaps the figures in approach.tex could be used in this section with the reference to the motivating example (Darya)}

\todo{This section on Statics is going to go and simply be integrated into approach in the right places, right? Right now it is just a list of figures and some text descrbining parts of them, not a coherent section as such, right?}

We present the abstract syntax of our system in Figure \ref{fig:core2-syntax}. A program $\rho$ is composed of a series of object type \keyw{objtype} and sum type \keyw{casetype} declarations, followed by expressions $e$. An object type is made of declarations of values \keyw{val}, methods \keyw{def} and \keyw{metadata}. A sum type is made of an enumeration of cases of the form $C$ \keyw{of} $\tau$, where $C$ is the name of the constructor and $\tau$ is the type of the expression constructed in this case, followed by metadata.

The metadata of a type $t$ (either an \keyw{objtype} or a \keyw{casetype}) can contain arbitrary data, for eg. documentation, but it will necessarily contain a $parser$ field of type $Parser$. The $parser$ field has a $parse$ method that takes as argument a stream of tokens and generates an abstract syntax tree expression. This $parse$ method is used for parsing new TSLs of type $t$ defined by the user. 

We differentiate between expressions that might contain a TSL expression and those that definitely do not contain a TSL expression by superscripting the latter with the symbol $\hat{}$. Thus we have two versions (one without $\hat{}$ and one with $\hat{}$) for programs $\rho$,  expressions $e$, cases $c$ of the sum types, and declarations $d$ of fields and methods. 

An expression can be a variable, a function, an application of a function to an expression, a pair of expressions, a case analysis on pairs, the constructor of a case type, the destructor of a case type, a new expression declaring fields and methods, the invocation $e.x$ of a field or a method. We do not have $e.m$ and $e.f$ in the abstract syntax because the parser cannot differentiate between the two, only the type checker can do that. An expression can also be an expression with a type ascribed to it, the abstract syntax tree of an expression, a metaobject of a type, a TSL literal or an expression obtained from a token stream. Each expression has a corresponding static semantics rule in Figures \ref{fig:statics1} and \ref{fig:statics2}. 

The abstract syntax also presents the definition of types, which can be unary types, arrow types corresponding to functions and product types corresponding to pairs. The context $\Gamma$ contains variables and their types. The context $\Delta$ contains types and their signatures. In $\Delta$ we need to keep track not only of a metadata's type, but we need to carry the actual metadata. This is because in the rule $\textit{T-literal}$ in Figure \ref{fig:statics2} we execute the $parse$ method on $\hat{e}_p$ and for this we need to know what the body of the $parse$ method is.




\begin{figure}
\centering
\[
\begin{array}[t]{lll} 
\rho & \bnfdef & \keyw{objtype}~ t~ \{ \omega, \keyw{metadata}=e \}; \rho \\
     & \bnfalt & \keyw{casetype}~ t~ \{ \chi, \keyw{metadata}=e \}; \rho\\
     & \bnfalt & e
     \\[1ex]
e    & \bnfdef & x \\
     & \bnfalt & \boldsymbol\lambda x{:}\tau . e \\ %
     & \bnfalt & e(e) \\
     & \bnfalt & (e, e) \\
     & \bnfalt & \keyw{case}(e) \{(x, y) \Rightarrow e\}\\
     & \bnfalt & t.C(e) \\
     & \bnfalt & \keyw{case}(e)~\{ c \} \\
     & \bnfalt & \keyw{new}~ \{ d \}\\
     & \bnfalt & e.x \\
     & \bnfalt & e : \tau\\
     & \bnfalt & \keyw{valAST}(e) \\
     & \bnfalt & t.\keyw{metaobject}\\
     & \bnfalt & \lfloor literal \rfloor \\
     & \bnfalt & \keyw{fromTS}[\Gamma](e, e)
\\[1ex]	
c    & \bnfdef & C(x) \Rightarrow e\\
     & \bnfalt & c \bnfalt c
	 \\[1ex]
d   & \bnfdef & \varepsilon \\
     & \bnfalt & \keyw{val}~ f:\tau = e;~d \\
     & \bnfalt & \keyw{def}~ m:\tau = e;~d
\\[1ex] 
\end{array}
\begin{array}[t]{lll}
~~~
\end{array}
\begin{array}[t]{lll}


\hat\rho & \bnfdef & \keyw{objtype}~ t~ \{ \omega, \keyw{metadata}=\hat e \}; \hat\rho \\
     & \bnfalt & \keyw{casetype}~ t~ \{ \chi, \keyw{metadata}=\hat e \}; \hat\rho\\
     & \bnfalt & \hat e
     \\[1ex]
\hat{e}    & \bnfdef & x \\
     & \bnfalt & \boldsymbol\lambda x{:}\tau . \hat{e} \\ %
     & \bnfalt & \hat{e}(\hat{e}) \\
     & \bnfalt & \cdots \\
     & \bnfalt & t.\keyw{metaobject} 
\\[1ex]
\hat c    & \bnfdef & ...
	 \\[1ex]
\hat d   & \bnfdef & ... 
\\[1ex] 
\chi & \bnfdef & C~\keyw{of}~\tau\\
     & \bnfalt & \chi \bnfalt \chi 
\\[1ex]
\omega &\bnfdef & \varepsilon \\  
         & \bnfalt & \keyw{val}~ f:\tau;~\omega\\
         & \bnfalt & \keyw{def}~ m:\tau;~\omega 
\\[1ex]
\tau & \bnfdef & t\\
     & \bnfalt & \tau \rightarrow \tau \\
     & \bnfalt & \tau \times \tau 
\\[1ex]
\Gamma & \bnfdef & \emptyset \bnfalt \Gamma, x:\tau
\\[1ex]
\Delta & \bnfdef & \emptyset \bnfalt \Delta, t:\{\chi, e:\tau\} \bnfalt \Delta, t:\{\omega, e:\tau\}
\\[1ex]

\end{array}
\]
\caption{Abstract Syntax}
\label{fig:core2-syntax}
\end{figure}


\begin{figure}
\centering
\[
\begin{array}{ll}
\keyw{casetype}\ & Exp=\\
& \ \ \ Var\ of\ ID\\
& \bnfalt \ Lam\ of\ ID\ *\ Ty\ *\ Exp\\
& \bnfalt \ App\ of\ Exp\ *\ Exp\\
& \cdots\\
& \bnfalt \ FromTokenStream\ of\ Exp\ *\ Exp\\
& \bnfalt \ Error\\
\\
\keyw{casetype}\ & Ty=\\
& \ \ \ Var\ of\ ID\\
& \bnfalt \ Arrow\ of\ Ty*Ty\\
\\ 
\end{array}
\]
\caption{Syntax Trees of Expressions and Types}
\end{figure}





\begin{figure}
\centering
\[
\begin{array}{c}

\infer[\textit{RT-objtype}]
          {\renewcommand{\arraystretch}{1}
	    \begin{array}{r}
	    \Delta; \Gamma \vdash  \keyw{objtype}~ t~=\{{\omega}, \keyw{metaobject}=e\}; \rho: \tau'\leadsto\\
            \keyw{objtype}~ t~=\{{\omega}, \keyw{metaobject}=\hat{e}\}; \hat{\rho}
            \end{array}
       }
	  {\Delta \vdash \omega & \Delta; \Gamma \vdash e \Rightarrow \tau \leadsto \hat{e} & \Delta, t:\{\omega, \hat e:\tau\}; \Gamma \vdash \rho :\tau'\leadsto \hat{\rho} }
	   \\[3ex] 


\infer[\textit{RT-casetype}]
          {\renewcommand{\arraystretch}{1}
	    \begin{array}{r}
	    \Delta; \Gamma \vdash  \keyw{casetype}~ t~=\{\chi, \keyw{metaobject}=e\}; \rho :\tau' \leadsto \\
            \keyw{casetype}~ t~=\{\chi, \keyw{metaobject}=\hat{e}\};\hat{\rho}
            \end{array}
       }
	  {\Delta \vdash \chi & \Delta; \Gamma \vdash e \Rightarrow \tau \leadsto \hat{e} & \Delta, t:\{\chi, \hat e:\tau\}; \Gamma \vdash \rho :\tau'\leadsto \hat{\rho} }
	   \\[3ex] 


\infer[\textit{RT-e}]
	{\Delta; \Gamma \vdash  e:\tau \leadsto \hat{e}} 
	{\Delta; \Gamma \vdash e \Rightarrow \tau \leadsto \hat{e}}\\[3ex]

\infer[\textit{C-decl}]
	{\Delta; \Gamma \vdash  C~\keyw{of}~\tau} 
	{\Delta \vdash \tau   }\\[3ex]

\infer[\textit{C-decls}]
	{\Delta; \Gamma \vdash  \chi_1 \bnfalt \chi_2} 
	{\Delta; \Gamma \vdash \chi_1 & \Delta; \Gamma \vdash \chi_2 & \text{dom}(\chi_1) \intersect \text{dom}(\chi_2) = \emptyset}\\[3ex]

\infer[\textit{O-val}]
	{\Delta; \Gamma \vdash \keyw{val}~ f:\tau \ \texttt{ok} }
	{\Delta \vdash \tau} \\[3ex]
	
\infer[\textit{O-def}]
	{\Delta; \Gamma \vdash \keyw{def}~ m:\tau \ \texttt{ok} }
	{\Delta \vdash \tau } \\[3ex]

\infer[\textit{O-defs}]
	{\Delta; \Gamma \vdash \omega_1\ \omega_2  }
	{\Delta \vdash \omega_1 & \Delta \vdash \omega_2 & \text{dom}(\omega_1) \intersect \text{dom}(\omega_2) = \emptyset } \\[3ex]

\infer[\textit{Syn2Check}]
	{\Delta; \Gamma \vdash  e \Leftarrow \tau \leadsto \hat{e}} 
	{\Delta;\Gamma \vdash e \Rightarrow \tau \leadsto \hat{e}   }\\[3ex]
	
\infer[\textit{T-varx}]
	{\Delta,\Gamma \vdash x\Rightarrow\tau } 
	{x:\tau \in \Gamma }\\[3ex]

\infer[\textit{T-abs}]
	{\Delta; \Gamma \vdash  \boldsymbol\lambda x{:}\tau . e \Leftarrow \tau \rightarrow \tau_1 \leadsto \boldsymbol\lambda x{:}\tau .\hat{e}} 
	{\Delta; \Gamma, x:\tau \vdash e\Leftarrow \tau_1 \leadsto \hat{e}  & \Delta\vdash \tau}\\[3ex]

\infer[\textit{T-appl}]
	{\Delta; \Gamma \vdash  e(e_1) \Rightarrow \tau_2  \leadsto \hat{e}(\hat{e}_1) } 
	{\Delta; \Gamma \vdash e \Rightarrow \tau_1 \rightarrow \tau_2  \leadsto \hat{e}  & \Gamma \vdash e_1 \Leftarrow \tau_1 \leadsto \hat{e}_1 }\\[3ex]

\infer[\textit{T-introcase}]
	{\Delta; \Gamma \vdash  t.C(e) \Rightarrow t  \leadsto t.C(\hat{e}) } 
	{t:\{\chi, e_0:\tau\} \in \Delta & C\ \keyw{of}\ \tau' \in \chi &\Delta; \Gamma \vdash e \Leftarrow \tau'  \leadsto \hat{e}}\\[3ex]

\infer[\textit{T-elimcase}]
	{\Delta; \Gamma \vdash  \keyw{case}~(e)~\{ c \} \Rightarrow \tau'  \leadsto \keyw{case}~(\hat{e})~\{ c \} } 
	{\Delta; \Gamma \vdash e \Rightarrow t  \leadsto \hat{e}  & t:\{ \chi,e_0:\tau\} \in \Delta & c:\chi \Rightarrow \tau'}\\[3ex]

\infer[\textit{T-casehelper1}]
	{\Delta; \Gamma \vdash  C(\chi)\Rightarrow e : C\ \keyw{of}\ \tau \Rightarrow \tau' \leadsto C(\chi)\Rightarrow \hat{e} : C\ \keyw{of}\ \tau} 
	{\Delta; \Gamma, x:\tau \vdash e \Rightarrow \tau' \leadsto \hat{e}}\\[3ex]

\infer[\textit{T-casehelper2}]
	{\Delta; \Gamma \vdash  c_1 \bnfalt c_2: \chi_1 \bnfalt \chi_2 \Rightarrow \tau' } 
	{\Delta; \Gamma \vdash c_1:\chi_1 \Rightarrow \tau' & \Delta; \Gamma \vdash c_2:\chi_2 \Rightarrow \tau'}\\[3ex]


\end{array}
\]
\label{fig:statics1}
\caption{Static Semantics Rules}
\end{figure}

\begin{figure}
\centering
\[
\begin{array}{c}

\infer[\textit{T-new}]
	{\Delta; \Gamma \vdash \keyw{new}\ \{ d \} \Leftarrow  t \leadsto \keyw{new}\ \{\hat d\}}
	{ t:\{\omega, \hat e:\tau\} \in \Delta & \Delta;\Gamma \vdash d \Leftarrow \omega \leadsto \hat d & t\neq TokenStream} \\[3ex]

\infer[\textit{DT-val}]
	{\Delta; \Gamma \vdash \keyw{val}~ f:\tau = e \Leftarrow \keyw{val}~ f:\tau  \leadsto \keyw{val}~ f:\tau = \hat{e}}
	{\Delta \vdash \tau &\Delta; \Gamma \vdash e \Leftarrow \tau \leadsto \hat{e} } \\[3ex]
	
\infer[\textit{DT-def}]
	{\Delta; \Gamma \vdash \keyw{def}~ m:\tau = e \Leftarrow \keyw{def}~ m:\tau \leadsto \keyw{def}~ m:\tau = \hat{e} }
	{\Delta \vdash \tau  & \Delta; \Gamma \vdash e  \Leftarrow \tau \leadsto \hat{e} } \\[3ex]

	
\infer[\textit{DT-defs}]
	{\Delta; \Gamma \vdash d_1\ d_2 \Leftarrow \omega_1\ \omega_2 }
	{\Delta; \Gamma \vdash d_1 \Leftarrow \omega_1 &  \Delta; \Gamma \vdash d_2 \Leftarrow \omega_2 } \\[3ex]


\infer[\textit{T-field}]
	{\Delta; \Gamma \vdash  e.f \Rightarrow \tau' \leadsto \hat{e}.f} 
	{\Delta; \Gamma \vdash e \Rightarrow t \leadsto \hat{e} & t:\{\omega, e_0:\tau\}\in \Delta & \keyw{val}\ f:\tau' \in \omega  }\\[3ex]

 
\infer[\textit{T-def }]
	{\Delta; \Gamma \vdash  e.m \Rightarrow \tau' \leadsto \hat{e}.m} 
	{\Delta; \Gamma \vdash e \Rightarrow t \leadsto \hat{e} & t: \{\omega, e_0:\tau\} \in \Delta & \keyw{def}\ m:\tau' \in \omega }\\[3ex]

\infer[\textit{T-ascribe}]
	{\Delta; \Gamma  \vdash  e:\tau \Rightarrow \tau \leadsto \hat{e}:\tau}
	{\Delta \vdash \tau & \Delta; \Gamma \vdash e \Leftarrow \tau \leadsto \hat{e} } \\[3ex]

\infer[\textit{T-valAST}]
        {\Delta; \Gamma \vdash \keyw{valAST}(e) \Rightarrow Exp \leadsto \keyw{valAST}(\hat{e}) }
	{\Delta; \Gamma \vdash e \Rightarrow \tau \leadsto \hat{e}} \\[3ex]

\infer[\textit{T-metaobject}]
        {\Delta; \Gamma \vdash t.\keyw{metaobject} \Rightarrow \tau   }
	{t:\{\_, e_0:\tau\} \in \Delta} \\[3ex]


\infer[\textit{T-fromTS}]
	  {\Delta; \Gamma' \vdash \keyw{fromTS}[\Gamma](e_1,e_2) \Leftarrow \tau \leadsto \hat{e} }
	  {\renewcommand{\arraystretch}{1}
	    \begin{array}{r}
	    \Delta;\Gamma' \vdash e_1:TokenStream ~~~~~~ \Delta;\Gamma' \vdash e_2:Token\\
            \texttt{parseConcrete(}e_1,e_2\texttt{)}\ \texttt{is}\ e ~~~~~~\Delta; \Gamma', \Gamma \vdash e \Leftarrow \tau \leadsto \hat{e}
            \end{array}
       } \\[3ex]  

\infer[\textit{T-literal}]
	  {\Delta; \Gamma \vdash \lfloor literal \rfloor \Leftarrow t \leadsto \hat{e} }
	  {\renewcommand{\arraystretch}{1}
	    \begin{array}{r}
	    \Delta;\Gamma \vdash t.\keyw{metaobject}.parser\Leftarrow Parser \leadsto \hat{e}_p ~~~~~ \texttt{TokenStream(}\lfloor literal \rfloor \texttt{)}\ \texttt{is}\ \hat{e}_{ts}\\
            \hat{e}_p.parse(\hat{e}_{ts}, Token.EOS(())) \Downarrow_{\Delta} (\hat{e}', \hat e_{ts}') ~~~~~  e \triangleleft_\Gamma \hat{e}'~~~~~ \Delta;\Gamma\vdash e\Leftarrow t \leadsto \hat{e} ~~~~~ \hat e_{ts}'\ \texttt{empty}
            \end{array}
       } \\[3ex]   
\end{array}
\]
\label{fig:statics2}
\caption{Static Semantics Rules 2}
\end{figure}

\begin{figure}
\centering
\[
\begin{array}{c}

\infer[\textit{Dyn-Meta}]
	{t.\keyw{metaobject} \xmapsto[\Delta]{} e} 
	{t:\{\_,e:\tau \} \in \Delta}\\[3ex]

\infer[\textit{Dyn-valAST1}]
	{\keyw{valAST}(\hat{e}) \xmapsto[\Delta]{} \keyw{valAST}(\hat{e}') } 
	{\hat{e} \xmapsto[\Delta]{} \hat{e}'}\\[3ex]

\infer[\textit{Dyn-valAST2}]
	{\keyw{valAST}(\hat{e}) \xmapsto[\Delta]{} \hat{e}' } 
	{\hat{e}\ \text{val} &\hat{e} \triangleright \hat{e}' }\\[3ex]




\end{array}
\]
\caption{Dynamic Semantics Rules}
\end{figure}




\begin{figure}
\centering
\begin{minipage}{.5\textwidth}
  \centering
   \[
\begin{array}{c}

\infer[\textit{DExp-Var}]
	{ x \triangleleft Exp.Var(\hat{e})   }
	{ ID(x)\ \text{is}\ \hat{e}} \\[3ex]

\infer[\textit{DExp-Lam}]
	{ \boldsymbol\lambda x{:}\tau . e'_1 \triangleleft Exp.Lam( \hat{e}, \tau, \hat{e}_1 )  }
	{ID(x)\ \text{is}\ \hat{e} & e'_1 \triangleleft \hat{e}_1  } \\[3ex]

\infer[\textit{DExp-App}]
	{ e'_1(e'_2)  \triangleleft Exp.App(\hat{e}_1,\hat{e}_2) }
	{ e'_1 \triangleleft \hat{e}_1  & e'_2 \triangleleft \hat{e}_2   } \\[3ex]

\infer[\textit{DExp-Literal}]
	{ \lfloor literal \rfloor \triangleleft Exp.Literal( \hat{e}_{ts} )  }
	{ \text{literal of}\ \hat{e}_{ts}\ \text{is}\ \lfloor literal \rfloor  } \\[3ex]

\infer[\textit{DTy-Var}]
	{ t \triangleleft Ty.Var(\hat{e})   }
	{ ID(t)\ \text{is}\ \hat{e}} \\[3ex]

\infer[\textit{DTy-Arrow}]
	{ \tau_1 \rightarrow \tau_2 \triangleleft Ty.Arrow(\hat{e}_1,\hat{e}_2 )  }
	{ \tau_1 \triangleleft \hat{e}_1 & \tau_2 \triangleleft \hat{e}_2 } \\[3ex]
   
\end{array}
\]
\caption{Dereification Rules}
\end{minipage}%
\vline
\begin{minipage}{.5\textwidth}
  \centering
  \[
\begin{array}{c}
\infer[\textit{RExp-Var}]
	{ x \triangleright Exp.Var(\hat{e})   }
	{ ID(x)\ \text{is}\ \hat{e}} \\[3ex]

\infer[\textit{RExp-Lam}]
	{ \boldsymbol\lambda x{:}\tau . \hat{e}'_1 \triangleright Exp.Lam( \hat{e}, \tau, \hat{e}_1 )  }
	{ID(x)\ \text{is}\ \hat{e} & \hat{e}'_1 \triangleright \hat{e}_1  } \\[3ex]

\infer[\textit{RExp-App}]
	{ \hat{e}'_1(\hat{e}'_2)  \triangleright Exp.App(\hat{e_1},\hat{e}_2) }
	{ \hat{e}'_1 \triangleright \hat{e}_1  & \hat{e}'_2 \triangleright \hat{e}_2   } \\[3ex]

\infer[\textit{RExp-Literal}]
	{ \lfloor literal \rfloor \triangleright Exp.Literal( \hat{e}_{ts} )  }
	{ \text{literal of}\ \hat{e}_{ts}\ \text{is}\ \lfloor literal \rfloor  } \\[3ex]

\infer[\textit{RTy-Var}]
	{ t \triangleright Ty.Var(\hat{e})   }
	{ ID(t)\ \text{is}\ \hat{e}} \\[3ex]

\infer[\textit{RTy-Arrow}]
	{ \tau_1 \rightarrow \tau_2 \triangleright Ty.Arrow(\hat{e}_1,\hat{e}_2 )  }
	{ \tau_1 \triangleright \hat{e}_1 & \tau_2 \triangleright \hat{e}_2 } \\[3ex]
   
\end{array}
\]
\caption{Reification Rules}
\end{minipage}
\end{figure}


\begin{figure}
\centering
\[
\infer[\textit{T-new-hat}]
	{\Delta; \Gamma \vdash \keyw{new}\ \{ \hat d \} :  t }
	{ t:\{\omega, \hat e:\tau\} \in \Delta & \Delta;\Gamma \vdash \hat d : \omega}
\]
\caption{Statics for $\hat e$}
\end{figure}

The judgement 

\fbox{$\Delta; \Gamma \vdash e\Rightarrow \tau \leadsto \hat{e}$} 
\\
\noindent
means that from the type context $\Delta$ and the variable context $\Gamma$ we synthesize the type $\tau$ for $e$. The  expression $e$ possibly containing $\lfloor literal \rfloor$ forms is transformed into the expression $\hat{e}$ without literals.

The judgement 

\fbox{$\Delta; \Gamma \vdash e \Leftarrow \tau \leadsto \hat{e}$} 

means that we check $e$ against the type $\tau$ and the expression $e$ is transformed into the expression $\hat{e}$. 

The rule \textit{RT-objtype} checks that the declaration of the object type $t$ is well-formed and the type of the expression $e$ is the same as the type of $t$'s metaobject.

The rule \textit{RT-casetype} checks that the declaration of the sum type $t$ is well-formed and the type of the expression $e$ is the same as the type of $t$'s metaobject.

The rule \textit{RT-e} is the corresponding static rule for the third case of the program $\rho$ of the abstract syntax.

The rule \textit{C-decl} checks that the type $\tau$ that is referenced by the name $C$ belongs to the type context $\Delta$.

The rule \textit{C-decls} allows a case type to have multiple cases, where each case will be checked by the rule \textit{C-decl}. We have to make sure that there are no two cases with the same names; we do this by checking that the domains of the $\chi$s are disjoint.

The rule \textit{O-val} checks that the type of a field ($\keyw{val}$) belongs to the type context $\Delta$ and thus makes the declaration of a value well-formed (\texttt{ok}).

The rule \textit{O-def} checks that the type of a method ($\keyw{def}$) belongs to the type context $\Delta$ and thus makes the declaration of a method well-formed (\texttt{ok}).

The rule \textit{O-defs} allows multiple declarations of values $val$ and methods $def$ to appear one after the other. Each declaration will either be checked by the rule \textit{O-val} or \textit{O-def}. We have to make sure that there are no two values or methods with the same name; we do this by checking that the domains of the $\omega$s are disjoint.

The \textit{Syn2Check} rule mediates between synthesis and type checking. This rule states that syntesis is more powerful than type checking.

The rule \textit{T-varx} synthesizes the type of the variable $x$ to be $\tau$, after checking that the variable context $\Gamma$ contains the $x:\tau$ declaration. 

The rule \textit{T-abs} checks the type of the lambda abstraction and states what are the conditions for the type checking to go through.

The rule \textit{T-appl} synthesizes the type of the application of one expression to the other and states what are the premises needed for this synthesis to happen.

The rule \textit{T-introcase} introduces the way a case of the sum type should be used and the type of the resulting expression. To make it simpler, we precede the name of the case by the sum type that includes that case.

The rules \textit{T-elimcase} synthesizes the type of the resulting expression of a particular case of a sum type. Note that all the cases of the same sum type should synthesize to the same type. The rules  \textit{T-casehelper1} and \textit{T-casehelper2} help with the type checking of $c:\chi \Rightarrow \tau'$ in the rule \textit{T-elimcase}. Rule \textit{T-casehelper1} is used when $c$ is of the kind (matches) $C(\chi)\Rightarrow e$ , while rule \textit{T-casehelper2} is used when $c$ is of the kind $c_1 \bnfalt c_2$.

The rule \textit{T-new} checks the type of a \keyw{new} expression. 

The rule \textit{DT-val} checks the type of a value that is instatiated to the expression $e$.

The rule \textit{DT-def} checks the type of a method \keyw{def} that is instantiated to the expression $e$.

The rule \textit{DT-defs} allows for multiple instatiations of values or methods to take place one after the other. Each instantiation is checked with the rule \textit{DT-val} or \textit{DT-def}.

The rule \textit{T-field} synthesizes the type of the field of an expression. The premise mentions that the field is declared as a value .

The rule \textit{T-def}  synthesizes the type of the method (\keyw{def}) of an expression. 

The rule \textit{T-ascribe} ascribes (attributes) the type $\tau$ to $e$, after checking in the premise of the rule that the type of $e$ is $\tau$.

The rule \textit{T-valAST}

The rule \textit{T-metaobject} synthesizes the type of the \keyw{metaobject} of the type $t$ by checking that $t$ is in the type context $\Delta$ and it has the right type.

The rule \textit{T-fromTS}

The rule \textit{T-literal} is a crucial rule of the our system. The conclusion checks that the $\lfloor literal \rfloor$ expression has the type $t$ and that it is translated to the expression $e$ that does not contain a $\lfloor literal \rfloor$ expression. The premise checks that the $parser$ method of the \keyw{metaobject} of the $t$ type is of type $Parser$. Instead of using $t.\keyw{metaobject}.parser$ we use $e_p$ in the rest of the rule. The premise continues by denoting the token stream of the $\lfloor literal \rfloor$ expression by $e_{ts}$. When the token stream is parsed, it evaluates to $Exp.C(e')$, which is an expression that does not contain a $\lfloor literal \rfloor$ expression. Note that only expressions with a hat $\hat{}$ contain a $\lfloor literal \rfloor$ expression. The expression $Exp.C(e')$ is then translated to the expression $\hat{e'}$, which in turn is recursively translated to the $e$ expression, which does not contain a $\lfloor literal \rfloor$. This rule might not terminate in the general case, but we prove that it terminates in the ways that we use it.














