% !TEX root = ecoop14.tex
%\section{Statics}
%\todo{perhaps the figures in approach.tex could be used in this section with the reference to the motivating example (Darya)}

%\todo{This section on Statics is going to go and simply be integrated into approach in the right places, right? Right now it is just a list of figures and some text descrbining parts of them, not a coherent section as such, right?}

\begin{figure}[t]
$\fbox{$\vdash_\Sigma \rho \leadsto i$}$
%
\[
\begin{array}{c}
\infer[\textit{P-CT}]
          {%\renewcommand{\arraystretch}{1}
	    %\begin{array}{c}
	    \vdash_\Sigma \keyw{casetype}~ t~\{\chi, \keyw{metadata}=e\}; \rho \leadsto i
            %\end{array}
       }
	  {t \notin \text{dom}(\Sigma) & 
	  \vdash_{\Sigma, t\,\{\chi, -\}} \chi &
	  \emptyset \vdash_{\Sigma, t\,\{\chi,-\}} e \leadsto i' \Rightarrow \tau 
	   & \vdash_{ \Sigma, t\,\{\chi, i' : \tau\}} \rho \leadsto i}
	   \\[3ex] 
	   
\infer[\textit{P-OT}]
          {%\renewcommand{\arraystretch}{1}
	    %\begin{array}{c}
	    \vdash_\Sigma  \keyw{objtype}~ t~\{{\omega}, \keyw{metadata}=e\}; \rho \leadsto%\\
           i
           % \end{array}
       }
	  {t \notin \text{dom}(\Sigma) &
	  \vdash_{\Sigma, t\,\{\omega, -\}} \omega &
	   \emptyset \vdash_{\Sigma, t\,\{\omega,-\}} e \leadsto i' \Rightarrow \tau &  \vdash_{\Sigma, t\,\{\omega, i':\tau\}} \rho \leadsto i }
	   \\[3ex] 
\infer[\textit{P-E}]
	{\vdash_\Sigma  e \leadsto i} 
	{\emptyset \vdash_\Sigma e \leadsto i \Rightarrow \tau}
\end{array}
\vspace{-20px}
\]
$\fbox{$\vdash_\Sigma \chi$}$
\[
\begin{array}{c}
\infer[\textit{C-decl}]
	{\vdash_\Sigma  C~\keyw{of}~\tau} 
	{\vdash_\Sigma \tau   }
~~~~~~
\infer[\textit{C-decls}]
	{\vdash_\Sigma  \chi_1 \bnfalt \chi_2} 
	{\vdash_\Sigma \chi_1 & \vdash_\Sigma \chi_2 & \text{dom}(\chi_1) \intersect \text{dom}(\chi_2) = \emptyset}\\[3ex]
\end{array}
\vspace{-10px}
\]
$\fbox{$\vdash_\Sigma \omega$}$
\[
\begin{array}{c}
\infer[\textit{O-v}]
	{\vdash_\Sigma \keyw{val}~ f:\tau; \omega }
	{\vdash_\Sigma \tau & f \notin \omega & \vdash_\Sigma \omega }
~~~~~~	
\infer[\textit{O-d}]
	{\vdash_\Sigma \keyw{def}~ m(\tau_1)\rightarrow\tau_2; \omega }
	{\vdash_\Sigma \tau_1 & \vdash_\Sigma \tau_2 & m \notin \omega & \vdash_\Sigma \omega }
~~~~~~
\infer[\textit{O-e}]
	{\vdash_\Sigma \epsilon}
	{ }
\end{array}
\]
\vspace{-15px}
\caption{Statics for programs, $\rho$.}
\vspace{-15px}
\end{figure}
\begin{figure}
\vspace{-10px}
$\fbox{$\Gamma \vdash_\Sigma e \leadsto i \Leftarrow \tau$}$~
$\fbox{$\Gamma \vdash_\Sigma e \leadsto i \Rightarrow \tau$}$
\[
\begin{array}{c}
\infer[\textit{T-syn-to-ana}]
	{\Gamma \vdash_\Sigma  e \leadsto i\Leftarrow \tau } 
	{\Gamma \vdash_\Sigma e  \leadsto i\Rightarrow \tau  }
~~~~~~
\infer[\textit{T-asc}]
	{\Gamma  \vdash_\Sigma e:\tau \leadsto i \Rightarrow \tau}
	{\vdash_\Sigma \tau & \Gamma \vdash_\Sigma e \Leftarrow \tau \leadsto i } \\[3ex]

\infer[\textit{T-var}]
	{\Gamma \vdash_\Sigma x \leadsto x \Rightarrow\tau } 
	{x:\tau \in \Gamma }
~~~~~~
\infer[\textit{T-abs}]
	{\Gamma \vdash_\Sigma  \boldsymbol\lambda x . e \leadsto \boldsymbol\lambda x .i \Leftarrow \tau_1 \rightarrow \tau_2 } 
	{\Gamma, x:\tau_1 \vdash_\Sigma e\leadsto i\Leftarrow \tau_2 }\\[3ex]

\infer[\textit{T-ap}]
	{\Gamma \vdash_\Sigma  e_1(e_2) \leadsto i_1(i_2) \Rightarrow \tau_2  } 
	{\Gamma \vdash_\Sigma e_1 \leadsto i_1 \Rightarrow \tau_1 \rightarrow \tau_2    & \Gamma \vdash_\Sigma e_2  \leadsto i_2 \Leftarrow \tau_1}\\[3ex]

\infer[\textit{T-case-intro}]
	{\Gamma \vdash_\Sigma  C(e) \leadsto C(i) \Leftarrow t} 
	{t\,\{\chi, \_\} \in \Sigma & C\ \keyw{of}\ \tau \in \chi &\Gamma \vdash_\Sigma e \leadsto i \Leftarrow \tau }\\[3ex]

\infer[\textit{T-case-elim}]
	{\Gamma \vdash_\Sigma  \keyw{case}(e)~\{ c \}   \leadsto \keyw{case}(i)~\{ \dot{c} \} \Rightarrow \tau} 
	{\Gamma \vdash_\Sigma e   \leadsto i \Rightarrow t & t\,\{ \chi,\_\} \in \Sigma & \Gamma \vdash_\Sigma c \leadsto \dot{c} \Leftarrow \chi \Rightarrow \tau}\\[3ex]
	
\infer[\textit{T-prod-intro}]
	{\Gamma \vdash_\Sigma (e_1, e_2)  \leadsto (i_1, i_2) \Leftarrow \tau_1 \times \tau_2}
	{\Gamma \vdash_\Sigma e_1 \leadsto i_1 \Leftarrow \tau_1 & 
	 \Gamma \vdash_\Sigma e_2  \leadsto i_2 \Leftarrow \tau_2}
	 \\[3ex]
\infer[\textit{T-prod-elim}]
	{\Gamma \vdash_\Sigma \keyw{case}(e)~\{ (x, y) \Rightarrow e' \} \leadsto \keyw{case}(i)~\{ (x, y) \Rightarrow i' \} \Rightarrow \tau}
	{\Gamma \vdash_\Sigma e \leadsto i \Rightarrow \tau_1 \times \tau_2& 
	 \Gamma, x : \tau_1, y : \tau_2 \vdash_\Sigma e' \leadsto i' \Rightarrow \tau}
	\\[3ex]
\infer[\textit{T-obj-intro}]
	{\Gamma \vdash_\Sigma \keyw{new}\ \{ d \}  \leadsto \keyw{new}\ \{\dot d\} \Leftarrow  t}
	{ t\neq ParseStream & t\,\{\omega, \_\} \in \Sigma & \Gamma \vdash_\Sigma^t d \leadsto \dot d \Leftarrow \omega} \\[3ex]
\infer[\textit{T-field}]
	{\Gamma \vdash_\Sigma  e.f \leadsto i.f \Rightarrow \tau} 
	{\Gamma \vdash_\Sigma e \leadsto i \Rightarrow t & t\,\{\omega, \_\}\in \Sigma & \keyw{val}\ f:\tau \in \omega  }\\[3ex]

\infer[\textit{T-meth}]
	{\Gamma \vdash_\Sigma  e_1.m(e_2) \leadsto i_1.m(i_2) \Rightarrow \tau_2} 
	{\Gamma \vdash_\Sigma e_1 \leadsto i_1 \Rightarrow t & t\,\{\omega, \_\} \in \Sigma & \keyw{def}\ m(\tau_1) \rightarrow \tau_2 \in \omega & \Gamma \vdash_\Sigma e_2 \leadsto i_2 \Leftarrow \tau_1}
\end{array}
\]
$\fbox{$\Gamma \vdash_\Sigma c \leadsto \dot{c} \Leftarrow \chi \Rightarrow \tau$}$
\[
\begin{array}{c}
\infer[\textit{T-case}]
	{\Gamma \vdash_\Sigma  C(x)\Rightarrow e  \leadsto C(x)\Rightarrow i \Leftarrow C\ \keyw{of}\ \tau_1 \Rightarrow \tau_2} 
	{\Gamma, x:\tau_1 \vdash_\Sigma e \leadsto i \Rightarrow \tau_2}\\[3ex]

\infer[\textit{T-cases}]
	{\Gamma \vdash_\Sigma c_1 \bnfalt c_2 \leadsto \dot{c}_1 \bnfalt \dot{c}_2 \Leftarrow \chi_1 \bnfalt \chi_2 \Rightarrow \tau  } 
	{\Gamma \vdash_\Sigma c_1 \leadsto \dot{c_1} \Leftarrow \chi_1 \Rightarrow \tau & \Gamma \vdash_\Sigma c_2 \leadsto \dot{c_2} \Leftarrow \chi_2 \Rightarrow \tau}
\end{array}
\]
$\fbox{$\Gamma \vdash_\Sigma^t d \leadsto \dot d \Leftarrow \omega$}$
\[
\begin{array}{c}
\infer[\textit{T-emp}]
	{\Gamma \vdash_\Sigma^t \epsilon  \leadsto \epsilon \Leftarrow \epsilon}
	{ }
~~~~~~
\infer[\textit{T-val}]
	{\Gamma \vdash_\Sigma^t \keyw{val}~ f = e; d \leadsto \keyw{val}~ f = i; \dot{d}\Leftarrow \keyw{val}~ f : \tau; \omega }
	{\Gamma \vdash_\Sigma e \leadsto i \Leftarrow \tau & \Gamma \vdash_\Sigma^t d \leadsto \dot{d} \Leftarrow \omega} \\[3ex]
	
\infer[\textit{T-def}]
	{\Gamma \vdash_\Sigma^t \keyw{def}~ m(x) = e; d  \leadsto \keyw{def}~ m(x) = i; \dot{d} \Leftarrow \keyw{def}~ m(\tau_1)\rightarrow\tau_2; \omega}
	{\Gamma, this : t, x : \tau_1 \vdash_\Sigma e\leadsto i  \Leftarrow \tau_2  & \Gamma \vdash_\Sigma^t d  \leadsto \dot{d} \Leftarrow \omega}
\end{array}
\]
\label{fig:statics1}
\vspace{-10px}
\caption{Statics for $e$ (continued below)}
\end{figure}
\begin{figure}
\centering
\[
\footnotesize
\begin{array}{c}
\infer[\textit{T-lift}]
        {\Gamma \vdash_\Sigma \keyw{lift}(e) \leadsto \keyw{lift}(i) \Rightarrow Exp}
	{\Sigma_0 \subset \Sigma & \Gamma \vdash_\Sigma e \leadsto i \Rightarrow \tau } \\[3ex]

\infer[\textit{T-metadata}]
        {\Gamma \vdash_\Sigma \keyw{metadata}[t]  \leadsto \keyw{metadata}[t]  \Rightarrow \tau}
	{t\,\{\_, i:\tau\} \in \Sigma} \\[3ex]

\infer[\textit{T-lit}]
	  {\Gamma \vdash_\Sigma \keyw{lit}[body] \leadsto i \Leftarrow t}
	  {\begin{array}{c}
	   \Sigma_0 \subset \Sigma ~~~~
	   t \{\_, i : HasTSL\} \in \Sigma ~~~~
	   \texttt{parsestream(}body\texttt{)=}i_{ps} \\
	   i.parser.parse(i_{ps}) \Downarrow_\Sigma (i_{ast}, i'_{ps})~~~~
	   \hat{\imath} \triangleleft i_{ast}~~~~
	   \Gamma; \emptyset \vdash_\Sigma \hat{\imath} \leadsto i \Leftarrow t~~~~
	   i'_{ps}~\texttt{empty}
	   \end{array}}
%	  {\renewcommand{\arraystretch}{1}
%	    \begin{array}{r}
%	    \vdash \Delta_0, \Delta ~~~ \Delta_0, \Delta ;\emptyset; \emptyset \vdash t.\keyw{metadata}.parser\Leftarrow Parser \leadsto i_p ~~~ \texttt{TS(}\lfloor body \rfloor \texttt{)}\ \texttt{is}\ i_{ts}\\
%            i_p.parse(i_{ts}) \Downarrow_{\Delta_0, \Delta} (i', \hat e_{ts}') ~~~  e \triangleleft  i'~~~ \Delta_0, \Delta;\Gamma', \Gamma; \emptyset\vdash e\Leftarrow t \leadsto i ~~~ \hat e_{ts}'\ \texttt{empty}
%            \end{array}
%       }
%\infer[\textit{T-Tvar}]{
%	\vdash_\Sigma t
%}{
%	t : \{\_, \delta \} \in \Delta
%}
%~~~~~~~
%\infer[\textit{T-Arr}]{
%	\vdash_\Sigma \tau_1 \rightarrow \tau_2
%}{
%	\vdash_\Sigma \tau_1 & \vdash_\Sigma \tau_2
%}
%~~~~~~~
%\infer[?]{
%	\vdash \emptyset
%}{ }
%~~~~
%\infer[?]{
%	\vdash \Delta, t : \{ \omega, \delta \}
%}{
%	\vdash \Delta & \vdash_\Sigma \omega~\texttt{ok} & \Delta, t : \{\omega, -\} \vdash \delta
%}
\end{array}
\]
\vspace{-10px}
\label{fig:statics2}
\caption{Statics for $e$, continued}
%\vspace{-10px}
\end{figure}
\newcommand{\Gout}{\Gamma_{\text{out}}}
\newcommand{\Gin}{\Gamma_{\text{in}}}
\begin{figure}[t]
$\fbox{$\Gamma; \Gamma \vdash_\Sigma \hat{\imath} \leadsto i \Leftarrow \tau$}$~
$\fbox{$\Gamma; \Gamma \vdash_\Sigma \hat{\imath} \leadsto i \Rightarrow \tau$}$
\[
\begin{array}{c}
\infer[\textit{T-var-H}]
	{\Gout; \Gin \vdash_\Sigma x \leadsto x \Rightarrow\tau } 
	{x:\tau \in \Gin }
~~~~~~
\infer[\textit{T-abs-H}]
	{\Gout; \Gin \vdash_\Sigma  \boldsymbol\lambda x . \hat{\imath} \leadsto \boldsymbol\lambda x .i \Leftarrow \tau_1 \rightarrow \tau_2 } 
	{\Gout; \Gin, x:\tau_1 \vdash_\Sigma \hat{\imath}\leadsto i\Leftarrow \tau_2 }\\[1ex]
\cdots\\[1ex]
\infer[\textit{T-spl-A}]
	{\Gout; \Gin \vdash_\Sigma \keyw{spliced}[e] \leadsto i \Leftarrow \tau}
	{\Gout \vdash_\Sigma e \leadsto i \Leftarrow \tau}~~~~

\infer[\textit{T-spl-S}]
	{\Gout; \Gin \vdash_\Sigma \keyw{spliced}[e] \leadsto i \Rightarrow \tau}
	{\Gout \vdash_\Sigma e \leadsto i \Rightarrow \tau}\\[3ex]
\end{array}
\]
\vspace{-15px}
\caption{Statics for $\hat e$. All rules are the unidirectional version of the corresponding rule for $e$ with a combined variable context. $\keyw{new}$ is unrestricted. See Lemma 1.}
\vspace{-10px}
\label{fig:staticsHat}
\end{figure}
\begin{figure}[t]
\centering
\begin{minipage}[t]{.51\textwidth}
$\fbox{$i \downarrow \hat{\imath}$}$
\vspace{-20px}
   \[
\begin{array}{c}
\infer[\textit{DR-Var}]
	{ x \triangleleft Exp.Var(i_{id})   }
	{ \texttt{Var($i_{id}$) is $x$}} \\[3ex]

\infer[\textit{DR-Lam}]
	{ \boldsymbol\lambda x{:}\tau . e \triangleleft Exp.Lam( i_{id}, i_{ty}, i)  }
	{ \texttt{Var($i_{id}$) is $x$} & \tau \triangleleft i_{ty} & e \triangleleft i } \\[3ex]

\infer[\textit{DExp-App}]
	{ e_1(e_2)  \triangleleft Exp.App(i_1,i_2) }
	{ e_1 \triangleleft i_1  & e_2 \triangleleft i_2   } \\[3ex]

\infer[\textit{DR-FromTS}]
          {\renewcommand{\arraystretch}{1}
	    \begin{array}{r}
	    \keyw{fromTS}(e) \triangleleft\\
            Exp.FromTS(i_{ts},i_{tok})
            \end{array}
       }
	  {\texttt{ParseConc($i_{ts},i_{tok}$) is $e$}}
\end{array}
\]
$\fbox{$\tau \triangleleft i$}$
\vspace{-20px}
\[
\begin{array}{c}
\infer[\textit{DTy-Var}]
	{ t \triangleleft Ty.Var(i_{id})   }
	{ \texttt{Var($i_{id}$) is $t$}} \\[3ex]

\infer[\textit{DTy-Arr}]
	{ \tau_1 \rightarrow \tau_2 \triangleleft Ty.Arrow(i_1,i_2 )  }
	{ \tau_1 \triangleleft i_1 & \tau_2 \triangleleft i_2 }
\end{array}
\]
\label{fig:dereification}
\vspace{-10px}
\caption{Dereification Rules (selected)}
\end{minipage}%
~\vline~
\begin{minipage}[t]{.44\textwidth}
$\fbox{$i \triangleright i$}$
\vspace{-20px}
  \[
\begin{array}{c}
\infer[\textit{R-Var}]
	{ x \triangleright Exp.Var(i_{id})   }
	{ \texttt{ID($x$) is $i_{id}$}} \\[3ex]

\infer[\textit{R-Lam}]
	{ \boldsymbol\lambda x{:}\tau . i \triangleright Exp.Lam( i_{id}, i_{ty}, i' )  }
	{\texttt{ID($x$) is $i_{id}$} & \tau \triangleright i_{ty} & i \triangleright i'  } \\[3ex]

\infer[\textit{R-App}]
	{ i_1(i_2)  \triangleright Exp.App(i'_1,i'_2) }
	{ i_1 \triangleright i'_1  & i_2 \triangleright i'_2   }
\end{array}
\]
$\fbox{$\tau \triangleright i$}$
\vspace{-20px}
\[
\begin{array}{c}
~~~~\infer[\textit{RTy-Var}]
	{ t \triangleright Ty.Var(i_{id})   }
	{ \texttt{ID($t$) is $i_{id}$}} \\[3ex]

\infer[\textit{RTy-Arr}]
	{ \tau_1 \rightarrow \tau_2 \triangleright Ty.Arrow(i_1,i_2 )  }
	{ \tau_1 \triangleright i_1 & \tau_2 \triangleright i_2 }
\end{array}
\vspace{-15px}
\]
\label{fig:reification}
\caption{Reification Rules (selected)}
\end{minipage}
\begin{minipage}[t]{.44\textwidth}
a
\end{minipage}
%\vspace{-15px}
\end{figure}

%In the following paragraphs, we are explaining the details of each of the static semantics rules.
%
%The rule \textit{RT-objtype} checks that the declaration of the object type $t$ is well-formed and the type of the expression $e$ is the same as the type of $t$'s metadata.
%Similarly, in the rule \textit{RT-casetype} we check that the declaration of the sum type $t$ is well-formed and the type of the expression $e$ is the same as the type of $t$'s metadata.
%The corresponding static rule for the third case of the program $\rho$ of the abstract syntax is \textit{RT-e}.
%
%We check that the type $\tau$ that is referenced by the name $C$ belongs to the type context $\Delta$ in the rule \textit{C-decl} .
%The rule \textit{C-decls} allows a case type to have multiple cases, where each case will be checked by the rule \textit{C-decl}. We have to make sure that there are no two cases with the same names; we do this by checking that the domains of the $\chi$s are disjoint.
%
%The rule \textit{O-val} checks that the type of a field ($\keyw{val}$) belongs to the type context $\Delta$ and thus makes the declaration of a value well-formed (\texttt{ok}).
%In a similar fashion, we check that the type of a method ($\keyw{def}$) belongs to the type context $\Delta$ in the premise of the rule \textit{C-decl}. 
%Multiple declarations of values $val$ and methods $def$ to appear one after the other are allowed by the rule \textit{O-defs}. Each declaration will either be checked by the rule \textit{O-val} or \textit{O-def}. We have to make sure that there are no two values or methods with the same name; we do this by checking that the domains of the $\omega$s are disjoint.
%
%We mediate between synthesis and type checking by using the \textit{Syn2Check} rule. This rule states that syntesis is more powerful than type checking.
%
%Rules \textit{T-varx}, \textit{T-abs} and \textit{T-appl} are conventional and we do not discuss them in detail here.
%
%The rule \textit{T-introcase} introduces a case of the case type and syntesizes the type of the resulting expression. To make it simpler, we precede the name of the case by the sum type that includes that case.
%The type of the resulting expression of a particular case of a sum type is synthesized in the \textit{T-elimcase} rule. Note that all the cases of the same case type should synthesize to the same type. The rules  \textit{T-casehelper1} and \textit{T-casehelper2} help with the type checking of $c:\chi \Rightarrow \tau'$ in the rule \textit{T-elimcase}. Rule \textit{T-casehelper1} is used when $c$ is of the kind (matches) $C(\chi)\Rightarrow e$ , while rule \textit{T-casehelper2} is used when $c$ is of the kind $c_1 \bnfalt c_2$.
%
%The rule \textit{T-new} checks the type of a \keyw{new} expression. This rule is used to construct a \keyw{new} expression and it follows the convention of bidirectional type systems, where type-checking is used for constructors of types. We need the additional premise $t\neq TokenStream$ because we do not want to allow users to create their own token streams. This premise is related to hygienic macros \cite{DBLP:conf/esop/HermanW08} and that we do not want identifiers (names of fields or methods) defined by users to be shadowed by identifiers defined in a type. We have to differentiate between the two and we do this by annotating the code that comes from the user with $TokenStream$. 
%The rule \textit{T-new-hat} from Figure \ref{fig:staticsHat} allows the type $t$ to be $TokenStream$ because we need to allow the compiler to create token streams; the users are the ones who write expressions of the form $e$, while the compiler produces expressions of the form $i$ which have already been translated from a specific TSL to Wyvern. 
%
%Rules \textit{DT-val} and \textit{DT-def} are used to check the type of a field or method when they are instantiated to an expression.
%The rule \textit{DT-defs} allows for multiple instatiations of fields or methods to take place one after the other. Each instantiation is checked with the rule \textit{DT-val} or \textit{DT-def}.
%
%Rules \textit{T-field} and \textit{T-def}  synthesize the type of the field/the method of an expression. Each premise mentions whether the field is declared as a value \keyw{val} or a method (\keyw{def}).
%
%We ascribe (attribute) the type $\tau$ to $e$ in the rule \textit{T-ascribe}, after checking in the premise of the rule that the type of $e$ is $\tau$.
%The rule \textit{T-valAST} is used to transform an expression $e$ into an abstract syntax tree of type $Exp$. The definition of type $Exp$ is given in Figure \ref{fig:synExpTy}. 
%We synthesize the type of the \keyw{metadata} of the type $t$ in rule \textit{T-metadata}. We check that $t$ is in the type context $\Delta$ and it has the right type.
%The rule \textit{T-fromTS} checks the type of the \keyw{fromTS} expression. Expression $e_1$ represents a token stream, $e_2$ is a delimiter token and $e$ is the concrete expression that $e_1$ parses to using $e_2$ as end delimiter. 
%
%The rule \textit{T-literal} is a crucial rule of the our system. The conclusion checks that the $\lfloor body \rfloor$ expression has the type $t$ and that it is translated to the expression $i$ that does not contain a $\lfloor body \rfloor$ expression. The premise checks that the $parser$ method of the \keyw{metadata} of the $t$ type is of type $Parser$. Instead of using $t.\keyw{metadata}.parser$ we use $i_p$ in the rest of the rule. The premise continues by denoting the token stream of the $\lfloor body \rfloor$ expression by $i_{ts}$. When the token stream is parsed with the method $parse$ that has as second argument a token used as a signal of the stream ending, it evaluates to $(i',i'_{ts})$. The expression $i'$ is the actual result of the parsing and it does not contain a $\lfloor body \rfloor$ expression, with $i'_{ts}$ being the remainder of the token stream. Since we parse the token stream until the last token, $i'_{ts}$ will be empty. Note that only expressions with a hat $\hat{}$ contain a $\lfloor body \rfloor$ expression. The expression $i'$ is then dereificated to the expression $e$. The dereification rules are found in Figure \ref{fig:dereification} and the reification rules are in Figure \ref{fig:reification}. 
%
%Dereification means transforming an expression of type $Exp$ or $Ty$ (from Figure \ref{fig:synExpTy}) into an expression that can be found in the abstract syntax Figure \ref{fig:core2-syntax}. The judgement for dereification is \fbox{$e_1 \triangleleft e_2$}, where $e_1$ is a form of the abstract syntax and $e_2$ is of type $Exp$ or $Ty$ . Reification is the reverse of dereification, where an expression found in the abstract syntax is transformed into an expression that the parser generates, of type $Exp$ or $Ty$. The judgement for reification is \fbox{$e_1 \triangleright_{\Gamma} e_2$}, where $e_1$ is a form of the abstract syntax and $e_2$ is of type $Exp$ or $Ty$ .
% Expression $e$ is recursively translated to the $i$ expression by using the same rule \textit{T-literal}. This rule might not terminate in the general case because the $parse$ function in the premise might not terminate, but termination of the parsing process is well studied \cite{DBLP:conf/sle/KrishnanW12} and the techniques can be applied to our system. 

\begin{figure}[t]
\centering
\[
\begin{array}{c}
\infer[\textit{D-m}]
	{\keyw{metadata}[t] \xmapsto[\Sigma]{} i} 
	{t\,\{\_,i:\tau\} \in \Sigma}\\[1ex]

\infer[\textit{D-l1}]
	{\keyw{lift}(i) \xmapsto[\Sigma]{} \keyw{lift}(i') } 
	{i \xmapsto[\Sigma]{} i'}
~~~~~~~~
\infer[\textit{D-l2}]
	{\keyw{lift}(i) \xmapsto[\Sigma]{} i' } 
	{i\ \texttt{val} &i \triangleright i' }\\[3ex]
\end{array}
\]
\label{fig:dynsemantics}
\vspace{-15px}
\caption{Dynamic Semantics \todo{full (de)reification/opsem}}
\end{figure}


