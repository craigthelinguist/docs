% !TEX root = ecoop14.tex

\section{Implementation}
\label{s:implementation}
The Wyvern implementation is written in Java, based around a custom recursive-descent parser, with self-hosting left to future work.

Whitespace based parsing is implemented with a custom stateful lexer as in Python, producing indent and dedent tokens. The token stream produced by the lexer is then passed into the Wyvern parser. When a language treansition occurs, the Wyvern core parser extracts a substream from the current token stream, using either indent and dedent or any of the TSL delimiters to indicate where the substream should begin or end. This substream is then passed to the extension parser as an argument. By subdividing the token stream, the parsers can avoid complicated issues with delegation of responsibillity caused by a single shared stream. 

In order to invoke the correct extension parser, the Wyvern compiler reqires a typing context to be present when parsing. To implement this, we combine the typechecking and parsing stages of the compiler, so that typechecking happens incrementally as the source is parsed. Once the first stage of parsing is complete and all Wyvern expressions are known, the Wyvern constructs are typechecked. Then, types for TSL blocks are inferred from the local type context, and the associated parsers are invoked in stage 2 on the substreams inside the TSL blocks.

Extension parsers are added though the interpreters Java interop, which allows Wyvern types to be structural subtypes of Java interfaces. Using this system, we convert type metaobjects into Java objects extending the Java Parser interface. Then, they are used just as if they were defined in Java code.