% !TEX root = ecoop14.tex

\section{Implementation}
\label{s:implementation}
\todo{implementation - Benjamin?}

%The Wyvern compiler
%was developed from the ground up to support the extensible parsing
%interface. The compiler is currently implemented in Java, with an eventual goal of self-hosting it within Wyvern itself.
%
%Wyvern uses a fixed whitespace-indented lexing approach similar to that used by languages like Python. The current indentation convention is based on the number of whitespace characters. In order for a block to be formed, each of its lines must share the same initial whitespace string. If the indentation level is decreased but does not return to the initial indentation level, a keyword block is created as shown in Figure \ref{f:dsl-multi}. This particular approach is not found in other whitespace-delimited languages to our knowledge.
%
%The Wyvern front-end effectively combines the parsing and type checking
%stages that are usually separated in more traditional compilers, such
%as \texttt{javac} or \texttt{gcc}. Before any block can be parsed,
%Wyvern requires a context that contains the types of the arguments of the surrounding function and any variables and types in scope. This context is passed into the delimited block for portions of the type-associated grammar that contain terms of sort \verb|Exp| or \verb|Type|, and thus may contain other function calls, variables, or types. 

%For example, the Wyvern default environment contains bindings for
%keywords like \keyw{class} or \keyw{meth} that are able to parse
%class and method declarations respectively. Parsers are bound to types and, as such, may be shadowed within application code. Only operators and their associated precedence are not exposed in the environment and, thus, have to be reused by the DSLs, though it is feasible to lift them up to the
%environment with an appropriate parser.
%
%% , an infix nature of operators
%% might make parsing definition more complex with arguably small gains
%% in expressiveness for potential DSLs.

%The core parsing in Wyvern is an extremely simple mechanism. The language uses a core parser that for every token encountered delegates to the appropriate parser in the environment. This extension parser processes the token and any relevant ones that follow. Once the extension parser is finished, the core parser continues through the remaining tokens, terminating when it either runs out of tokens or encounters a token with no associated extension parser.

%% In a similar manner to keywords, we also allow types and values to
%% attach appropriate bindings that can potentially define how to parse a
%% particular type and value as well as connecting them to an appropriate
%% type representation. For example, currently all primitive types (such
%% as integers, booleans, or strings) are defined using a binding as well
%% as basic values such as \texttt{true} or \texttt{false}.

%% Such flexible mechanism, especially when defined in Wyvern itself
%% makes any DSL extension as flexible and natural to define as writing
%% any normal Wyvern program itself.


%% \subsection{Examples}

%% We now present a small number of examples that demonstrate and explain
%% the operation of Wyvern.

%% \begin{figure}
%%   \centering
%%   \label{f:eg-let-eg}
%%   \caption{Wyvern Example: \texttt{let}}
%% \end{figure}
%% The \lstinline{let} parser knows that the first few lines following
%% the \lstinline{let} keyword will be variable definitions of the form
%% \lstinline{varname = value} and therefore can easily parse the lines
%% that following until a token \lstinline{in} on an indented line of its
%% own is encountered.  The body of the \lstinline{let} statement can now
%% be parsed using a continuation of the original Wyvern parser with an
%% addition of variables \lstinline{x} and \lstinline{z} to the current
%% environment. When the indented block finishes, the main Wyvern parser
%% can continue without \lstinline{let} variables in the environment. One
%% can observe that such parsing is very suitable to performing parsing
%% and type checking at the same time.

%% Our next example presents a simple \lstinline{if} statement in
%% Figure~\ref{f:eg-if}. Just like with the \lstinline{let} statement,
%% one can see how upon seeing the \lstinline{if} keyword, Wyvern parser
%% can invoke an appropriate \lstinline{if} parser that can easily be
%% replaced or modified. The default \lstinline{if} parsers parses the
%% conditional and is able to parse the body using the continuation of
%% the main parser with the right value of the condition taken into
%% account. One can observe that extending Wyvern to perform flow
%% sensitive checks such as non-nullness can be done easily even during
%% the parsing stage.

%% \begin{figure}
%%   \centering
%%   \begin{lstlisting}
%% if x = 5
%%     do stuff
%%   else
%%     do stuff
%%   \end{lstlisting}
%%   \label{f:eg-if}
%%   \caption{Wyvern Example: \texttt{if}}
%% \end{figure}

%% A more interesting variation of the \lstinline{if} statement shown in
%% Figure~\ref{f:eg-if-smalltalk} can be one that attaches a parser to
%% the boolean type rather than a specific keyword. In the spirit of
%% Smalltalk, one can provide a parser in Wyvern that is invoked when an
%% expression of a boolean type is encountered. Such parser can then
%% check if the next keyword is \lstinline{iftrue} that can be followed
%% by the true block parsed by the continuation of the normal
%% parser. Furthermore, an additional \lstinline{iffalse} keyword can be
%% allowed that contains the else part.

%% \begin{figure}
%%   \centering
%%   \begin{lstlisting}
%% condition iftrue
%%     [block]
%%   iffalse
%%     [block]
%%   \end{lstlisting}
%%   \label{f:eg-if-smalltalk}
%%   \caption{Wyvern Example: \texttt{if} in Smalltalk style}
%% \end{figure}

%% As a more complex example, consider an attempt to express a simple
%% Domain Specific Language that roughly corresponds to
%% HTML. Figure~\ref{f:eg-html} shows such extension that makes each
%% major html tag a keyword with its own parser attached to it. In fact,
%% each keyword can be treated as a first class value that can be stored
%% in a variable resulting in body being passed around or used as part of
%% a \lstinline{let} expression. The indentation makes clear when each
%% tag's parser needs to stop and in our opinion makes a body of a web
%% page much more readable, yet structured and even suitable for type
%% checking.

%% \begin{figure}
%%   \centering
%%   \begin{lstlisting}
%% let 
%%     theBody = body
%%         h1
%%             "This is a section header"
%%   in  
%% 	html
%% 	    head
%% 	        title: "The title of the page"
%% 	        script(src="http://.../")
%% 	        style
%% 	            body
%% 	                background-color: "white"
%% 	    theBody
%%   \end{lstlisting}
%%   \label{f:eg-html}
%%   \caption{Wyvern Example: HTML}
%% \end{figure}

%% \begin{figure}
%%   \centering
%%   \label{f:eg-arch}
%%   \begin{lstlisting}
%%   \end{lstlisting}
%%   \caption{Wyvern Example: Architecture}
%% \end{figure}

%% \begin{figure}
%%   \centering
%%   \label{f:eg-security}
%%   \begin{lstlisting}
%%   \end{lstlisting}
%%   \caption{Wyvern Example: Security Policy}
%% \end{figure}

%% \begin{figure*}
%%   \centering
%%   \label{f:eg-dsl-db}
%%   \begin{lstlisting}
%% assuming 
%%   theDB : OracleDB 
%% (that is, theDB is a DB that supports oracle-specific queries)

%% type-directed parsing:

%% theDB query
%%   (* stuff in the syntax of Oracle DBs *)

%% vs

%% keyword-directed parsing:

%% OracleDBquery theDB
%%   (* stuff in the syntax of Oracle DBs *)
%%   \end{lstlisting}
%%   \caption{Wyvern Example: DSL for DB Definition}
%% \end{figure*}



%For example, the Wyvern default environment contains bindings for
%keywords like \keyw{class} or \keyw{meth} that are able to parse
%class and method declarations respectively. Parsers are bound to types and, as such, may be shadowed within application code. Only operators and their associated precedence are not exposed in the environment and, thus, have to be reused by the DSLs, though it is feasible to lift them up to the
%environment with an appropriate parser.
%
%% , an infix nature of operators
%% might make parsing definition more complex with arguably small gains
%% in expressiveness for potential DSLs.

%The core parsing in Wyvern is an extremely simple mechanism. The language uses a core parser that for every token encountered delegates to the appropriate parser in the environment. This extension parser processes the token and any relevant ones that follow. Once the extension parser is finished, the core parser continues through the remaining tokens, terminating when it either runs out of tokens or encounters a token with no associated extension parser.

%% In a similar manner to keywords, we also allow types and values to
%% attach appropriate bindings that can potentially define how to parse a
%% particular type and value as well as connecting them to an appropriate
%% type representation. For example, currently all primitive types (such
%% as integers, booleans, or strings) are defined using a binding as well
%% as basic values such as \texttt{true} or \texttt{false}.

%% Such flexible mechanism, especially when defined in Wyvern itself
%% makes any DSL extension as flexible and natural to define as writing
%% any normal Wyvern program itself.


%% \subsection{Examples}

%% We now present a small number of examples that demonstrate and explain
%% the operation of Wyvern.

%% \begin{figure}
%%   \centering
%%   \label{f:eg-let-eg}
%%   \caption{Wyvern Example: \texttt{let}}
%% \end{figure}