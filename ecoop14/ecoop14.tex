\documentclass[runningheads]{llncs}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage[T1]{fontenc}
%\usepackage[defaultmono]{droidmono}
\usepackage{proof,amssymb,enumerate}
\usepackage{math-cmds}
\usepackage{listings}
%\setcounter{tocdepth}{3}
%\renewcommand*\ttdefault{txtt}
\usepackage[scaled]{beramono}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{url}
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\def\implies{\Rightarrow}
\newcommand{\todo}[1]{\textbf{[TODO: #1]}}
\newcommand{\keyw}[1]{\textbf{#1}}

\newtheorem{thm}{Theorem}
\newtheorem{dfn}{Definition}

\lstset{tabsize=2, 
basicstyle=\ttfamily\scriptsize, 
commentstyle=\itshape\rmfamily, 
numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,xleftmargin=15pt,escapeinside={(@}{@)}, morekeywords=[1]{let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,keyword}}
\lstloadlanguages{Java,VBScript,XML,HTML}


\begin{document}

\title{Safely-Composable Type-Specific Languages}
\author{~}
\institute{~}
%\author{Cyrus Omar \and Darya Kurilova \and Ligia Nistor \and Benjamin Chung \and\\
%Alex Potanin$^{1}$ \and Jonathan Aldrich}
%\institute{Carnegie Mellon University\todo{Should Alex's affiliation be CMU too?}\\

%NB! Alex says: I don't mind either way. CMU (since they paid me when I was there!)
%or VUW (Victoria University of Wellington) as long as my
%email stays: alex@ecs.vuw.ac.nz . Thanks!

%\texttt{\scriptsize \{comar, darya, lnistor, bwchung, aldrich\}@cs.cmu.edu}
%and
%$^{1}$\texttt{\scriptsize alex@ecs.vuw.ac.nz}}

\maketitle

\begin{abstract}
%The abstract should summarize the contents of the paper and should
%contain at least 70 and at most 150 words. It should be written using the
%\emph{abstract} environment.
Programming languages often include specialized notation for common datatypes (e.g. lists) and some also build in support for specific specialized datatypes (e.g. regular expressions), but user-defined types must use general-purpose notations. Frustration with this causes developers to use strings, rather than structured representations, with alarming frequency, leading to correctness, performance, security and usability  problems.
Allowing developers to modularly extend a language with new notations could help address these issues. Unfortunately, prior mechanisms either lack expressive power or suffer from composability problems: individually-unambiguous extensions introduce ambiguities if used together. We introduce an approach where user-defined types can define \emph{type-specific languages} that determine how \emph{generalized literals}, containing arbitrary syntax, are parsed specifically when they appear where an expression of that type is expected. This type-driven dispatch protocol guarantees safe composability. We provide evidence in support of  this approach and specify it with a bidirectional type system for an emerging language: Wyvern.

%
%Domain-specific languages can improve ease-of-use, expressiveness and verifiability, but defining and using different DSLs within a single application remains difficult.
%
%We introduce an approach for embedding DSLs in a common host language where the type of a piece of domain-specific code can specify which grammar governs it. Because this grammar is type-specific, but the block is delimited by the host language, we can guarantee that link-time conflicts cannot arise. These grammars can recursively include top-level expressions using special entry tokens that guarantee that the composition of the type-specific language and the host language is also sound. We argue that this approach occupies a previously-unexplored sweet spot providing high expressiveness and ease-of-use while guaranteeing safety. We introduce the design, provide examples, sketch the safety theorems and describe an ongoing implementation of this strategy in the Wyvern programming language.
%
%Domain-specific languages improve ease-of-use, expressiveness and
%verifiability, 
%but defining and using different 
%DSLs within a single application remains difficult.  
%We introduce an approach for embedded DSLs where 1) whitespace delimits DSL-governed blocks, and 2) the parsing and type checking phases occur in tandem so that the expected type of the block determines which domain-specific parser governs that block.
%We argue that this approach occupies a sweet spot, providing   
%high expressiveness and ease-of-use while maintaining safe composability. We introduce the design, provide examples and describe an ongoing implementation of this strategy in the Wyvern programming language. We also discuss how a more conventional keyword-directed strategy for parsing of DSLs can arise as a special case of this type-directed strategy.
%
\keywords{extensible languages; parsing; bidirectional typechecking}
\end{abstract}

\input{intro}
\input{motivation}
\input{approach}
\input{statics}
\input{implementation}
\input{discussion}
\input{related}
\input{conclusion}

\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}
