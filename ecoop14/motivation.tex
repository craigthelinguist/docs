% !TEX root = ecoop14.tex

\section{Type-Specific Languages in Wyvern}
\label{s:motivation}

To motivate our work we show an example, which illustrates the expressiveness that our approach provides, and also present results of a small empirical study that looked into how current Java projects could  benefit from using TSLs.

\subsection{Motivating Example}

In this subsection, we show an example that demonstrates the key features of our approach. Here we give an informal explanation of the Wyvern language and the TSL-related constructs; a formal and more detailed description is to follow in the subsequent sections.


\begin{figure}[t]
\begin{lstlisting}
(* Assuming that serve : (URL, HTML) -> Unit; bodyFont : Font; db : DB; 
   SearchBox : String -> HTML; itemsFromDB : (DB, Nat, SQLQuery) -> HTML *)
let imageURL : URL = `images.example.com` in
let bgImage : URL = `{images}/background.gif` in
serve(~)
  :html
    :head
      :title Product Listing
      :style {~
        body { font-family: {bodyColor} }
      }
    :body
      :div[id="search"]
        {SearchBox("Products")}
      :ul[id="products"]
        {items_from_db(db, 10, <SELECT * FROM products>)}
\end{lstlisting}
\caption{Wyvern Example.}
\label{f-example}
\end{figure}

\todo{Alex says: Jumpting straight into the delimiter pairs for distinguishing TSL from GPL is confusing. However, maybe Introduction will help with this.}

One of the reasons that motivated our work is the aspiration to provide developers with a possibility to compose various language constructs together in a program in a simple intuitive way. Consider a piece of Wyvern code in Figure~\ref{f-example}. When executed, it produces a webpage that displays a bulleted list of products followed by a list of reviews, both retrieved from a database. Notably, this method is mere 14 lines long but comprises the host Wyvern language as well as 6 type-specific languages. Each of the TSLs is introduced either within a pair of delimiters (e.g., backticks (\lstinline{`}), quotation marks (\lstinline{"}), or matching angle brackets (\lstinline{<} and \lstinline{>})) or by a tilde (\lstinline{~}) on a preceding line. The escape back to the host language is also done with a use of a pair of delimiters (e.g., matching curly braces (\lstinline|{| and \lstinline|}|)). With this in mind, let us have a closer look at how the code on Figure~\ref{f-example} decomposes:

\begin{itemize}
\item As a first argument to the Wyvern \lstinline{serve} method, a URL TSL, delimited by backticks, is used (line 1);
\item The skeleton of the \lstinline{serve} method's body is written using an HTML TSL (lines 2-14), which was introduced by the tilde on line 1;
\item For the \lstinline{style} ``tag'' of the HTML code on line 5, containing a precursory tilde, a CSS TSL is used (line 6);
\item Inside the CSS TSL, the \lstinline{bodyFont} is a Wyvern variable, escaped by a matching pair of curly braces (line 6);
\item Inside the \lstinline{serve} method's HTML skeleton code, Wyvern code is used thrice: on line 10, to specify the content of the \lstinline{div} ``tag'' and, on lines 12 and 14, to produce two bulleted lists\textemdash every time the Wyvern code is delimited by curly braces;
\item When specifying the content for the \lstinline{div} ``tag,'' a Wyvern \lstinline{SearchBox} method is using a TSL for strings (in Wyvern, there is no built-in data structure to represent strings; they are implemented as TSLs) and the string ``Products,'' delimited by quotation marks, is passed in (line 10);
\item In the Wyvern \lstinline{items_from_db} method, the second argument is an SQL TSL (line 12), which is introduced by a matching pair of angle brackets and returns a list of \lstinline{Item}s;
\item In the Wyvern \lstinline{reviews_from_db} method, the second argument is another SQL TSL (line 14), which is also introduced within angle brackets but returns a list of \lstinline{Review}s;
\item Finally, the query provided to the Wyvern \lstinline{reviews_from_db} method contains a Wyvern variable \lstinline{UserLocation} which is escaped using a pair of matching curly braces (line 14).
\end{itemize}

Apart from the large number of TSL that can be composed together in a short piece of code and produce meaningful results, we aim at providing a safe composability guarantees that other language extension solutions don't (cf.~\cite{Erdweg:2013:FEL:2517208.2517210} \todo{more citations?}). For instance, in the above Wyvern code the SQL TSLs use similar syntax; however, since they are triggered by methods expecting different types of arguments, namely \lstinline{items_from_db} method takes in a list of \lstinline{Item}s whereas \lstinline{reviews_from_db} method takes in a list of \lstinline{Review}s, the overlapping keywords used in the TSLs do not cause any ambiguities and can be safely composed.

%
%\begin{figure}
%  \centering
%  \begin{lstlisting}
%val dashboardArchitecture : Architecture = ~
%    external component twitter : Feed
%        location www.twitter.com
%    external component client : Browser
%        connects to servlet
%    component servlet : DashServlet
%        connects to productDB, twitter
%        location intranet.nameless.com
%    component productDB : Database
%        location db.nameless.com
%    policy mainPolicy = ~
%        must salt servlet.login.password
%        connect * -> servlet with HTTPS
%        connect servlet -> productDB with TLS
%  \end{lstlisting}
%  \caption{Wyvern DSL: Architecture Specification}
%  \label{f:dsl-arch}
%\end{figure}
%
%We start with a few examples to illustrate the expressiveness of our approach and the breadth of DSLs we plan for it to support.  The examples are presented in the proposed syntax for Wyvern, a new language being developed by our group that is targeted toward building secure web and mobile applications. We will informally describe each of these examples here, and further explain how such code is parsed in Section \ref{s:approach}.
%
%The first example, shown in Figure~\ref{f:dsl-arch}, describes the overall architecture of a ``hot product dashboard'' application.  The variable \lstinline{dashboardArchitecture} is explicitly ascribed type \lstinline{Architecture}. Rather than explicitly providing a value of this type, we instead use a DSL that makes specifying the component architecture of the application more concise and readable. This DSL code appears in the subsequent whitespace-delimited block and is introduced by a tilde (\lstinline{~}). The example architecture declares several components, some of which are declared \keyw{external} to indicate that they are used by this application but are not part of it directly. Component types are declared after a colon and attributes like connectivity location, are declared after the type (formatted in an indented block for readability). 
%The \keyw{policy} keyword (line 11) introduces a security policy, which constrains the communication protocols that can be used and 
%enforces the secure handling of passwords. A separate type, \lstinline{Policy}, is associated with such policies. Although we could instantiate this type explicitly using a Wyvern expression, we use a DSL for defining policies instead, again within a whitespace-delimited block introduced by a tilde.
%
%\begin{figure}
%  \centering
%  \begin{lstlisting}
%val newProds = productDB.query(~)
%    select twHandle 
%    where introduced - today < 3 months
%val prodTwt = new Feed(newProds)
%return prodTwt.query(~)
%    select *
%    group by followed
%    where count > 1000
%  \end{lstlisting}
%  \caption{Wyvern DSL: Queries}
%  \label{f:dsl-query}
%\end{figure}
%
%Figure~\ref{f:dsl-query} shows how a DSL for database queries can be used from within ordinary Wyvern code.  The example shows code for computing a feed that is derived from tweets about a company's new products.  In this example, the use of a querying DSL is triggered by the use of methods named \lstinline{query} expecting an argument of type \lstinline{DBQuery} (line 1) or \lstinline{FeedQuery} (line 5) respectively.  These types define related but distinct syntax for queries, determined by the expected type of expression where the tilde appears (tildes need not appear only at the ends of lines). Queries are again delimited by indentation. This mechanism is similar to what can be expressed in languages with built-in query syntax like LINQ \cite{mslinq}, but in this case, it is entirely user-defined, rather than built into the language.\begin{figure}
%  \centering
%  \begin{lstlisting}
%serve(page, loc) where 
%  val page = ~ 
%    html:
%      head:
%        title: Hot Products
%        style: {myStylesheet}
%        body:
%          div id="search":
%            {SearchBox("products")}
%          div id="products":
%            {FeedBox(servlet.hotProds())}
%  val loc = ~
%    products.nameless.com
%  \end{lstlisting}
%  \caption{Wyvern DSLs: Presentation and URLs}
%  \label{f:dsl-presentation}
%\end{figure}
%
%Finally, Figure~\ref{f:dsl-presentation} shows a DSL for presenting the hot product application to a web browser, served at a particular URL. Here, two DSLs are used within a single function call. To allow this without introducing ambiguity, the user can use a \keyw{where} clause, similar to that found in Haskell \cite{jones2003haskell}. The presentation DSL is based on HTML and associated with a type, \lstinline{HTMLElement}. It uses an indentation-sensitive syntax and allows integration of Wyvern code of the appropriate type using curly braces. The second DSL simply canonicalizes URL literals into Wyvern values of type \lstinline{URL}.
