% !TEX root = ecoop14.tex

\section{Type-Specific Languages in Wyvern}
\label{s:motivation}
We begin with an example in Fig. \ref{f-example} showing several different TSLs being used to define a fragment of a web application showing search results from a database. We will review this example below to develop intuitions about TSLs in Wyvern; a formal and more detailed description will follow in the subsequent sections.
\begin{figure}[t]
\begin{lstlisting}
let imageBase : URL = <images.example.com>
let bgImage : URL = <{imageBase}/background.png>
new : SearchServer
  def serve_results(searchQuery : String, page : Nat) : Unit =
    serve(~) (* serve : HTML -> Unit *)
      :html
        :head
          :title Search Results
          :style {~
            body { background-image: url({bgImage}) }
            #search { background-color: {`#aabbcc`.darken(20pct)} }
          }
        :body
          :h1 Results for {searchQuery}
          :div[id="search"]
            Search again: {SearchBox("Go!")}
          { (* fmt_results : (DB, SQLQuery, Nat, Nat) -> HTML *)
            fmt_results(db, ~, 10, page)
              SELECT * FROM products WHERE {searchQuery} in title
          }
\end{lstlisting}
\vspace{-10px}
\caption{Wyvern Example \todo{better caption?}\todo{colors}}
\label{f-example}
%\vspace{-15px}
\end{figure}
 
Our first TSL appears on line 1. The type of \li{imageBase} is \li{URL}, an \emph{object type} containing several fields representing the components of a URL: its protocol, domain name, port, path and so on. Instead of creating a new object and setting these fields explicitly, however, we instantiate them using the \emph{generic literal} \li{<images.example.com>}, using conventional notation for URLs. Because of the type annotation, this literal's \emph{expected type} is known to be \li{URL}, so the body of this literal (the characters between the angle brackets) is governed by the \li{URL} TSL. It will be parsed by this TSL \emph{at compile-time} to produce a Wyvern AST that instantiates a new object of type \li{URL} explicitly (see below).

In addition to defining conventional notation for URLs, this TSL supports \emph{interpolation} of an expression of type \li{URL} to form a larger URL, using curly braces as a delimiter as seen on line 2. The TSL parses the portion between curly braces as a Wyvern expression and specifies its expected type as  \li{URL}. The TSL can then assume the interpolated value is of this type to construct an AST for the overall value; string interpolation does not occur.

To introduce a value manually, we must use {general-purpose notation}. The general-purpose notation for introducing a value of an object type is to use \li{new}. This term is a syntactic \emph{forward reference} to the layout-delimited block of \emph{definitions} beginning on the line after the line \li{new} appears in and ending when the indentation level has returned to the baseline or the file ends (here, lines 4-20). An object in TSL Wyvern can contain methods, introduced using \li{def}, and fields, introduced using \li{val}. Here we have just a single method, \li{serve_results} taking two arguments. Object types in TSL Wyvern are simple structural types that constrain the signatures of fields and methods. The \emph{type ascription} around \li{new} checks that the object being introduced satisfies the signature of \li{SearchServer}.



\begin{figure}[t]
\begin{lstlisting}[mathescape]
`literal body here, ``inner backticks`` must be doubled`
'literal body here, ''inner single quotes'' must be doubled'
"literal body here, ""inner double quotes"" must be doubled"
{literal body here, {inner braces} must be balanced}
[literal body here, [inner brackets] must be balanced]
<literal body here, <inner angle brackets> must be balanced>
12xyz (* there are no delimiters for number literals *)
\end{lstlisting}
\vspace{-10px}
\caption{Inline Generic Literal Forms}
\vspace{-15px}
\label{f-delims}
\end{figure}

On line 5 of Fig. \ref{f-example}, we see a call to the function \li{serve}, which has type \li{HTML -> Unit}. Here, \li{HTML} is a user-defined \emph{case type}, having cases for each HTML tag as well as some other structures. Declarations  of some of these cases can be seen on lines 2-6 of Fig. \ref{f-htmltype}. The general-purpose introductory form for a case type like \li{HTML} is, e.g., \li{HTML.BodyElement(attrs, child)}. But, as discussed in Sec. \ref{s:intro}, using this syntax can be cognitively demanding. Thus, we associate a TSL with \li{HTML} that provides a 

\todo{describe HTML, a case type not an obj type. these are the two user-defined types}One of the reasons that motivated our work is the aspiration to provide developers with a possibility to compose various language constructs together in a program in a simple intuitive way. Consider a piece of Wyvern code in Figure~\ref{f-example}. When executed, it produces a webpage that displays a bulleted list of products followed by a list of reviews, both retrieved from a database. Notably, this method is mere 14 lines long but comprises the host Wyvern language as well as 6 type-specific languages. Each of the TSLs is introduced either within a pair of delimiters (e.g., backticks (\lstinline{`}), quotation marks (\lstinline{"}), or matching angle brackets (\lstinline{<} and \lstinline{>})) or by a tilde (\lstinline{~}) on a preceding line. The escape back to the host language is also done with a use of a pair of delimiters (e.g., matching curly braces (\lstinline|{| and \lstinline|}|)). With this in mind, let us have a closer look at how the code on Figure~\ref{f-example} decomposes:

\begin{itemize}
\item As a first argument to the Wyvern \lstinline{serve} method, a URL TSL, delimited by backticks, is used (line 1);
\item The skeleton of the \lstinline{serve} method's body is written using an HTML TSL (lines 2-14), which was introduced by the tilde on line 1;
\item For the \lstinline{style} ``tag'' of the HTML code on line 5, containing a precursory tilde, a CSS TSL is used (line 6);
\item Inside the CSS TSL, the \lstinline{bodyFont} is a Wyvern variable, escaped by a matching pair of curly braces (line 6);
\item Inside the \lstinline{serve} method's HTML skeleton code, Wyvern code is used thrice: on line 10, to specify the content of the \lstinline{div} ``tag'' and, on lines 12 and 14, to produce two bulleted lists\textemdash every time the Wyvern code is delimited by curly braces;
\item When specifying the content for the \lstinline{div} ``tag,'' a Wyvern \lstinline{SearchBox} method is using a TSL for strings (in Wyvern, there is no built-in data structure to represent strings; they are implemented as TSLs) and the string ``Products,'' delimited by quotation marks, is passed in (line 10);
\item In the Wyvern \lstinline{items_from_db} method, the second argument is an SQL TSL (line 12), which is introduced by a matching pair of angle brackets and returns a list of \lstinline{Item}s;
\item In the Wyvern \lstinline{reviews_from_db} method, the second argument is another SQL TSL (line 14), which is also introduced within angle brackets but returns a list of \lstinline{Review}s;
\item Finally, the query provided to the Wyvern \lstinline{reviews_from_db} method contains a Wyvern variable \lstinline{UserLocation} which is escaped using a pair of matching curly braces (line 14).
\end{itemize}

Apart from the large number of TSL that can be composed together in a short piece of code and produce meaningful results, we aim at providing a safe composability guarantees that other language extension solutions don't (cf.~\cite{Erdweg:2013:FEL:2517208.2517210} \todo{more citations?}). For instance, in the above Wyvern code the SQL TSLs use similar syntax; however, since they are triggered by methods expecting different types of arguments, namely \lstinline{items_from_db} method takes in a list of \lstinline{Item}s whereas \lstinline{reviews_from_db} method takes in a list of \lstinline{Review}s, the overlapping keywords used in the TSLs do not cause any ambiguities and can be safely composed.

%
%\begin{figure}
%  \centering
%  \begin{lstlisting}
%val dashboardArchitecture : Architecture = ~
%    external component twitter : Feed
%        location www.twitter.com
%    external component client : Browser
%        connects to servlet
%    component servlet : DashServlet
%        connects to productDB, twitter
%        location intranet.nameless.com
%    component productDB : Database
%        location db.nameless.com
%    policy mainPolicy = ~
%        must salt servlet.login.password
%        connect * -> servlet with HTTPS
%        connect servlet -> productDB with TLS
%  \end{lstlisting}
%  \caption{Wyvern DSL: Architecture Specification}
%  \label{f:dsl-arch}
%\end{figure}
%
%We start with a few examples to illustrate the expressiveness of our approach and the breadth of DSLs we plan for it to support.  The examples are presented in the proposed syntax for Wyvern, a new language being developed by our group that is targeted toward building secure web and mobile applications. We will informally describe each of these examples here, and further explain how such code is parsed in Section \ref{s:approach}.
%
%The first example, shown in Figure~\ref{f:dsl-arch}, describes the overall architecture of a ``hot product dashboard'' application.  The variable \lstinline{dashboardArchitecture} is explicitly ascribed type \lstinline{Architecture}. Rather than explicitly providing a value of this type, we instead use a DSL that makes specifying the component architecture of the application more concise and readable. This DSL code appears in the subsequent whitespace-delimited block and is introduced by a tilde (\lstinline{~}). The example architecture declares several components, some of which are declared \keyw{external} to indicate that they are used by this application but are not part of it directly. Component types are declared after a colon and attributes like connectivity location, are declared after the type (formatted in an indented block for readability). 
%The \keyw{policy} keyword (line 11) introduces a security policy, which constrains the communication protocols that can be used and 
%enforces the secure handling of passwords. A separate type, \lstinline{Policy}, is associated with such policies. Although we could instantiate this type explicitly using a Wyvern expression, we use a DSL for defining policies instead, again within a whitespace-delimited block introduced by a tilde.
%
%\begin{figure}
%  \centering
%  \begin{lstlisting}
%val newProds = productDB.query(~)
%    select twHandle 
%    where introduced - today < 3 months
%val prodTwt = new Feed(newProds)
%return prodTwt.query(~)
%    select *
%    group by followed
%    where count > 1000
%  \end{lstlisting}
%  \caption{Wyvern DSL: Queries}
%  \label{f:dsl-query}
%\end{figure}
%
%Figure~\ref{f:dsl-query} shows how a DSL for database queries can be used from within ordinary Wyvern code.  The example shows code for computing a feed that is derived from tweets about a company's new products.  In this example, the use of a querying DSL is triggered by the use of methods named \lstinline{query} expecting an argument of type \lstinline{DBQuery} (line 1) or \lstinline{FeedQuery} (line 5) respectively.  These types define related but distinct syntax for queries, determined by the expected type of expression where the tilde appears (tildes need not appear only at the ends of lines). Queries are again delimited by indentation. This mechanism is similar to what can be expressed in languages with built-in query syntax like LINQ \cite{mslinq}, but in this case, it is entirely user-defined, rather than built into the language.\begin{figure}
%  \centering
%  \begin{lstlisting}
%serve(page, loc) where 
%  val page = ~ 
%    html:
%      head:
%        title: Hot Products
%        style: {myStylesheet}
%        body:
%          div id="search":
%            {SearchBox("products")}
%          div id="products":
%            {FeedBox(servlet.hotProds())}
%  val loc = ~
%    products.nameless.com
%  \end{lstlisting}
%  \caption{Wyvern DSLs: Presentation and URLs}
%  \label{f:dsl-presentation}
%\end{figure}
%
%Finally, Figure~\ref{f:dsl-presentation} shows a DSL for presenting the hot product application to a web browser, served at a particular URL. Here, two DSLs are used within a single function call. To allow this without introducing ambiguity, the user can use a \keyw{where} clause, similar to that found in Haskell \cite{jones2003haskell}. The presentation DSL is based on HTML and associated with a type, \lstinline{HTMLElement}. It uses an indentation-sensitive syntax and allows integration of Wyvern code of the appropriate type using curly braces. The second DSL simply canonicalizes URL literals into Wyvern values of type \lstinline{URL}.
