% !TEX root = ecoop14.tex

\section{Type-Specific Languages in Wyvern}
\label{s:motivation}

To motivate our work we show an example, which illustrates the expressiveness that our approach provides, and also present results of a small empirical study that looked into how current Java projects could  benefit from using TSLs.

\subsection{Motivating Example}

In this subsection, we show an example that demonstrates the key features of our approach. Here we give an informal explanation of the Wyvern language and the TSL-related constructs; a formal and more detailed description is to follow in the subsequent sections.


\begin{figure}
\begin{lstlisting}
serve(`products.nameless.com`, ~)
  :html
    :head
      :title Product Listing
      :style {~
        body { font-family: {bodyFont} }
      }
    :body
      :div[id="search"]
        {SearchBox("Products")}
      :ul[id="products"]
        {items_from_db(db, <SELECT * FROM products>)}
      :ul[id="reviews"]
        {reviews_from_db(db, <SELECT * FROM reviews WHERE location = {UserLocation}>)}
\end{lstlisting}
\caption{Wyvern Example}
\label{f-example}
\end{figure}

\todo{Alex says: Jumpting straight into the delimiter pairs for distinguishing TSL from GPL is confusing. However, maybe Introduction will help with this.}

One of the reasons that motivated our work is the aspiration to provide developers with a possibility to compose various language constructs together in a program in a simple intuitive way. Consider a piece of Wyvern code in Figure~\ref{f-example}. When executed, it produces a webpage that displays a bulleted list of products followed by a list of reviews, both retrieved from a database. Notably, this method is mere 14 lines long but comprises the host Wyvern language as well as 6 type-specific languages. Each of the TSLs is introduced either within a pair of delimiters (e.g., backticks (\lstinline{`}), quotation marks (\lstinline{"}), or matching angle brackets (\lstinline{<} and \lstinline{>})) or by a tilde (\lstinline{~}) on a preceding line. The escape back to the host language is also done with a use of a pair of delimiters (e.g., matching curly braces (\lstinline|{| and \lstinline|}|)). With this in mind, let us have a closer look at how the code on Figure~\ref{f-example} decomposes:

\begin{itemize}
\item As a first argument to the Wyvern \lstinline{serve} method, a URL TSL, delimited by backticks, is used (line 1);
\item The skeleton of the \lstinline{serve} method's body is written using an HTML TSL (lines 2-14), which was introduced by the tilde on line 1;
\item For the \lstinline{style} ``tag'' of the HTML code on line 5, containing a precursory tilde, a CSS TSL is used (line 6);
\item Inside the CSS TSL, the \lstinline{bodyFont} is a Wyvern variable, escaped by a matching pair of curly braces (line 6);
\item Inside the \lstinline{serve} method's HTML skeleton code, Wyvern code is used thrice: on line 10, to specify the content of the \lstinline{div} ``tag'' and, on lines 12 and 14, to produce two bulleted lists\textemdash every time the Wyvern code is delimited by curly braces;
\item When specifying the content for the \lstinline{div} ``tag,'' a Wyvern \lstinline{SearchBox} method is using a TSL for strings (in Wyvern, there is no built-in data structure to represent strings; they are implemented as TSLs) and the string ``Products,'' delimited by quotation marks, is passed in (line 10);
\item In the Wyvern \lstinline{items_from_db} method, the second argument is an SQL TSL (line 12), which is introduced by a matching pair of angle brackets and returns a list of \lstinline{Item}s;
\item In the Wyvern \lstinline{reviews_from_db} method, the second argument is another SQL TSL (line 14), which is also introduced within angle brackets but returns a list of \lstinline{Review}s;
\item Finally, the query provided to the Wyvern \lstinline{reviews_from_db} method contains a Wyvern variable \lstinline{UserLocation} which is escaped using a pair of matching curly braces (line 14).
\end{itemize}

Apart from the large number of TSL that can be composed together in a short piece of code and produce meaningful results, we aim at providing a safe composability guarantees that other language extension solutions don't (cf.~\cite{Erdweg:2013:FEL:2517208.2517210} \todo{more citations?}). For instance, in the above Wyvern code the SQL TSLs use similar syntax; however, since they are triggered by methods expecting different types of arguments, namely \lstinline{items_from_db} method takes in a list of \lstinline{Item}s whereas \lstinline{reviews_from_db} method takes in a list of \lstinline{Review}s, the overlapping keywords used in the TSLs do not cause any ambiguities and can be safely composed.


\subsection{Empirical Study}

To further motivate our approach, we performed an empirical study that examined potential usage of the proposed language composition mechanism. For this purpose, we looked at the recent version (20130901r) of 107 Java projects in the Qualitas Corpus~\cite{QualitasCorpus:APSEC:2010} and performed two analyses to see how TSLs could be used directly and indirectly. Our analyses' methodology and the results are described below.

\subsubsection{Methodology}

To perform our analyses, we used command line tools, such as \lstinline{grep} and \lstinline{sed}, and a VI editor features, such as search and substitution. In a semi-manual procedure, we scanned though the Java code and picked out class constructors. After that, we chose constructors that take at least one \lstinline{String} as an argument, and looking at the names of the constructors and their arguments, we inferred the intended use of the classes associated with them. The summarized results of our analysis are shown in Table~\ref{t-summary}.

\begin{table}
   \centering
    \begin{tabular}{l | c | c}
    \bf Constructors & \bf Number & \bf \% of Total \\ \hline
    Total analyzed & 125,048 & 100 \\
    Have a String argument & 30,190 & 24 \\
    Could be substituted by a TSL & 19,317 & 15 \\
    Could use a TSL & 0 & 0 \\
    \end{tabular}
    \vspace{0.15in}
    \caption{Summary of the Analyses Results}
    \label{t-summary}
\end{table}

\subsubsection{Direct Substitution with TSLs}

As the first part of our analysis of the Java projects, we looked into how developers could directly benefit  from using TSLs. To do that, we looked though the Java constructors and found those that could be substituted by a type. What we were looking for is the constructors such as:

\begin{lstlisting}
Path(String path) {...}
\end{lstlisting}

That is the constructors that take in a single \lstinline{String} argument, which must be of a specific format and which serves as a basis for the underlying class. In the example above, if it was to be written in Wyvern, the \lstinline{Path} class could be represented as a type called \lstinline{Path} with a \lstinline{parse} method that would verify the adherence to the necessary format.

Looking through the Java constructors, we found that there is x \% (y out of z examined constructors) which comply with this pattern. Those constructors were used for classes that represent URLs and URIs, identification numbers, versions, directory paths, and various types of names (e.g., user name, database name, column name, etc.).

\subsubsection{Potential Use of TSLs}

In the second part of our analysis, we continued examining the identified Java constructors, but this time we looked at the constructors that could benefit from the substitution of classes with TSLs, which we talked about in the previous subsection. In particular, we again looked at the constructors that take at least one \lstinline{String} argument that has to conform to a specific format but the \lstinline{String} argument is not the basis for the underlying class. For instance, constructors such as:

\begin{lstlisting}
FileUpdatedEvent(Object source, String path) {...}
\end{lstlisting}

Here, the second argument \lstinline{path}, which is of type \lstinline{String}, could be represented using a Wyvern type \lstinline{Path} that would guarantee that the passed in argument is of the required format.

\begin{table}
   \centering
    \begin{tabular}{l | c | c}
    \bf Type of String & \bf Number & \bf \% of Total \\ \hline
    Name & 14,330 & 74.2 \\
    ID	& 1,336 & 6.9 \\
    Directory path& 823 & 4.3 \\
    Pattern & 495 & 2.6 \\
    URL/URI & 398 & 2.1 \\
    Other & 1,935 & 10.0 \\ \hline
    \bf Total: & \bf 19,317 & \bf 100.0
    \end{tabular}
    \vspace{0.15in}
    \caption{Types of \lstinline{String} Arguments in Java Constructors}
    \label{t-strs-in-constrs}
\end{table}

Our analysis found that there is x \% (y out of z constructors) of this kind of constructors (see Table~\ref{t-summary}). More details on the kinds of \lstinline{String} arguments that are passed into constructors can be found in Table~\ref{t-strs-in-constrs}. The ``Name'' category refers to the name of a file, a user, a class, etc. that do not have to be unique; the ``ID'' category comprises process IDs, user IDs, column or row IDs, etc. that must have the uniqueness property; the ``Pattern'' category includes regular expressions, prefixes and suffixes, delimiters, format templates, etc.; the ``Other'' category contains \lstinline{String}s used for ZIP codes, passwords, queries, IP addresses, versions, HTML and XML code, etc.; and the ``Directory path'' and ``URL/URI'' categories are self-explanatory.

Hence, our empirical study has shown that there is at least x \% of Java constructors that have a potential of directly or indirectly taking advantage of TSLs. It is important to keep in mind that our analyses were fairly narrow: they focused exclusively on the constructors and thus forwent many other types of programming constructs, such as methods, variable assignments, etc., that could possibly also benefit from our approach.

%
%\begin{figure}
%  \centering
%  \begin{lstlisting}
%val dashboardArchitecture : Architecture = ~
%    external component twitter : Feed
%        location www.twitter.com
%    external component client : Browser
%        connects to servlet
%    component servlet : DashServlet
%        connects to productDB, twitter
%        location intranet.nameless.com
%    component productDB : Database
%        location db.nameless.com
%    policy mainPolicy = ~
%        must salt servlet.login.password
%        connect * -> servlet with HTTPS
%        connect servlet -> productDB with TLS
%  \end{lstlisting}
%  \caption{Wyvern DSL: Architecture Specification}
%  \label{f:dsl-arch}
%\end{figure}
%
%We start with a few examples to illustrate the expressiveness of our approach and the breadth of DSLs we plan for it to support.  The examples are presented in the proposed syntax for Wyvern, a new language being developed by our group that is targeted toward building secure web and mobile applications. We will informally describe each of these examples here, and further explain how such code is parsed in Section \ref{s:approach}.
%
%The first example, shown in Figure~\ref{f:dsl-arch}, describes the overall architecture of a ``hot product dashboard'' application.  The variable \lstinline{dashboardArchitecture} is explicitly ascribed type \lstinline{Architecture}. Rather than explicitly providing a value of this type, we instead use a DSL that makes specifying the component architecture of the application more concise and readable. This DSL code appears in the subsequent whitespace-delimited block and is introduced by a tilde (\lstinline{~}). The example architecture declares several components, some of which are declared \keyw{external} to indicate that they are used by this application but are not part of it directly. Component types are declared after a colon and attributes like connectivity location, are declared after the type (formatted in an indented block for readability). 
%The \keyw{policy} keyword (line 11) introduces a security policy, which constrains the communication protocols that can be used and 
%enforces the secure handling of passwords. A separate type, \lstinline{Policy}, is associated with such policies. Although we could instantiate this type explicitly using a Wyvern expression, we use a DSL for defining policies instead, again within a whitespace-delimited block introduced by a tilde.
%
%\begin{figure}
%  \centering
%  \begin{lstlisting}
%val newProds = productDB.query(~)
%    select twHandle 
%    where introduced - today < 3 months
%val prodTwt = new Feed(newProds)
%return prodTwt.query(~)
%    select *
%    group by followed
%    where count > 1000
%  \end{lstlisting}
%  \caption{Wyvern DSL: Queries}
%  \label{f:dsl-query}
%\end{figure}
%
%Figure~\ref{f:dsl-query} shows how a DSL for database queries can be used from within ordinary Wyvern code.  The example shows code for computing a feed that is derived from tweets about a company's new products.  In this example, the use of a querying DSL is triggered by the use of methods named \lstinline{query} expecting an argument of type \lstinline{DBQuery} (line 1) or \lstinline{FeedQuery} (line 5) respectively.  These types define related but distinct syntax for queries, determined by the expected type of expression where the tilde appears (tildes need not appear only at the ends of lines). Queries are again delimited by indentation. This mechanism is similar to what can be expressed in languages with built-in query syntax like LINQ \cite{mslinq}, but in this case, it is entirely user-defined, rather than built into the language.\begin{figure}
%  \centering
%  \begin{lstlisting}
%serve(page, loc) where 
%  val page = ~ 
%    html:
%      head:
%        title: Hot Products
%        style: {myStylesheet}
%        body:
%          div id="search":
%            {SearchBox("products")}
%          div id="products":
%            {FeedBox(servlet.hotProds())}
%  val loc = ~
%    products.nameless.com
%  \end{lstlisting}
%  \caption{Wyvern DSLs: Presentation and URLs}
%  \label{f:dsl-presentation}
%\end{figure}
%
%Finally, Figure~\ref{f:dsl-presentation} shows a DSL for presenting the hot product application to a web browser, served at a particular URL. Here, two DSLs are used within a single function call. To allow this without introducing ambiguity, the user can use a \keyw{where} clause, similar to that found in Haskell \cite{jones2003haskell}. The presentation DSL is based on HTML and associated with a type, \lstinline{HTMLElement}. It uses an indentation-sensitive syntax and allows integration of Wyvern code of the appropriate type using curly braces. The second DSL simply canonicalizes URL literals into Wyvern values of type \lstinline{URL}.
