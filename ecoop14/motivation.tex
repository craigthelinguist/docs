% !TEX root = ecoop14.tex
\section{Motivation}
\label{s:motivation}

To motivate our work we show an example, which illustrate the expressiveness that our approach provides, and also present results of a small empirical study that looked into how current Java projects could  benefit from using TSLs.

\subsection{Motivating Examples}
\begin{figure}
\begin{lstlisting}
serve(`products.nameless.com`, ~)
  :html
    :head
      :title Product Listing
      :style {~
        body { font-family: {bodyFont} }
      }
    :body
      :div[id="search"]
        {SearchBox("Products")}
      :ul[id="products"]
        {items_from_query(query(db,
           <SELECT * FROM products COUNT {n_products}>))} 
\end{lstlisting}
\caption{Wyvern Example}
\label{}
\end{figure}



\begin{figure}
\begin{lstlisting}
casetype HTML = 
    Text of String 
  | DIVElement of (Attributes, HTML)
  | ULElement  of (Attributes, HTML)
  | ...
  metaobject = new
    val parser : Parser = ~
      start ::= Ò:bodyÓ children=start => {~ 
                   HTML.BodyElement(([], `children`))
                } 
             | ...
             |  Ò:styleÒ Ò{Ò e=EXP[Ò}Ó] => {~
                   HTML.StyleElement(([], `e` : CSS))
                }
\end{lstlisting}
\caption{Wyvern Example Backend}
\label{}
\end{figure}

\begin{figure}
\begin{lstlisting}
objtype Parser = 
  def parse(s : TokenStream) : ExpAST
\end{lstlisting}
\caption{Wyvern objtype Parser}
\label{}
\end{figure}

\begin{figure}
\begin{lstlisting}
casetype ExpAST = 
  Var of ID 
| Lam of Var * ExpAST | Ap of Exp * Exp 
| CaseIntro of TyAST * String * ExpAST | ...
\end{lstlisting}
\caption{Wyvern casetype ExpAST}
\label{}
\end{figure}

\subsection{Empirical Study}

\cite{QualitasCorpus}

\subsubsection{Direct Substitution with TSLs}
\subsubsection{Benefits of Using TSLs}


%
%\begin{figure}
%  \centering
%  \begin{lstlisting}
%val dashboardArchitecture : Architecture = ~
%    external component twitter : Feed
%        location www.twitter.com
%    external component client : Browser
%        connects to servlet
%    component servlet : DashServlet
%        connects to productDB, twitter
%        location intranet.nameless.com
%    component productDB : Database
%        location db.nameless.com
%    policy mainPolicy = ~
%        must salt servlet.login.password
%        connect * -> servlet with HTTPS
%        connect servlet -> productDB with TLS
%  \end{lstlisting}
%  \caption{Wyvern DSL: Architecture Specification}
%  \label{f:dsl-arch}
%\end{figure}
%
%We start with a few examples to illustrate the expressiveness of our approach and the breadth of DSLs we plan for it to support.  The examples are presented in the proposed syntax for Wyvern, a new language being developed by our group that is targeted toward building secure web and mobile applications. We will informally describe each of these examples here, and further explain how such code is parsed in Section \ref{s:approach}.
%
%The first example, shown in Figure~\ref{f:dsl-arch}, describes the overall architecture of a ``hot product dashboard'' application.  The variable \lstinline{dashboardArchitecture} is explicitly ascribed type \lstinline{Architecture}. Rather than explicitly providing a value of this type, we instead use a DSL that makes specifying the component architecture of the application more concise and readable. This DSL code appears in the subsequent whitespace-delimited block and is introduced by a tilde (\lstinline{~}). The example architecture declares several components, some of which are declared \keyw{external} to indicate that they are used by this application but are not part of it directly. Component types are declared after a colon and attributes like connectivity location, are declared after the type (formatted in an indented block for readability). 
%The \keyw{policy} keyword (line 11) introduces a security policy, which constrains the communication protocols that can be used and 
%enforces the secure handling of passwords. A separate type, \lstinline{Policy}, is associated with such policies. Although we could instantiate this type explicitly using a Wyvern expression, we use a DSL for defining policies instead, again within a whitespace-delimited block introduced by a tilde.
%
%\begin{figure}
%  \centering
%  \begin{lstlisting}
%val newProds = productDB.query(~)
%    select twHandle 
%    where introduced - today < 3 months
%val prodTwt = new Feed(newProds)
%return prodTwt.query(~)
%    select *
%    group by followed
%    where count > 1000
%  \end{lstlisting}
%  \caption{Wyvern DSL: Queries}
%  \label{f:dsl-query}
%\end{figure}
%
%Figure~\ref{f:dsl-query} shows how a DSL for database queries can be used from within ordinary Wyvern code.  The example shows code for computing a feed that is derived from tweets about a company's new products.  In this example, the use of a querying DSL is triggered by the use of methods named \lstinline{query} expecting an argument of type \lstinline{DBQuery} (line 1) or \lstinline{FeedQuery} (line 5) respectively.  These types define related but distinct syntax for queries, determined by the expected type of expression where the tilde appears (tildes need not appear only at the ends of lines). Queries are again delimited by indentation. This mechanism is similar to what can be expressed in languages with built-in query syntax like LINQ \cite{mslinq}, but in this case, it is entirely user-defined, rather than built into the language.\begin{figure}
%  \centering
%  \begin{lstlisting}
%serve(page, loc) where 
%  val page = ~ 
%    html:
%      head:
%        title: Hot Products
%        style: {myStylesheet}
%        body:
%          div id="search":
%            {SearchBox("products")}
%          div id="products":
%            {FeedBox(servlet.hotProds())}
%  val loc = ~
%    products.nameless.com
%  \end{lstlisting}
%  \caption{Wyvern DSLs: Presentation and URLs}
%  \label{f:dsl-presentation}
%\end{figure}
%
%Finally, Figure~\ref{f:dsl-presentation} shows a DSL for presenting the hot product application to a web browser, served at a particular URL. Here, two DSLs are used within a single function call. To allow this without introducing ambiguity, the user can use a \keyw{where} clause, similar to that found in Haskell \cite{jones2003haskell}. The presentation DSL is based on HTML and associated with a type, \lstinline{HTMLElement}. It uses an indentation-sensitive syntax and allows integration of Wyvern code of the appropriate type using curly braces. The second DSL simply canonicalizes URL literals into Wyvern values of type \lstinline{URL}.
