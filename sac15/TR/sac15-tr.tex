\documentclass[12pt]{article}
\usepackage{fullpage,cmu-titlepage2}
\usepackage{times}

\usepackage{listings}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{latexsym}

\usepackage{verbatim}
\usepackage[T1]{fontenc}
%\usepackage[defaultmono]{droidmono}
\usepackage{proof,amssymb,enumerate}
\usepackage{math-cmds}
\usepackage{listings}
\usepackage{placeins}
%\setcounter{tocdepth}{3}
%\renewcommand*\ttdefault{txtt}
\usepackage[scaled]{beramono}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{graphicx}
\usepackage{url}
\usepackage{bussproofs}
\usepackage{stackengine}
\usepackage{verbatim}
\usepackage{enumitem}
\usepackage[english]{babel}
\EnableBpAbbreviations

\newcommand\BeraMonottfamily{%
  \def\fvm@Scale{0.85}% scales the font down
  \fontfamily{fvm}\selectfont% selects the Bera Mono font
}

\lstdefinestyle{wyvern}{
%backgroundcolor=\color{highlight}, % Set the background color for the snippet - useful for highlighting
basicstyle=\scriptsize\BeraMonottfamily, % The default font size and style of the code
breakatwhitespace=false, % If true, only allows line breaks at white space
breaklines=true, % Automatic line breaking (prevents code from protruding outside the box)
captionpos=b, % Sets the caption position: b for bottom; t for top
morecomment=[s]{(*}{*)},
commentstyle=\fontshape{it}\color{Gray}\selectfont, % Style of comments within the code - dark green courier font
deletekeywords={}, % If you want to delete any keywords from the current language separate them by commas
%escapeinside={\%}, % This allows you to escape to LaTeX using the character in the bracket
firstnumber=1, % Line numbers begin at line 1
frame=lines, % Frame around the code box, value can be: none, leftline, topline, bottomline, lines, single, shadowbox
frameround=tttt, % Rounds the corners of the frame for the top left, top right, bottom left and bottom right positions
keywords=[1]{new, objtype, type, casetype, val, def, metadata, syntax, of, fn, typekw, with, let, tyfn, for},
keywordstyle={[1]\bfseries},
keywordstyle={[3]\color{red!80!orange}},
morekeywords={}, % Add any functions no included by default here separated by commas
numbers=left, % Location of line numbers, can take the values of: none, left, right
numbersep=8pt, % Distance of line numbers from the code box
numberstyle=\tiny\color{Gray}, % Style used for line numbers
rulecolor=\color{black}, % Frame border color
showstringspaces=false, % Don't put marks in string spaces
showtabs=false, % Display tabs in the code as lines
stepnumber=1, % The step distance between line numbers, i.e. how often will lines be numbered
tabsize=4, % Number of spaces per tab in the code
}
\lstset{basicstyle=\footnotesize,breaklines=true}
\lstset{escapeinside={@}{@}}


%\usepackage{mathtools}
\newcommand{\todo}[1]{{\bf \{TODO: {#1}\}}}
\newcommand{\keyw}[1]{\textbf{#1}}
\newcommand{\T}{\mathtt{T}}
\newcommand{\flyingbox}[1]{\fbox{{#1}}}
\newcommand{\myvdash}{\vdash_{\Theta}^{\Psi}}
\newcommand{\doublebox}[2]{\begin{flushleft}\fbox{{#1}}\ \fbox{{#2}}\end{flushleft}}
\newcommand{\textcd}[1]{\textbf{\footnotesize\BeraMonottfamily{#1}}}
\newcommand{\textsp}[1]{\text{\footnotesize\BeraMonottfamily{#1}}}
\newcommand{\mycaption}[1]{\caption{#1}}
\newcommand{\tabularspace}{~~~~~}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}

\title{Composable and Hygienic Typed Syntax Macros (Technical Reports)}

\author{Cyrus Omar \and Chenglong Wang \and Jonathan Aldrich}

\date{\today}

\abstract{
  We present additional details on our static semantics that were omitted from the main body of the paper \emph{Composable and Hygienic Typed Syntax Macros} for concision.
}

\keywords{extensible syntax; macros; hygiene; type inference}

\trnumber{\todo{TR number}}

%\citationinfo{}

%\arpasupport{fox}
\support{\todo{acknowledgement}}
% \authorsupport{The author holds a Froboz Gradual Fellowship.}

% \otherdisclaimer{NSF}

\begin{document}
\renewcommand*{\thepage}{title-\arabic{page}} 
\maketitle
\renewcommand*{\thepage}{\arabic{page}} 
\appendix

\section{Core TSM Syntax \& Semantics}\label{theory}
For readability consideration, before we introduce the full formal definition, we first introduce the core syntax and semantics for TSMs with explanations.

TSMs are building directly upon the calculus for TSLs in Wyvern presented previously by Omar et al. \cite{TSLs}.
The abstract syntax corresponding to the concrete syntax is shown in Figures \ref{formal-syntax} and \ref{syntax-types}. A \emph{program}, $\rho$, consists of a series of declarations, $ d$, followed by a single external term, $e$. In practice, the declarations would be imported from separate packages, but we omit details of the package system here for simplicity. The top-level judgement in the system is the compilation judgement:
$$\AXC{$d\sim(\Psi;\Theta)$ ~~~~ $\emptyset;\emptyset\vdash_{\Theta_0\Theta}^{\Psi}e\rightsquigarrow i\Rightarrow \tau$}      \RightLabel{(compile)}
\UIC{$ d;e\sim(\Psi;\Theta)\rightsquigarrow i:\tau$}
\DP$$

%The syntax for the contexts used in these judgements is shown in Figure \ref{typechecking-environment}. The main rules defining these judgements  are shown in Figures \ref{typechecking-elaboration} through \ref{expkw-kwstatics}. %For simplicity, we do not formalize Wyvern's mechanisms for parameterized types and type members here. 

A series of declarations, $d$, consists of TSM declarations and named type declarations. The judgement $d \sim (\Psi, \Theta)$, defined in Figure \ref{typechecking-elaboration}, generates a corresponding TSM context, $\Psi$, and named type context, $\Theta$, from $d$. The syntax for these contexts is given in Figure \ref{typechecking-environment}. We refer to the type declarations in the prelude, some of which were shown in Fig. \ref{exp-prelude}, by using the named type context $\Theta_0$ in our rules.


Judgements $\Delta; \Gamma \vdash_\Theta^\Phi e \leadsto i \Rightarrow \tau$ and  $\Delta; \Gamma \vdash_\Theta^\Phi e \leadsto i \Leftarrow \tau$ can be read ``under kinding context $\Delta$, typing context $\Gamma$, named type context $\Theta$ and TSM context $\Phi$, external term $e$ elaborates to internal term $i$ and (synthesizes / analyzes against) type $\tau$''. This is a \emph{bidirectionally typed elaboration semantics}, used to elaborate TSL literals and TSM applications, which appear only in the external language, to an internal language, which includes only the core operations in the language. The semantics follows that given in \cite{TSLs}, so we do not repeat the rules for the core operations or TSL literals. The rules for the only new form, $\textbf{eaptsm}[s, body]$, are given in Figure \ref{expkw-kwstatics} and described below.

\subsection{Term-Level TSMs}

\newcommand{\mytab}{~~~~~~~~~~~}

\begin{figure}[t]
\hspace{-5px}$\begin{array}{rll}
      &\textbf{Abstract Forms}   & \textbf{Concrete Forms}\\
      \text{Programs}		&	\rho~::=~ d;e\\
      \text{Declarations}	&	d~::=~\emptyset\\
      						&	\mytab d;\mathbf{syntsm}(s,\tau,e)    & \textcd{syntax}~s : \tau~\textcd{=}~e\\
      						&	\mytab d;\mathbf{anatsm}(s,e)          & \textcd{syntax}~s~\textcd{=}~e\\
      						&	\mytab d;\mathbf{tytsm}(s,\kappa, \tau, e) & \textcd{syntax}~s::\kappa~\textcd{with metadata:}\tau\,\textcd{=}\,e\\
      						& 	\mytab d; \mathbf{tydecl}(\mathtt{T}, \tau, e)  & \textcd{type}~\mathtt{T}~\textcd{=}~\tau\\
                            & 	\mytab ~~~\textcd{metadata = }e\\
      						& 	\mytab d; \mathbf{tyaptsm}(\mathtt{T}, s, body, e)   & \textcd{type}~\mathtt{T}~\textcd{=}~\mathit{s~dform}\\
                            & 	\mytab ~~~\textcd{metadata }e\\
%      \text{Object Fields}\\
%      \omega~::=~\emptyset                      \\
%      \tabularspace l[\mathbf{val},\tau];\omega                 & \textcd{val}~l : \tau\\
%      \tabularspace l[\mathbf{def},\tau];\omega                 & \textcd{def}~l : \tau\\
%      \text{Casetype Cases}\\
%      \chi~::=~\emptyset                      \\                 
%      \tabularspace C[\tau];\chi                   & C~\textcd{of}~\tau\\
      \text{External Terms}	&	e~::= ...                              & \\
      &	\mytab\mathbf{lit}[body]             & \mathit{dform}\\
      &	\mytab\mathbf{eaptsm}[s,body]       & \mathit{s~dform}\\
      \text{Translational Terms}	& \hat{e}~::= ... \\
      								&\mytab\mathbf{spliced}[e] \\
      \text{Internal Terms}			& i~::= ...
  \end{array}$
\mycaption{Abstract and concrete forms for declarations and terms. Metavariable $s$ ranges over TSM names, $\mathtt{T}$ over type names, $dform$ over delimited forms, per Figure \ref{f-delimited}, and $body$ over their bodies. Translational and internal terms are used in the semantics only. Elided forms are given in \cite{TSLs}.}
\label{formal-syntax}
\end{figure}


\begin{figure}[t]
\[
	\begin{array}{llcl}
      \text{Kinds}\\
      \mytab	\kappa ::=  \star  ~|~ \kappa \rightarrow \kappa\\
      \text{Types}\\
      \mytab	 \tau  ::=  \mathtt{T} ~|~ \tau \rightarrow \tau ~|~ \mathbf{objtype}[\omega] ~|~ \mathbf{casetype}[\chi] ~|~  t ~|~ \lambda[\kappa](t.\tau) ~|~ \tau(\tau) \\
      \text{Translational Types}\\
      \mytab\hat{\tau} ~ ::= ... ~|~ \mathbf{spliced}[\tau]
  \end{array}
\]
\mycaption{Syntax for types and kinds. Metavariable $t$ ranges over type variables. Object type and case type declarations $\omega$ and $\chi$ are taken from \cite{TSLs}.
%Metavariable $T$ ranges over type names, $l$ over member labels, $C$ over case names, $x$ over term variables, $X$ over type variables.
}\label{syntax-types}
\end{figure}



\begin{figure}[t]
\[\begin{array}{l}
      \text{TSM Contexts}\\
      \mytab\Psi ::= \emptyset ~|~ \Psi, s[\mathbf{ty}(\kappa,\tau, i)] ~|~ \Psi, s[\mathbf{syn}(\tau,i)] ~|~ \Psi, s[\mathbf{ana}(i)]\\
      \text{Named Type Contexts}\\
      \mytab\Theta ::= \emptyset~|~\Theta, \mathtt{T}[\tau :: \kappa,i : \tau]\\
      \text{Typing Contexts}\\
      \mytab\Gamma ::= \emptyset ~|~ \Gamma, x : \tau\\
      \text{Kinding Contexts}\\
      \mytab\Delta ::= \emptyset ~|~ \Delta,t::\kappa
\end{array}
\]
\mycaption{Syntax for contexts.}\label{typechecking-environment}
\end{figure}
The rule (D-syntsm) shows how a synthetic TSM named $s$, synthesizing type $\tau$ and implemented by $e_{tsm}$ is declared. The rule first recursively checks the preceding declarations, then ensures that no other TSM named $s$ was declared  (we treat contexts as finite mappings and write, e.g., $\text{dom}(\Psi)$ to be the domain of $\Psi$). Then, it checks that $\tau$ is a closed type by checking that it's kind is $\star$ in an empty kinding context. Kinding contexts are simply mappings from type variables to kinds and the key kinding rules are shown in Figure \ref{kinding}. We will return to them when discussing type declarations below. Finally, $e_{tsm}$ is analyzed against  $\mathtt{Parser}(\mathtt{Exp})$, defined in the prelude. It must be a closed term, so the kinding and typing contexts are empty (it can use the named types and TSMs declared previously, however). Once these checks are complete, the definition of $s$ is added to $\Psi$. The rule for analytic TSM declarations, (D-anatsm), is nearly identical, differing only in that no kind check is needed.

Term-level TSM application is captured by the abstract form $\textbf{eaptsm}[s, body]$, where $s$ is the name of the TSM and $body$ is the body of the delimited form, per Sec. \ref{tsms-term}. The rule (T-syn) shows how typing and elaboration for a synthetic TSM proceeds. First, the definition of $s$ is extracted from $\Psi$. Then, a parse stream is constructed on the basis of $body$. We assume the relation $\textsf{parsestream}(body)=i_{ps}$ is defined such that $i_{ps}$ is a closed term of type $\mathtt{ParseStream}$. Then, the $parse$ method of the TSM implementation is invoked with the parse stream. The judgement $i \Downarrow i'$ captures evaluation of $i$ to a value, $i'$. Our internal language is identical to that in \cite{TSLs}, so we omit the rules. As suggested by the declarations in Figure \ref{exp-prelude}, the result is either a parse error or a valid parse, written $OK(i_{exp})$, where $i_{exp}$ is a value of type $\mathtt{Exp}$. Here, we simply leave the error case undefined -- the typing judgement cannot be derived if there is a parse error.% -- though in practice, the compiler would report errors that occurred. 

The \emph{dereification judgement} $i \uparrow \hat{e}$, defined in \cite{TSLs}, takes a value of type \verb|Exp| to a corresponding \emph{translational term}, $\hat{e}$. 
Translational terms mirror external terms but include an additional form, $\textbf{spliced}[e]$, which captures portions of the parse stream parsed as a spliced term. The case \verb|Spliced| of case type \verb|Exp|, which takes a (portion of) a parse stream, dereifies to this form. This permits us to ensure that only spliced portions of parse streams can refer to variables in the surrounding scope (and no others), ensuring that hygiene is maintained. 

This is technically accomplished by the judgements \[\Delta_{out}; \Gamma_{out}; \Delta; \Gamma \vdash_{\Theta}^{\Psi} \hat{e} \leadsto i {\Rightarrow}{(\Leftarrow)} \tau\]  which can be read ``under outer typing and kinding contexts $\Delta_{out}$ and $\Gamma_{out}$ and inner typing and kinding contexts $\Delta$ and $\Gamma$,  $\hat{e}$ elaborates to internal term $i$ and (synthesizes/analyzes against) type $\tau$''. These judgements behave identically to the corresponding judgements for external terms, using the inner typing and kinding contexts, until a term of the form $\textbf{spliced}[e]$ is encountered. The outer contexts are then used. The relevant rule can be found in \cite{TSLs}, and an analagous type-level rule will be shown below. 
In the rules for TSLs and TSMs, (T-syn) and (T-ana), the inner contexts begin empty so only variables inside spliced terms can refer to outer variables. A \verb|parse| function that generated, for example, \verb|Var('x')|, would not typecheck, because it captures a variable that it cannot know exists. An occurrence of a variable \verb|x| inside a spliced portion (e.g. between \verb|<{| and \verb|}>| when using the \verb|HTML| TSL) would be checked in the outer context and thus be acceptable. Parse streams cannot be created manually, so this guarantee is strict. %The details of this mechanism at the term level are essentially identical (up to the orthogonal addition of parameterized types) to that in \cite{TSLs}, so we omit the rules.

In the rule (T-syn), the type that $\hat{e}$ is being analyzed against is determined by the definition of the TSM. The rule (T-ana) is essentially identical, but the type is determined by the type that the whole application is being analyzed against instead, consistent with the descriptions in Sec. \ref{tsms-term}. 


\subsection{Type Declarations}\label{declarations}
\input{kw-elaboration.tex}

\input{kw-statics.tex}

\begin{figure}[ht]
\flyingbox{$\Delta\vdash_{\Theta}\tau::\kappa$}
\begin{center}
\AXC{$t::\kappa\in\Delta$}
\UIC{$\Delta\vdash_{\Theta} t::\kappa$}
%%
\AXC{$\Delta\vdash_{\Theta}\tau_1::\kappa \rightarrow \kappa'$ ~~~~ $\Delta\vdash_{\Theta}\tau_2::\kappa$}
\UIC{$\Delta\vdash_{\Theta}\tau_1(\tau_2)::\kappa'$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\Delta,t::\kappa\vdash_{\Theta}\tau::\kappa'$}
\UIC{$\Delta\vdash_{\Theta}\lambda[\kappa](t.\tau)::\kappa\rightarrow \kappa'$}
%%
\AXC{$T[\tau :: \kappa, i_{md} : \tau_{md}]\in\Theta$}
\UIC{$\Delta\vdash_{\Theta} \mathtt{T}::\kappa$}
\noLine
\BIC{}
\DP
\end{center}
\mycaption{Kinding (object and case types follow \cite{TSLs})}
\label{kinding}
\end{figure}


The rule (D-tydecl) shows how explicit named type declarations (those which do not apply a type-level TSM) work. First, the preceding declarations are processed and we ensure that no other type named $T$ was declared. Then, we need that the type $\tau$ has arrow kind $\kappa \rightarrow \kappa$ where $\kappa$ is the kind of type being declared, e.g. $\kappa = \star \rightarrow \star$ for \verb|List|. The reason for this is to support recursive named types, e.g. 

\begin{lstlisting}[style=wyvern]
type List(T) = casetype
  Nil
  Cons of T * List(T)
\end{lstlisting}
\noindent
desugars to a type-level function taking in a self reference before returning a type-level function accepting the type parameter and returning the case type being declared:

\begin{lstlisting}[style=wyvern]
type List = tyfn(List::* -> *) => tyfn(T::*) => casetype 
  Nil 
  Cons of T * List(T)
\end{lstlisting}

Before being added to the named type context, the named type constructor $\mathtt{List}$ is substituted for the type variable $List$ via type-level function application, $\tau(\mathtt{T})$, as can be seen in the conclusion of the rule. Non-recursive types can simply ignore the ``self reference'' argument.

We do not formalize mutually recursive types here, though they follow the same pattern (taking $n$ arguments rather than just one). The full rules can be found in the appendix. Note also that we do not explicitly check for cyclic type definitions. Standard syntactic constraints can be imposed to rule these out. 

The final premise of (D-tydecl) synthesizes a type for the metadata. Metadata can use  the type declaration, but not recursively refer to its own metadata yet so we write a dash for a dummy metadata value.

Figure \ref{kinding} shows that named types have the kind of their underlying type-level term. Parameterized types can thus be applied to parameters like type-level functions.

\subsection{Type-Level TSMs}

\begin{figure}[t]
\flyingbox{$\Delta;\Delta\vdash_{\Theta}\hat{\tau}\rightsquigarrow \tau::\kappa$}
%\vspace{-6px}
\begin{center}
\AXC{$\Delta_{out}\vdash_{\Theta} \tau ::\kappa$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta}\mathbf{spliced}[\tau]\rightsquigarrow \tau::\kappa$}
%%%
\AXC{$t::\kappa\in\Delta$}
\UIC{$\Delta_{out}; \Delta\vdash_{\Theta} t::\kappa$}
%%%

\noLine
\BIC{}
\DP
\end{center}
\begin{center}

\AXC{$\Delta_{out}; \Delta,t::\kappa\vdash_{\Theta}\hat\tau\rightsquigarrow\tau::\kappa'$}
\UIC{$\Delta_{out}; \Delta\vdash_{\Theta}\lambda[\kappa](t.\hat\tau)\rightsquigarrow\lambda[\kappa](t.\tau)::\kappa\rightarrow \kappa'$}
\DP
\end{center}
\mycaption{Translational Kinding. Remaining rules are directly analagous to those for $\tau$ in Figure \ref{kinding}.}
\label{tr-kinding}
\end{figure}
Rule (D-tytsm) declares a type-level TSM $s$ that generates a type of kind $\kappa$ with metadata of type $\tau_{md}$ and an implementation $e_{tsm}$. The metadata type is checked to ensure that it is a type and the implementation is checked against type $\mathtt{Parser}(\mathtt{Type} \times \tau_{md})$, consistent with the explanation in Section \ref{tsms-type}. Note that we assume product types can be encoded as object types for simplicity in our calculus. This information is recorded in the TSM context, $\Psi$.

Rule (D-aptsm) shows how type-level TSMs are applied. If the result of the \verb|parse| method is $OK((i_{type}, i_{md}))$, then we dereify $i_{type}$ to a \emph{translational type}, $\hat{\tau}$. These are analagous to translational terms, $\hat{e}$, and serve to ensure hygiene at the level of types. The judgement $\Delta_{out}; \Delta \vdash_{\Theta} \hat{\tau} \leadsto \tau :: \kappa$ can be read ``under outer kinding context $\Delta_{out}$, inner kinding context $\Delta$ and named type context $\Theta$, translational type $\hat\tau$ elaborates to type $\tau$ at kind $\kappa$''. The syntax of translational types mirrors that of types, again with the addition of a form capturing spliced type-level terms arising from the parse stream, $\textbf{spliced}[\tau]$. The rules related to type variables and spliced forms are shown in Figure \ref{tr-kinding}. Only spliced types are checked under the outer context. 

As with type declarations, in (D-aptsm) we need that $\hat{\tau}$ has kind $\kappa \rightarrow \kappa$ to support recursive types (in the example in Sec. \ref{tsms-type}, we omitted this because in practice, the mechanism inserts it by default for non-recursive types). The outer kinding context here is initially empty because we do not formalize nested type declarations for simplicity, but in practice it would be the kinding context coming from any outer declarations. 

The remaining two premises of (D-aptsm) check that the metadata transformation is a function of the right type and invoke it to produce the final metadata (per Sec. \ref{tsms-type}). An identity function would be generated automatically when one is not explicitly provided by the user.

\section{Full Syntax \& Semantics}
In this section, we present how TSMs and TSLs works with the full definition, including syntax and semantic rules.

Besides the full syntax and semantics for the core-TSM mechanism, we also include the definitions of two mechanisms we left in the main body for concision: 1) the support for mutually recursive type declarations, which enables users to define mutually recursive types using type-TSMs and 2) how to access a TSM definition programatically at run-time in this section, which is useful to explicitly call the same parser as is used by the type-checker for TSM invocations.
\subsection{Syntax}
\[
\begin{array}{rlrlrl}
  \rho    ~::=&~ {d};e\\        
  {d}   ~::=&~ \emptyset                  & \kappa      ~::=& \star 					&   \theta  ~::=& \emptyset\\
        | ~ &~ {d}; \mathbf{syntsm}(s,\tau,e)     &   | ~ & \kappa\rightarrow\kappa 	&	        | ~ & \theta,\mathbf{tydecl}(\T,\tau,e)\\
        | ~ &~ {d}; \mathbf{anatsm}(s,e)        	&	&								&	        | ~ & \theta,\mathbf{tyaptsm}(\T,s,body,e)\\
        | ~ &~ {d};\mathbf{tytsm}(s,n,\kappa,\tau,e)   & n ~ ::= &1 ~|~ n + 1     \\
%       | ~ &~ {d};\mathbf{tydecl}(\T,\tau,e)     \\
        | ~ &~{d};\mathbf{mrectydecl}(\theta)\\
%       | ~ &~ {d};\mathbf{tyaptsm}(\T,s,body,e)\\
  \tau    ~::=&~ \T       &\hat{\tau} ~::=&~ \T 										&\omega ~::=&~   \emptyset\\
        |~  & ~ \mathbf{objtype}[\omega]    &|~ &~ \mathbf{objtype}[\omega]       		&|~&    ~l[\mathbf{val}, \tau];\omega\\
        |~  & ~ \mathbf{casetype}[\chi]     &|~ &~ \mathbf{casetype}[\chi]        		&|~&  ~l[\mathbf{def}, \tau];\omega\\
        |~  & ~ \tau\rightarrow\tau       &|~ &~ \hat\tau\rightarrow\hat\tau  			&\hat{\omega} ~::=&~ \emptyset\\
        |~  & ~ t               &|~ &~ t                  								&|~ & ~l[\mathbf{val}, \hat\tau];\hat\omega\\
        |~  & ~ \lambda[\kappa](t.\tau)     &|~ &~ \lambda[\kappa](t.\hat{\tau})		&|~ & ~l[\mathbf{def}, \hat\tau];\hat\omega\\
        |~  & ~ \forall(t.\tau)       &|~ &~ \forall(t.\hat{\tau})						&\chi       ~::=&~  \emptyset\\
        |~  & ~ \tau(\tau)            &|~ &~ \hat{\tau}(\hat{\tau})						&|~&  ~C[\tau];\chi               \\
        |~  & ~ \tau \times \tau        &|~ &~ \hat{\tau}\times\hat{\tau}				&\hat\chi ~::=&~  \emptyset\\
            &                 &|~ &~ \mathbf{spliced}[\tau]								&|~&  ~C[\hat\tau];\hat{\chi}\\
  e       ~::=&~ x                &\hat{e}  ~::=&~  x                     & i     ~::=&~  x\\
        | ~ &~ \mathbf{easc}[\tau](e)     &       | ~ &~  \mathbf{hasc}[\hat\tau](\hat{e})    &       | ~ &~  \mathbf{iasc}[\tau](\dot{e})\\
        | ~ &~ \mathbf{elet}(e; x.e)        &       | ~ &~  \mathbf{hlet}(\hat{e}; x.\hat{e})   &       | ~ &~  \mathbf{ilet}(i;x.i)\\
        | ~ &~ \mathbf{elam}(x.e)           &       | ~ &~  \mathbf{hlam}(x.\hat{e})        &       | ~ &~  \mathbf{ilam}(x.i)\\
%        | ~ &~ \mathbf{etylam}[\kappa](t.e)     &       | ~ &~  \mathbf{htylam}[\kappa](t.\hat{e})    &       | ~ &~  \mathbf{itylam}[\kappa](t.i)\\
        | ~ &~ \mathbf{eap}(e;e)          &       | ~ &~  \mathbf{hap}(\hat{e};\hat{e})     &       | ~ &~  \mathbf{iap}(i;i)\\
        | ~ &~ \mathbf{enew}(m)           &       | ~ &~  \mathbf{hnew}(\hat{m})          &       | ~ &~  \mathbf{inew}(\dot{m})\\
        | ~ &~ \mathbf{eprj}[l](e)          &       | ~ &~  \mathbf{hprj}[l](\hat{e})       &       | ~ &~  \mathbf{iprj}[l](i)\\
        | ~ &~ \mathbf{einj}[C](e)          &       | ~ &~  \mathbf{hinj}[C](\hat{e})       &       | ~ &~  \mathbf{iinj}[C](i)\\
        | ~ &~ \mathbf{ecase}(e)\{r\}         &       | ~ &~  \mathbf{hcase}(\hat{e})\{\hat{r}\}    &       | ~ &~  \mathbf{icase}(i)\{\dot{r}\}\\
        | ~ &~ \mathbf{etoast}(e)           &       | ~ &~  \mathbf{htoast}(\hat{e})        &       | ~ &~  \mathbf{itoast}[i]\\
        | ~ &~ \mathbf{emetadata}[\T]         &       | ~ &~  \mathbf{hmetadata}[\T]\\
        | ~ &~ \mathbf{etsmdef}[s]        &       | ~ &~  \mathbf{htsmdef}[s]\\
        | ~ &~ \mathbf{lit}[body]       &       | ~ &~  \mathbf{spliced}[e]\\
        | ~ &~ \mathbf{eaptsm}[s,body]\\
  m       ~::=&~ \emptyset            &\hat{m}  ~::=&~ \emptyset                &\dot{m}  ~::=&~ \emptyset\\
        | ~ &~ \mathbf{eval}[l](e);m      &     | ~ &~ \mathbf{hval}[l](\hat{e});\hat{m}    &     | ~ &~ \mathbf{ival}[l](i);\dot{m}\\
        | ~ &~ \mathbf{edef}[l](x.e);m      &     | ~ &~ \mathbf{hdef}[l](x.\hat{e});\hat{m}    &     | ~ &~ \mathbf{idef}[l](x.i);\dot{m}\\
  r       ~::=&~ \emptyset            &\hat{r}  ~::=&~ \emptyset                &\dot{r}  ~::=&~ \emptyset\\
        | ~ &~ \mathbf{erule}[C](x.e);r     &       | ~ &~ \mathbf{hrule}[C](x.\hat{e});\hat{r}   &     | ~ &~ \mathbf{irule}[C](x.i);\dot{r}
\end{array}
\]


In the type checking and elaboration rules, we use certain concrete forms for simplicity and readability consideration. For example, field projection out of an object is written abstractly $\mathbf{iprj}[l](i)$, but we present it in its concrete form $i.l$ in the rules. Function application, written $i(i)$, is abstractly written $\mathbf{iap}(i;i)$. Introducing a value of a case type is written $[C](i)$, but abstractly is written $\mathbf{iinj}[C](i)$ (''injection'', following standard terminology for sum types). Note also that in \cite{TSLs},  named types were written $\mathbf{named}[T]$ but for concision here we simply use typewriter font, $\mathtt{T}$. We also include polymorphic function types in the syntax for completeness, assuming a standard mechanism supporting higher-rank polymorphism so that we do not need explicit type abstraction and application at the term level, though we do not formalize it here.

\subsection{Contexts}
\[
\begin{array}{rrl}
\text{TSM Context}  & \Psi  ~::=&~  \emptyset\\
            &     | ~ &~  \Psi;s[\mathbf{ty}(n,\kappa,\tau,i)]\\
            &     | ~ &~  \Psi;s[\mathbf{syn}(\tau,i)]\\
            &     | ~ &~  \Psi;s[\mathbf{ana}(i)]\\
\text{Named Type Context}   & \Theta  ~::=&~ \emptyset\\
            &     | ~ &~ \Theta,\T[\tau::\kappa,i:\tau] \\
\text{Typing Context} & \Gamma  ~::=&~ \emptyset\\
            &     | ~ &~ \Gamma,x:\tau\\
\text{Kinding Context}  &   \Delta  ~::=&~ \emptyset\\
            &       | ~ &~ \Delta,t::\kappa\\
\end{array}
\]
\subsection{Type Checking and Elaboration}
\par
\flyingbox{$\rho \sim (\Psi;\Theta)\rightsquigarrow i:\tau$}
\begin{center}
\AXC{$d\sim(\Psi;\Theta)$ ~~~~ $\emptyset;\emptyset\vdash_{\Theta_0\Theta}^{\Psi}e\rightsquigarrow i\Rightarrow \tau$}      \RightLabel{(compile)}
\UIC{$d;e\sim(\Psi;\Theta)\rightsquigarrow i:\tau$}
\DP
\end{center}

\flyingbox{$d\sim (\Psi;\Theta)$}
\begin{center}
\AXC{} \RightLabel{(D-empty)}
\UIC{$\emptyset \sim (\emptyset;\emptyset)$} 
\DP
\end{center}

\begin{center}

\AXC{
	\stackanchor
	{$d\sim(\Psi;\Theta)$ ~~~~ $s\notin\text{dom}(\Psi)$ ~~~~ $\emptyset\vdash_{\Theta_0\Theta}\tau::\star$}
  	{$\emptyset;\emptyset\vdash_{\Theta_0\Theta}^{\Psi}e_{tsm}\rightsquigarrow i_{tsm} \Leftarrow \mathtt{Parser(Exp)}$}
}\RightLabel{(D-syntsm)}
\UIC{$d;\mathbf{syntsm}(s,\tau,e_{tsm})\sim (\Psi,s[\mathbf{syn}(\tau,i_{tsm})];\Theta)$}
\DP
\end{center}

\begin{center}
\AXC{
  $d\sim(\Psi;\Theta)$ ~~~~ $s\notin\text{dom}(\Psi)$ ~~~~ $\emptyset;\emptyset\vdash_{\Theta_0\Theta}^{\Psi}e_{tsm}\rightsquigarrow i_{tsm} \Leftarrow \mathtt{Parser(Exp)}$
}\RightLabel{(D-anatsm)}
\UIC{$d;\mathbf{anatsm}(s,e_{tsm})\sim (\Psi,s[\mathbf{ana}(i_{tsm})];\Theta)$}
\DP
\end{center}

\begin{center}
\AXC{
\stackanchor{
  $d\sim(\Psi;\Theta)$ ~~~~ $s\notin\text{dom}(\Psi)$ ~~~~ $\emptyset\vdash_{\Theta_0\Theta}\tau_{md}::\star$}
  {$\emptyset;\emptyset\vdash_{\Theta_0\Theta}^{\Psi}e_{tsm}\rightsquigarrow i_{tsm}\Leftarrow \mathtt{Parser}(\mathtt{Type}\times\tau_{md})$}
}\RightLabel{(D-tytsm)}
\UIC{$d;\mathbf{tytsm}(s,n,\kappa,\tau_{md},e_{tsm})\sim(\Psi,s[\mathbf{ty}(n,\kappa,\tau_{md},i_{tsm})];\Theta)$}
\DP
\end{center}

%\begin{center}
%\AXC{
% \stackanchor
% {$d\sim(\Psi;\Theta)$ ~~~~ $\T\notin\text{dom}(\Theta_0\Theta)$ ~~~~ $\emptyset\vdash_{\Theta_0\Theta}\tau::\kappa\rightarrow\kappa$}
% {$\emptyset;\emptyset\vdash_{\Theta_0\Theta,\T[\tau(\T)::\kappa,-]}^{\Psi}e_{md}\rightsquigarrow i_{md}\Rightarrow\tau_{md}$}
%}\RightLabel{(D-tydecl)}
%\UIC{$d;\mathbf{typedecl}(\T,\tau,e)\sim (\Psi;\Theta,\T[\tau(\T)::\kappa,i_{md}::\tau_{md}])$}
%\DP
%\end{center}
%
%\begin{center}
%\AXC{
% \stackanchor{
%   \stackanchor{$d \sim (\Psi;\Theta)$ ~~~~ $\mathtt{T}\notin \text{dom}(\Theta_0\Theta)$ ~~~~ $s[\mathbf{ty}(\kappa,\tau_{md},i_{tsm})]\in\Psi$}
%   {
%     \stackanchor{$\mathsf{parsestream}(body)=i_{ps}$ ~~~~ $i_{tsm}.parse(i_{ps}) \Downarrow OK((i_{type},i_{md}))$}{
%       $i_{type}\uparrow\hat\tau$ ~~~~ $\Delta;\emptyset\vdash_{\Theta\Theta'}\hat\tau\rightsquigarrow\tau::\kappa \rightarrow \kappa$
%     }
%   }
% }
% {$\emptyset;\emptyset\vdash_{\Theta_0\Theta,\mathtt{T}[\tau(\mathtt{T}) :: \kappa,-]}^{\Psi}e_{mdx}\rightsquigarrow i_{mdx} \Rightarrow \tau_{md}\rightarrow\tau'_{md}$ ~~~~ $i_{mdx}(i_{md})\Downarrow i'_{md}$}
%}
%\RightLabel{(D-aptsm)}
%\UIC{$d;\mathbf{tyaptsm}(\mathtt{T},s,body,e_{mdx}) \sim (\Psi; \Theta,\mathtt{T}[\tau(\mathtt{T}) :: \kappa,i'_{md}:\tau'_{md}])$}
%\DP
%\end{center}

\begin{center}
\AXC{
  $d\sim(\Psi;\Theta)$ ~~~~ $\vdash_{\Theta_0\Theta}^{\Psi} \theta \sim \Upsilon$ ~~~~ $\vdash_{\Theta_0\Theta}^{\Psi} \theta \sim_{\Upsilon} \Theta'$ ~~~~ $\vdash_{\Theta_0\Theta}^\Psi \theta \sim_{\Theta'} \Theta''$
  }\RightLabel{(D-rec)}
\UIC{$d;\mathbf{mrectydecl}(\theta)\sim(\Psi;\Theta\Theta'')$}
\DP
\end{center}

We formalize mutually recursive types with the rule above, following functional languages like Ocaml: all mutually recursive types should be declared together with the keyword \verb|and| separating them. The rule operates in three passes through the list. Type-level TSMs must declare how many types they must be mutually defined against. Each application of a type-level TSM still only generates a single type. \\

\flyingbox{$\vdash_{\Theta}^\Psi \theta \sim \Upsilon$}~~~~$\Upsilon ::= \emptyset ~|~ \Upsilon, \mathtt{T} :: \kappa$\\

First the names and kinds are extracted and placed in a list, $\Upsilon$. 

\begin{center}
\AXC{~}
\UIC{$\vdash_\Theta^\Psi \emptyset \sim \emptyset$}
\DP
\end{center}

\begin{center}
\AXC{
  $\vdash_{\Theta}^\Psi \theta \sim \Upsilon$ ~~~~ $\mathtt{T} \notin \text{dom}(\Upsilon)$ ~~~~ $\mathtt{T} \notin \text{dom}(\Theta)$ ~~~~ $\emptyset \vdash_{\Theta}^\Psi \tau :: \kappa_1 \rightarrow \ldots \rightarrow \kappa_n \rightarrow \kappa$  
}
\UIC{$\vdash_\Theta^\Psi \theta, \textbf{tydecl}(\mathtt{T}, \tau, e) \sim \Upsilon, \mathtt{T} :: \kappa$}
\DP
\end{center}

\begin{center}
\AXC{
  $\vdash_\Theta^\Psi \theta \sim \Upsilon$ ~~~~ $\mathtt{T} \notin \text{dom}(\Upsilon)$ ~~~~ $\mathtt{T} \notin \text{dom}(\Theta)$ ~~~~ $s[\textbf{ty}(n, \kappa,\tau,i)] \in \Psi$
}
\UIC{$\vdash_\Theta^\Psi \theta, \textbf{tyaptsm}(\mathtt{T}, s, body, e) \sim \Upsilon, \mathtt{T} :: \kappa$}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta}^\Psi \theta \sim_\Upsilon \Theta$}\\

Then, the types themselves are constructed and the type-level TSMs are applied. The metadata is not generated yet (though we save the metadata generated by a type-level TSM so we don't have to re-run it in the next phase.) Each type-level term must have a kind that takes in references to all the others.

\begin{center}
\AXC{~}
\UIC{$\vdash_\Theta^\Psi \emptyset \sim_\Upsilon \emptyset$}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_\Theta^\Psi \theta \sim_\Upsilon \Theta'$ ~~~~ $\Upsilon = \mathtt{T}_1 :: \kappa_1, \ldots, \mathtt{T}_i :: \kappa_i, \ldots, \mathtt{T}_n :: \kappa_n$ ~~~~ $\emptyset \vdash_\Theta \tau :: \kappa_1 \rightarrow \ldots \rightarrow \kappa_n \rightarrow \kappa_i$}
\UIC{$\vdash_\Theta^\Psi \theta, \textbf{tydecl}(\mathtt{T}_i, \tau, e) \sim_\Upsilon \Theta', \mathtt{T_i}[\tau(\mathtt{T}_1)\ldots(\mathtt{T}_n) :: \kappa_i, -]$}
\DP
\end{center}

\begin{center}
\AXC{
	\stackanchor{$\vdash_\Theta^\Psi \theta \sim_\Upsilon \Theta'$ ~~~~ $\Upsilon = \mathtt{T}_1 :: \kappa_1, \ldots, \mathtt{T}_i :: \kappa_i, \ldots, \mathtt{T}_n :: \kappa_n$ ~~~~ $s[\textbf{ty}(n, \kappa, \tau_{md}, i_{tsm})] \in \Psi$}
	{
		\stackanchor
  		{$\mathsf{parsestream}(body)=i_{ps}$ ~~~~ $i_{tsm}.parse(i_{ps}) \Downarrow OK((i_{type},i_{md}))$}
  		{$i_{type}\uparrow\hat\tau$ ~~~~ $\emptyset;\emptyset\vdash_{\Theta_0\Theta\Theta'}\hat\tau\rightsquigarrow\tau::\kappa_1 \rightarrow \ldots \rightarrow \kappa_n \rightarrow \kappa_i$}
  	}
  }
\UIC{$\vdash_\Theta^\Psi \theta, \textbf{tyaptsm}(\mathtt{T}_i, s, body, e) \sim_\Upsilon \Theta', \mathtt{T}_i[\tau(\mathtt{T}_i)...(\mathtt{T}_n) :: \kappa_i, i_{md} : \tau_{md}]$}
\DP
\end{center}

\flyingbox{$\vdash_\Theta^\Psi \theta \sim_\Theta \Theta$}\\

Finally, the metadata and metadata transformations are processed.

\begin{center}
\AXC{~}
\UIC{$\vdash_\Theta^\Psi \emptyset \sim_{\Theta'} \emptyset$}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_\Theta^\Psi \theta \sim_{\Theta',\mathtt{T}[\tau :: \kappa, -]} \Theta''$ ~~~~ $\emptyset; \emptyset \empty \vdash_{\Theta\Theta',\mathtt{T}[\tau :: \kappa, -]}^\Psi e_{md} \leadsto i_{md} \Rightarrow \tau_{md}$}
\UIC{$\vdash_\Theta^\Psi \theta, \textbf{tydecl}(\mathtt{T}, \tau, e_{md}) \sim_{\Theta'', \mathtt{T}[\tau :: \kappa, -]} \Theta', \mathtt{T}[\tau :: \kappa, i_{md} : \tau_{md}]$}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_\Theta^\Psi \theta \sim_{\Theta',\mathtt{T}[\tau::\kappa,i_{md}:\tau_{md}]} \Theta''$ ~~~~ $\emptyset;\emptyset\vdash_{\Theta\Theta',\mathtt{T}[\tau :: \kappa,i_{md}:\tau_{md}]}^{\Psi}e_{mdx}\rightsquigarrow i_{mdx} \Rightarrow \tau_{md}\rightarrow\tau'_{md}$ ~~~~ $i_{mdx}(i_{md})\Downarrow i'_{md}$}
\UIC{$\vdash_\Theta^\Psi \theta, \textbf{tyaptsm}(\mathtt{T}, s, body, e_{mdx}) \sim_{\Theta',\mathtt{T}[\tau :: \kappa, i_{md} : \tau_{md}]} \Theta'', \mathtt{T}[\tau :: \kappa_i, i_{md}' : \tau_{md}']$}
\DP
\end{center}

% \flyingbox{$\vdash_{\Theta}^{\Psi}\theta\leadsto\mathring\theta$}
% \begin{center}
% \AXC{
%   {$\T\notin\text{dom}(\Theta_0\Theta)$ ~~~~ $\emptyset\vdash_{\Theta_0\Theta}\tau::\kappa$}
% }\RightLabel{(D-tydecl-1)}
% \UIC{$\vdash_{\Theta}^{\Psi}\mathbf{typedecl}(\T,\tau,e)\leadsto (\Psi;\Theta,\T[\tau::\kappa,e])$}
% \DP
% \end{center}

% \begin{center}
% \AXC{
%     \stackanchor{$\mathtt{T}\notin \text{dom}(\Theta_0\Theta)$ ~~~~ $s[\mathbf{ty}(\kappa,\tau_{md},i_{tsm})]\in\Psi$}
%     {
%       \stackanchor{$\mathsf{parsestream}(body)=i_{ps}$ ~~~~ $i_{tsm}.parse(i_{ps}) \Downarrow OK((i_{type},i_{md}))$}{
%         $i_{type}\uparrow\hat\tau$ ~~~~ $\Delta;\emptyset\vdash_{\Theta\Theta'}\hat\tau\rightsquigarrow\tau::\kappa$
%       }
%     }
% }\RightLabel{(D-aptsm-1)}
% \UIC{$\vdash_{\Theta}^{\Psi}\mathbf{tyaptsm}(\mathtt{T},s,body,e_{mdx}) \leadsto (\Psi; \Theta,\mathtt{T}[\tau::\kappa,e_{mdx},i_{md}:\tau_{md}])$}
% \DP
% \end{center}

% \flyingbox{$\vdash^{\Psi}_{\Theta}\mathring\theta\leadsto\T[\tau::\kappa,i:\tau]$}
% \begin{center}
% \AXC{
%   $\emptyset;\emptyset\vdash_{\Theta}^{\Psi}e_{md}\rightsquigarrow i_{md}\Rightarrow\tau_{md}$
% }\RightLabel{(D-tydecl-2)}
% \UIC{$\vdash_{\Theta}^{\Psi}\T[\tau::\kappa,e_{md}]\leadsto\T[\tau::\kappa,i_{md}::\tau_{md}])$}
% \DP
% \end{center}

% \begin{center}
% \AXC{
%   {$\emptyset;\emptyset\vdash_{\Theta}^{\Psi}e_{mdx}\rightsquigarrow i_{mdx} \Rightarrow \tau_{md}\rightarrow\tau'_{md}$ ~~~~ $i_{mdx}(i_{md})\Downarrow i'_{md}$}
% }\RightLabel{(D-aptsm-2)}
% \UIC{$\vdash_{\Theta}^{\Psi}\T[\tau::\kappa,e_{mdx},i_{md}:\tau_{md}] \leadsto\mathtt{T}[\tau::\kappa,i'_{md}:\tau'_{md}])$}
% \DP
% \end{center}

\flyingbox{$\Delta\vdash_{\Theta}{\tau}::\kappa$}
\begin{center}
\AXC{$\vdash_{\Theta} \omega$}
\UIC{$\Delta\vdash_{\Theta} \mathbf{objtype}[\omega]::\star$}
%%% the next rule
\AXC{$\vdash_{\Theta} \chi$}
\UIC{$\Delta\vdash_{\Theta} \mathbf{casetype}[\chi]::\star$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\Delta\vdash_{\Theta} \tau_1::\star$ ~~~~ $\Delta\vdash_{\Theta}\tau_2::\star$}
\UIC{$\Delta\vdash_{\Theta} \tau_1\rightarrow\tau_2::\star$}
%%% the next rule
\AXC{$\T[\tau::\kappa,i:\tau]\in\Theta$}
\UIC{$\Delta\vdash_{\Theta} \T::\kappa$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\Delta\vdash_{\Theta} \tau_1::\star$ ~~~~ $\Delta\vdash_{\Theta}\tau_2::\star$}
\UIC{$\Delta\vdash_{\Theta} \tau_1\times\tau_2::\star$}
%%%
\AXC{$\Delta\vdash_{\Theta}\tau_1::\kappa_1\rightarrow \kappa_2$ ~~~~ $\Delta\vdash_{\Theta}\tau_2::\kappa_1$}
\UIC{$\Delta\vdash_{\Theta}\tau_1(\tau_2)::\kappa_2$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$t::\kappa\in\Delta$}
\UIC{$\Delta\vdash_{\Theta} t::\kappa$}
%%
\AXC{$\Delta,t:\kappa_1\vdash_{\Theta}\tau::\kappa_1$}
\UIC{$\Delta\vdash_{\Theta}\lambda[\kappa_1](t.\tau)::\kappa\rightarrow \kappa_2$}
%%
\AXC{$\Delta,t::\star\vdash_{\Theta}\tau::\star$}
\UIC{$\Delta\vdash_{\Theta}\forall(t.\tau)::\star$}
\noLine
\TIC{}
\DP
\end{center}

\flyingbox{$\Delta;\Delta\vdash_{\Theta}{\hat{\tau}}\rightsquigarrow\tau::\kappa$}
\begin{center}
\AXC{$\Delta_{out};\Delta\vdash_{\Theta} \hat\omega\rightsquigarrow \omega$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta}\mathbf{objtype}[\hat\omega]\rightsquigarrow\mathbf{objtype}[\omega]::\star$}
\DP
\end{center}

\begin{center}
\AXC{$\Delta_{out};\Delta\vdash_{\Theta} \hat\chi\rightsquigarrow{\chi}$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta} \mathbf{casetype}[\hat\chi]\rightsquigarrow \mathbf{casetype}[\chi]::\star$}
\DP
\end{center}

\begin{center}
\AXC{$\Delta_{out};\Delta\vdash_{\Theta} \hat{\tau}_1\rightsquigarrow\tau_1::\star$ ~~~~ $\Delta_{out};\Delta\vdash_{\Theta}\hat{\tau}_2\rightsquigarrow\tau_2::\star$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta} \hat{\tau}_1\rightarrow\hat{\tau}_2\rightsquigarrow{\tau}_1\rightarrow{\tau}_2::\star$}
%%% the next rule
\AXC{$\T[{\tau}::\kappa,i:{\tau}]\in\Theta$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta} \T\rightsquigarrow\T::\kappa$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\Delta_{out};\Delta\vdash_{\Theta} \hat{\tau}_1\rightsquigarrow\tau_1::\star$ ~~~~ $\Delta_{out};\Delta\vdash_{\Theta}\hat{\tau}_2\rightsquigarrow\tau_2::\star$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta} \hat{\tau}\times\hat{\tau}\rightsquigarrow\tau_1\times\tau_2::\star$}
\DP
\end{center}

\begin{center}
\AXC{$\Delta_{out};\Delta\vdash_{\Theta}\hat{\tau}_1\rightsquigarrow\tau_1::\kappa_1\rightarrow \kappa_2$ ~~~~ $\Delta_{out};\Delta\vdash_{\Theta}\hat{\tau}_2\rightsquigarrow\tau_2::\kappa_1$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta}\hat{\tau}_1(\hat{\tau}_2)\rightsquigarrow\tau_1(\tau_2)::\kappa_2$}
\DP
\end{center}

\begin{center}
\AXC{$t::\kappa\in\Delta$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta} t::\kappa$}
%%
\AXC{$\Delta_{out};\Delta,t:\kappa_1\vdash_{\Theta}\hat{\tau}\rightsquigarrow\tau::\kappa_1$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta}\lambda[\kappa_1](t.\hat{\tau})\rightsquigarrow\lambda[\kappa_1](t.{\tau})::\kappa\rightarrow \kappa_2$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\Delta_{out};\Delta,t::\star\vdash_{\Theta}\hat{\tau}\rightsquigarrow\tau::\star$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta}\forall(t.\hat{\tau})\rightsquigarrow\forall(t.{\tau})::\star$}
\DP
\end{center}

\begin{center}
\AXC{$\Delta_{out}\vdash_{\Theta} \tau ::\kappa$}
\UIC{$\Delta_{out};\Delta\vdash_{\Theta}\mathbf{spliced}[\tau]\rightsquigarrow \tau::\kappa$}
\DP
\end{center}

\doublebox{$i\uparrow \tau$}{$\tau\downarrow i$}
\begin{center}
\AXC{$ i\uparrow \T$}
\UIC{$ \mathbf{iinj}[Named](i)\uparrow \T$}
%%% the next rule
\AXC{$\T\downarrow i_{id}$}
\UIC{$\T\downarrow \mathbf{iinj}[Named](i_{id})$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$ i\uparrow \omega$}
\UIC{$ \mathbf{iinj}[Objtype](i)\uparrow \mathbf{objtype}[\omega]$}
%%% the next rule
\AXC{$\omega\downarrow i$}
\UIC{$\mathbf{objtype}[\omega]\downarrow\mathbf{iinj}[Objtype](i)$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$ i\uparrow \chi$}
\UIC{$ \mathbf{iinj}[Casetype](i)\uparrow \mathbf{casetype}[\chi]$}
%%% the next rule
\AXC{$\chi\downarrow i$}
\UIC{$\mathbf{casetype}[\omega]\downarrow\mathbf{iinj}[Casetype](i)$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$ i_1\uparrow \tau_1$ ~~~~ $ i_2\uparrow \tau_2$}
\UIC{$ \mathbf{iinj}[Arrow]((i_1, i_2))\uparrow \tau_1\rightarrow\tau_2$}
%%%
\AXC{$\tau_1\downarrow i_1$ ~~~~ $\tau_2\downarrow i_2$}
\UIC{$\tau_1\rightarrow\tau_2 \downarrow\mathbf{iinj}[Arrow]((i_1, i_2))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{ }
\UIC{$\mathbf{iinj}[Nil](i)\uparrow \emptyset$}
%%%
\AXC{}
\UIC{$\emptyset \downarrow\mathbf{iinj}[Nil](i)$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{
  \stackanchor
  {$i_l\uparrow l$}
  {$ i_t\uparrow \tau$ ~~~~ $ i_c\uparrow \omega$}
}
\UIC{$\mathbf{iinj}[Cons]((i_l, i_t, i_c))\uparrow l[\tau],\omega$}
%%%
\AXC{$l\downarrow i_l$ ~~~~ $\tau\downarrow i_t$ ~~~~ $\omega\downarrow i_c$}
\UIC{$l[\tau],\omega \downarrow \mathbf{iinj}[Cons]((i_l,i_t,i_c))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{}
\UIC{$\mathbf{iinj}[Nil](i)\uparrow \emptyset$}
%%%
\AXC{}
\UIC{$\emptyset \downarrow\mathbf{iinj}[Nil](i)$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{
  \stackanchor
  {$i_l\uparrow C$}
  {$ i_t\uparrow \tau$ ~~~~ $ i_c\uparrow \chi$}
 }
\UIC{$\mathbf{iinj}[Cons]((i_l, i_t, i_c))\uparrow C[\tau],\chi$}
%%%
\AXC{$C\downarrow i_l$ ~~~~ $\tau\downarrow i_t$ ~~~~ $\chi\downarrow i_c$}
\UIC{$C[\tau],\chi \downarrow \mathbf{iinj}[Cons]((i_l,i_t,i_c))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
... ...
\end{center}

\begin{center}
\AXC{$\mathsf{body}(i_{ps})=body$ ~~~~ $\mathsf{tparse}(body)=\tau$}
\UIC{$\mathbf{iinj}[Spliced](i_{ps})\uparrow \mathbf{spliced}[\tau]$}
\DP
\end{center}

\doublebox{$i\uparrow\hat{e}$}{$i\downarrow i$}
\begin{center}
\AXC{$i_{id}\uparrow x$}
\UIC{$\mathbf{iinj}[Var](i_{id})\uparrow x$}
%%%
\AXC{$x\downarrow i_{id}$}
\UIC{$x\downarrow \mathbf{iinj}[Var](i_{id})$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$ i_{1}\uparrow \tau$ ~~~~ $ i_2\uparrow\hat{e}$}
\UIC{$\mathbf{iinj}[Asc]((i_1,i_2))\uparrow \mathbf{hasc}[\tau](\hat{e})$}
%%%%
\AXC{$\tau\downarrow i_1$ ~~~~ $i\downarrow i_2$}
\UIC{$\mathbf{iasc}[\tau](i)\downarrow \mathbf{iinj}{Asc}((i_1,i_2))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$i_{id}\uparrow x$ ~~~~ $i\uparrow \hat{e}$}
\UIC{$\mathbf{iinj}[Lam]((i_{id},i))\uparrow \mathbf{hlam}(x.\hat{e})$}
%%%
\AXC{$x\downarrow i_{id}$ ~~~~ $i\downarrow i'$}
\UIC{$\mathbf{ilam}(x.i)\downarrow \mathbf{iinj}[Lam]((i_{id},i'))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$i_1\uparrow\hat{e}_1$ ~~~~ $i_2\uparrow\hat{e}_2$}
\UIC{$\mathbf{iinj}[Ap]((i_1,i_2))\uparrow \mathbf{hap}(\hat{e}_1,\hat{e}_2)$}
%%%
\AXC{$i_1\downarrow i'_1$ ~~~~ $i_2\downarrow i'_2$}
\UIC{$\mathbf{iap}(i_1;i_2)\downarrow \mathbf{iinj}[Ap]((i'_1,i'_2))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
... ...
\end{center}

\begin{center}
\AXC{$\mathsf{body}(i_{ps})=body$ ~~~~ $\mathsf{eparse}(body)=e$}
\UIC{$\mathbf{iinj}[Spliced](i_{ps})\uparrow \mathbf{spliced}[e]$}
\DP
\end{center}


\subsection{Context Formation}

\flyingbox{$\vdash_{\Theta} \Psi$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} \emptyset$}
%%% the next rule
\AXC{\stackanchor{$\Theta_{0}\subset\Theta$ ~~~~ $\vdash_{\Theta} \Psi$ ~~~~ $\nexists~s.(s=s_0\land s[\mathbf{ty}(\_,\_,\_,\_)]\in\Psi)$}{$\vdash_{\Theta}\tau_{md}::\star$ ~~~~ $\emptyset;\emptyset\vdash_{\Theta}i \Leftarrow \mathtt{Parser}(\mathtt{Type}\times\tau_{md})$}}
\UIC{$\vdash_{\Theta}\Psi;s_0[\mathbf{ty}(n, \kappa,\tau_{md},i_{tsm})]$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\Theta_{0}\subset\Theta$ ~~~~ $\vdash_{\Theta} \Psi$ ~~~~ $\nexists~s.(s=s_0\land (s[\mathbf{syn}(\_,\_)]\in \Psi\lor s[\mathbf{ana}(\_)])\in \Psi)$ ~~~~ $\emptyset;\emptyset\vdash_{\Theta}i\Leftarrow\mathtt{Parser}(\mathtt{Exp})$}
\UIC{$\vdash_{\Theta}\Psi;s_0[\mathbf{ana}(i)]$}
\DP
\end{center}

\begin{center}
\AXC{
  \stackanchor
  {$\Theta_{0}\subset\Theta$ ~~~~ $\vdash_{\Theta} \Psi$ ~~~~ $\nexists~s.(s=s_0\land (s[\mathbf{syn}(\_,\_)]\in \Psi\lor s[\mathbf{ana}(\_)])\in \Psi)$}
  {$\emptyset\vdash_{\Theta}\tau::\star$~~~~ $\emptyset;\emptyset\vdash_{\Theta}i\Leftarrow\mathtt{Parser}(\mathtt{Exp})$}
}
\UIC{$\vdash_{\Theta}\Psi;s_0[\mathbf{syn}(\tau,i)]$}
\DP
\end{center}

\flyingbox{$\vdash_\Theta \Theta$}
\begin{center}
\AXC{}
\UIC{$\vdash_\Theta \emptyset$}
%%% the next rule
\AXC{
  $\vdash_\Theta \Theta'$ ~~~~ $\mathtt{T} \notin \text{dom}(\Theta\Theta')$ ~~~~ $\emptyset \vdash_{\Theta'} \tau :: \kappa$ ~~~~ $\emptyset; \emptyset \vdash_\Theta i_{md} \Leftarrow \tau_{md}$}
\UIC{$\vdash_\Theta \Theta', \mathtt{T}[\tau :: \kappa, i_{md} : \tau_{md}]$}
\noLine
\BIC{}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta} \omega$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} \emptyset$}
%%% the next rule
\AXC{$l\notin \text{dom}(\omega)$ ~~~~ $\emptyset\vdash_{\Theta}\tau::\star$ ~~~~ $\vdash_{\Theta}\omega$}
\UIC{$\vdash_{\Theta} l[\mathbf{def},\tau];\omega$}
%%%
\AXC{$l\notin \text{dom}(\omega)$ ~~~~ $\emptyset\vdash_{\Theta}\tau::\star$ ~~~~ $\vdash_{\Theta}\omega$}
\UIC{$\vdash_{\Theta} l[\mathbf{val},\tau];\omega$}
\noLine
\TIC{}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta} \chi$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} \emptyset$}
%%% the next rule
\AXC{$C\notin \text{dom}(\chi)$ ~~~~ $\emptyset\vdash_{\Theta}\tau::\star$ ~~~~ $\vdash_{\Theta}\chi$}
\UIC{$\vdash_{\Theta} C[\tau];\chi$}
\noLine
\BIC{}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta} \Gamma$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} \emptyset$}
%%% the next rule
\AXC{$\vdash_{\Theta} \Gamma$ ~~~~ $\emptyset\vdash_{\Theta} \tau::\star$}
\UIC{$\vdash_{\Theta} \Gamma,x:\tau$}
\noLine
\BIC{}
\DP
\end{center}

\subsection{Statics for external terms}
Statics for core lambda calculus can be referred to in \cite{TSLs}. And here we present elaboration rules for TSM and TSL extensions on Wyvern language: including the rule for TSL literals elaboration $\mathbf{lit}[body]$, rules for TSM parser access $\mathbf{etsmdef}[s]$, and TSM application $\mathbf{eaptsm}[s,body]$.
\begin{center}
\AXC{
  \stackanchor{
    \stackanchor
    {$\Theta_0\subset\Theta$ ~~~~ $T[\tau::\kappa,i_m:\mathtt{HasTSL}]\in\Theta$ ~~~~ $\mathsf{parsestream}(body)=i_{ps}$}
    {$i_m.parser.parse(i_{ps})\Downarrow OK((i_{ast},i'_{ps}))$}
  }
  {$i_{ast}\uparrow \hat{e}$ ~~~~ $\Delta;\emptyset;\Gamma;\emptyset\vdash_{\Theta}\hat{e}\rightsquigarrow i\Leftarrow \mathtt{T}$}
} \RightLabel{(T-lit)}
\UIC{$\Delta;\Gamma\vdash_{\Theta}\mathbf{lit}[body]\rightsquigarrow i\Leftarrow \mathtt{T}$}
\DP
\end{center}


\begin{center}
\AXC{$\Theta_0\subset\Theta$ ~~~~ $s[\mathbf{syn}(\tau,i)]\in\Psi$}\RightLabel{(T-syntsmdef)}
\UIC{$\Delta;\Gamma\myvdash\mathbf{etsmdef}[s] \rightsquigarrow i\Rightarrow\mathtt{Parser}(\mathtt{Exp})$}
\DP
\end{center}

\begin{center}
\AXC{$\Theta_0\subset\Theta$ ~~~~ $s[\mathbf{ana}(i)] \in \Psi$}\RightLabel{(T-anatsmdef)}
\UIC{$\Delta;\Gamma\myvdash \mathbf{etsmdef}[s] \rightsquigarrow i\Rightarrow\mathtt{Parser}(\mathtt{Exp})$}
\DP
\end{center}

\begin{center}
\AXC{$\Theta_0\subset\Theta$ ~~~~ $s[\mathbf{ty}(n,\kappa,\tau,i)]\in\Psi$} \RightLabel{(T-typetsmdef)}
\UIC{$\Delta;\Gamma\myvdash \mathbf{etsmdef}[s]\rightsquigarrow i\Rightarrow\mathtt{Parser}(\mathtt{Type})$}
\DP
\end{center}

\begin{center}
\AXC{
  \stackanchor
  {$\Theta_0 \subset \Theta$ ~~~~ $s[\mathbf{ana}(i_{tsm})]\in\Theta$ ~~~~ $\mathsf{parsestream}(body)=i_{ps}$}
  {$i_{tsm}.parse(i_{ps});\Downarrow OK((i_{ast}, i'_{ps}))$ ~~~~ $i_{ast}\uparrow \hat{e}$ ~~~~ $\Delta;\emptyset;\Gamma;\emptyset\myvdash \hat{e} \rightsquigarrow i \Leftarrow \tau$}
}\RightLabel{(T-ana)}
\UIC{$\Delta;\Gamma\myvdash\mathbf{eaptsm}[s,body] \rightsquigarrow i \Leftarrow \tau$}  
\DP
\end{center}

\begin{center}
\AXC{
  \stackanchor
  {$\Theta_0 \subset \Theta$ ~~~~ $s[\mathbf{syn}(\tau,i_{tsm})]\in\Theta$ ~~~~ $\mathsf{parsestream}(body)=i_{ps}$}
  {$i_{tsm}.parse(i_{ps})\Downarrow OK((i_{ast}, i'_{ps}))$ ~~~~ $i_{ast}\uparrow \hat{e}$ ~~~~ $\Delta;\emptyset;\Gamma;\emptyset\myvdash \hat{e} \rightsquigarrow i \Leftarrow \tau$}
} \RightLabel{(T-syn)}
\UIC{$\Delta;\Gamma\myvdash\mathbf{eaptsm}[s,body] \rightsquigarrow i\Rightarrow \tau$}  
\DP
\end{center}

\section{Metatheory}
\begin{theorem}[Internal Type Safety]
If $\vdash\Theta$, and $\emptyset;\emptyset\vdash_{\Theta}i\Leftarrow\tau$ or $\emptyset;\emptyset\vdash_{\Theta}i\Rightarrow\tau$, then either $i~\texttt{val}$ or $i\mapsto i'$ such that $\emptyset;\emptyset\vdash_{\Theta}i'\Leftarrow\tau$.
\end{theorem}
\begin{proof}
The dynamics are standard, so the proof is by a standard preservation and progress argument. One exception is the proof for the term reification expression $\mathbf{etoast}(e)$:
\begin{itemize}
\item {case $\mathbf{etoast}[e]$: If $\Theta_0\subset\Theta$ and $\emptyset;\emptyset\vdash_{\Theta}i\Leftarrow\tau$ then $i\downarrow i'$ and $\emptyset\vdash_{\Theta}i'\Leftarrow\mathtt{Exp}$.}
\\
The proof of the case can be referred to the rules $i\downarrow i$: for each interanl expression, there exists a rule to transform the expression into an AST presentation. And by induction on the derivation of the terms, the proof can be easily achieved.
\end{itemize}
\end{proof}

\begin{theorem}[External Type Preservation]
If $\vdash\Theta$, $\vdash_{\Theta_0\Theta}\Psi$, $\vdash_{\Theta_0\Theta}\Gamma$, $\vdash\Delta$ and $\Delta;\Gamma\vdash_{\Theta_0\Theta}^{\Psi} e\rightsquigarrow i\Leftarrow\tau$ or $\Delta;\Gamma\vdash_{\Theta_0\Theta}^{\Psi} e\rightsquigarrow i\Rightarrow\tau$ then $\Delta;\Gamma\vdash_{\Theta_0\Theta} i\Leftarrow\tau$.
\end{theorem}
\begin{proof}
Base on the proof of core Wyvern external terms in TSL, we only need to present the proofs for the new cases extended in external Wyvern:
\begin{itemize}
\item $\mathbf{eaptsm}[s,body]$, in this case, according to the rule T-syn, there exists a translational term $\hat{e}$, s.t. $\Delta;\emptyset;\Gamma;\emptyset\vdash_{\Theta}^{\Psi}\hat{e}\rightsquigarrow i\Leftarrow \tau$. For the typing context, we have $\vdash\emptyset$ (which is $\Gamma_{out}$) and $\vdash\emptyset$ (empty $\Delta_{out}$). And by the conditions in the theorem $\vdash_{\Theta}\Gamma$, $\vdash\Theta$ and $\vdash_{\Theta_0\Theta}\Psi$, by Lemma~1, we have $\emptyset;\Gamma\vdash_{\Theta_0\Theta}i\Leftarrow\tau$. 
\item $\mathbf{etsmdef}[s]$. There are three subcases depends on the property of $s$: type-level TSM, synthetic TSM or analytic TSM. For synthetic TSM, by induction, we have the formation of the internal term $i$ in $s[\mathbf{syn}(\tau,i)]$, i.e. $\vdash_{\Theta_0\Theta}i\Leftarrow \mathtt{ExpParser}$ as $\Theta_0\Theta$ is well formed. The subcase for analytic TSM and type level TSM are similar, as the formation of the term $i$ in $s[\mathbf{ana}(i)]$ and the term $i$ in $s[\mathbf{ty}(n,\kappa,\tau,i)]$ are checked in declarations elaboration. Thus the case is proved.
\end{itemize}
With all these cases proved, we have the property holds for all external terms.
\end{proof}

\begin{lemma}[Translational Type Preservation]
If $\vdash\Theta$, $\vdash_{\Theta_0\Theta} \Psi$, $\vdash_{\Theta_0\Theta}\Gamma_{out}$, $\vdash_{\Theta_0\Theta}\Gamma$, $\text{dom}(\Gamma_{out})\cap \text{dom}(\Gamma)=\emptyset$, $\vdash\Delta$, $\vdash\Delta_{out}$, $\text{dom}(\Delta)\cap\text{dom}(\Delta_{out})=\emptyset$ and $\Delta_{out};\Delta;\Gamma_{out};\Gamma\vdash_{\Theta\Theta_0}^{\Psi}\hat{e}\rightsquigarrow i\Leftarrow\tau$ or $\Delta_{out};\Delta;\Gamma_{out};\Gamma\vdash_{\Theta\Theta_0}^{\Psi}\hat{e}\rightsquigarrow i\Rightarrow \tau$ then $(\Delta_{out}\Delta);(\Gamma_{out}\Gamma)\vdash_{\Theta_0\Theta}i\Leftarrow \tau$.
\end{lemma}
\begin{proof}
The proof by induction over the typing derivation for all the shared cases. The outer context is threaded through opaquely when applying the inductive hypothesis. By induction on all translational terms, we can easily prove them based on their derivation rules.

The only rules of note are the rules for the spliced external terms, which require applying the external type preservation theorem recursively.
This is well-founded by a metric measuring the size of the spliced external term, written
in concrete syntax, since we know it was derived from a portion of the literal body.
\end{proof}

\begin{lemma}[Translational Type Elaboration]
If $\vdash\Theta$, $\vdash\Delta$, $\vdash\Delta_{out}$, $\text{dom}(\Delta)\cap\text{dom}(\Delta_{out})=\emptyset$ and $\Delta_{out};\Delta\vdash_{\Theta_0\Theta}\hat\tau\rightsquigarrow\tau::\kappa$, then we have $\Delta_{out}\Delta\vdash_{\Theta_0\Theta}\tau::\kappa$.
\end{lemma}
\begin{proof}
By induction on the derivation of the translational types, we can easily proof the cases in by checking the properties on the derivation rules:
\begin{itemize}
\item For the type $\mathbf{spliced}[\tau]$, the well-formedness is checked under the context $\Delta_{out}$, i.e. $\Delta_{out}\tau$, thus in the check rule for internal types, we have $\Delta_{out}\Delta\vdash_{\Theta}\tau$. And the case is proved.
\item For other terms, by induction, the proof is standard, as they are checked in $\Delta$. For example, the formation of the arrow type $\tau_1\rightarrow\tau_2$ is proved by its subterms $\tau_1$ and $\tau_2$. Thus the case is proved.
\end{itemize}
With these cases proved, the lemma is proved.
\end{proof}


\begin{theorem}[Compilation]
If ~$\rho\sim(\Psi;\Theta)\rightsquigarrow i:\tau$ then $\vdash\Theta$, $\vdash_{\Theta_0\Theta}\Psi$ and $\emptyset;\emptyset\vdash_{\Theta_0\Theta} i\Leftarrow\tau$.
\end{theorem}
\begin{proof}
The proof contains two parts: the formation of the contexts ($\Theta$, $\Psi$) and the formation of the term $i$.

The proof for the contexts formation requires the following lemma. And the proof for the term $i$ is obvious: According to the rule `compile', we have that $\emptyset;\emptyset\vdash_{\Theta_0\Theta}^{\Psi}e\rightsquigarrow i\Rightarrow \tau$, and for the context: $\vdash\emptyset$ by the checking rule for $\Gamma$, $\vdash\emptyset$ for context $\Delta$, $\vdash_{\Theta_0\Theta}\Psi$, $\vdash\Theta_0\Theta$ by the proof of the first part. Then by Theorem~1, we have $\emptyset;\emptyset\vdash_{\Theta_0\Theta}i\Leftarrow\tau$, which completes the proof.
\end{proof}

\begin{lemma} If $d\sim(\Psi';\Theta')$, then we have $\vdash\Theta'$ and $\vdash_{\Theta_0\Theta'}\Psi'$.
\end{lemma}
\begin{proof}
By induction on the length of the derivation steps the declarations $d$. Check the last step of derivation, we have the following four cases to proof:
\begin{itemize}
\item $d=d_1;\mathbf{syntsm}(s,\tau,e_{tsm})$. To prove the well-formedness of the declaration, we need to prove that no name conflicts exists and the parser $i$ is of type $\mathtt{Parser}(\mathtt{Exp})$. 

Firstly, by induction, we have the well-formedness of the previous contexts: $d_1\sim(\Theta_1;\Psi_1)$ imply that $\Theta_1$ and $\Psi_1$ is well formed. Secondly, in the rule \text{D-syntsm}, we check that its name does not appear in the previous context $\Psi_1$, thus we have $s[\mathbf{syn}(\_,\_)]\notin\text{dom}(\Psi_1)\lor s[\mathbf{ana}(\_)]\notin\text{dom}(\Psi_1)$, thirdly, by theorem~2 and the premise $\emptyset;\emptyset\vdash_{\Theta_0\Theta}^{\Psi}e_{tsm}\rightsquigarrow i_{tsm} \Leftarrow \mathtt{Parser(Exp)}$, we have $\emptyset;\emptyset\vdash_{\Theta}i\Leftarrow\mathtt{Parser}(\mathtt{Exp})$. And these three rules prove the well-formedness of the environment $\Psi_1,s[\mathbf{syn}(\tau,i)]$. Also by induction, we have $\vdash\Theta_1$. Combining these two conditions, the case is proved.
\item $d=d_1;\mathbf{anatsm}(s,e_{tsm})$, this case is exactly the same with the previous case, expect that the type $\tau$ is omitted.
\item $d=d_1;\mathbf{tytsm}(s,\kappa,\tau,e)$. To check the well-formedness of the type-level TSM, we need to check 1) No name conflicts exists in the previous context, 2) the type should be of kind $\star$, 3) the type of the parser $i$ should be $\mathtt{Parser}(\mathtt{Type}\times\tau)$.

The proof can be done with the following conditions in the derivation rules \text{(D-tytsm)}: 1) The name is checked to be free of conflicts in the previous context. 2) The type $\tau$ is checked to be well formed and of kind $\star$. 3) By Theorem~2, and the premise $\emptyset;\emptyset\vdash_{\Theta_0\Theta}e_{tsm}\rightsquigarrow i_{tsm}\Leftarrow \mathtt{Parser}(\mathtt{Type}\times\tau)$, we have  $\emptyset;\emptyset\vdash_{\Theta_0\Theta} i_{tsm}\Leftarrow \mathtt{Parser}(\mathtt{Type}\times\tau)$. And by induction, we have the formation of the previous context $\Theta_1$ and $\Psi_1$. Thus the case is proved.
\item $d=d;\mathbf{mrectydecl}(\theta_1,...,\theta_n)$. The formation of a type declaration in $\Theta$ includes 1) no name conflicts in the previous context, 2) the type structure is well formed, 3) the metadata expression is well formed.

Firstly, the names are check by the premise $\nexists~u,v\in\{1,...,n\}.(u\neq v\land\T_u=\T_v)$ and $\forall~k.(\T_k\notin\text{dom}(\Theta))$. Thus no name conflicts exists in the previous context.

Secondly, by the rule (D-tydecl-1), we have $\emptyset\vdash_{\Theta\Theta_0}\tau::\kappa$. By the rule (D-aptsm-1), we have $\emptyset\vdash_{\Theta\Theta_0}\hat{\tau}\rightsquigarrow\tau::\kappa$, then by Lemma~2, we have $\emptyset\vdash_{\Theta\Theta_0}\tau::\kappa$. Then by the type checking condition $\emptyset\vdash\mathsf{type}(\mathring\theta_k)::\kappa_1\rightarrow...\rightarrow\kappa_n\rightarrow\kappa_k$, all types are of kind $\tau_1\rightarrow...\rightarrow\tau_n\rightarrow\tau_k$ and are well formed. Then by the named type substitution, we have the formation of the type $\tau_k(\T_1,...,T_n)::\kappa_k$, which proves the well-formedness of each type structure.

Thirdly, by the rule \text{(D-tydecl-2)}, the metadata is checked by the condition $\emptyset;\emptyset\vdash_{\Theta}^{\Psi}e\rightsquigarrow i\Rightarrow\tau$, then by Theorem~2, we have $\emptyset;\emptyset\vdash_{\Theta}i\Leftarrow\tau$. And by \text{(D-aptsm-2)}, the metadata $i$ is well formed by applying a well formed term $i_{mdx}$ to another well formed term $i_{md}$, thus the result should be well formed.

Then by induction, we have the TSM context $\Psi_1$ untouched and thus it is well formed.

With these three conditions proved, the case is proved.
\end{itemize}
With these four cases proved, the lemma is proved: compilation always produce well formed contexts.
\end{proof}

\FloatBarrier
\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}
