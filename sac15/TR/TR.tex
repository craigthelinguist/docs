\documentclass[letterpaper, notitlepage]{article}
\usepackage{bussproofs}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{fancyhdr}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{stackengine}
\usepackage[usenames,dvipsnames]{color} % Required for specifying custom colors and referring to colors by name
\usepackage{listings}
\usepackage[top=1in, bottom=1in, left=1.25in, right=1.25in]{geometry}
\usepackage{xcolor}
\usepackage{bera}% optional; just for the example

\definecolor{DarkGreen}{rgb}{0.0,0.4,0.0} % Comment color
\definecolor{highlight}{RGB}{255,251,204} % Code highlight color
% This is the "centered" symbol
\def\fCenter{{\mbox{\Large$\rightarrow$}}}

% Optional to turn on the short abbreviations
\EnableBpAbbreviations

% This is the "centered" symbol
\def\fCenter{{\mbox{\Large$\rightarrow$}}}

\newcommand{\blue}[1] {\textcolor{blue}{#1}}
\newcommand{\flyingbox}[1]{\begin{flushleft}\fbox{{#1}}\end{flushleft}}
\newcommand{\doublebox}[2]{\begin{flushleft}\fbox{{#1}}\ \fbox{{#2}}\end{flushleft}}
\newcommand{\myvdash}{\vdash_{\Theta}^{\Delta}}
\newcommand{\todo}[1]{{\bf \{TODO: {#1}\}}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}

% Optional to turn on the short abbreviations
\EnableBpAbbreviations

% \alwaysRootAtTop  % makes proofs upside down
% \alwaysRootAtBottom % -- this is the default setting

\lstdefinestyle{wyvern}{ % Define a style for your code snippet, multiple definitions can be made if, for example, you wish to insert multiple code snippets using different programming languages into one document
%backgroundcolor=\color{highlight}, % Set the background color for the snippet - useful for highlighting
basicstyle=\footnotesize\ttfamily, % The default font size and style of the code
breakatwhitespace=false, % If true, only allows line breaks at white space
breaklines=true, % Automatic line breaking (prevents code from protruding outside the box)
captionpos=b, % Sets the caption position: b for bottom; t for top
morecomment=[s]{(*}{*)},
commentstyle=\fontshape{it}\color{DarkGreen}\selectfont, % Style of comments within the code - dark green courier font
deletekeywords={}, % If you want to delete any keywords from the current language separate them by commas
%escapeinside={\%}, % This allows you to escape to LaTeX using the character in the bracket
firstnumber=1, % Line numbers begin at line 1
frame=lines, % Frame around the code box, value can be: none, leftline, topline, bottomline, lines, single, shadowbox
frameround=tttt, % Rounds the corners of the frame for the top left, top right, bottom left and bottom right positions
keywords=[1]{new, objtype, type, casetype, val, def, metadata, keyword, of},
keywordstyle={[1]\ttfamily\color{blue!90!black}},
keywordstyle={[3]\ttfamily\color{red!80!orange}},
morekeywords={}, % Add any functions no included by default here separated by commas
numbers=left, % Location of line numbers, can take the values of: none, left, right
numbersep=10pt, % Distance of line numbers from the code box
numberstyle=\tiny\color{Gray}, % Style used for line numbers
rulecolor=\color{black}, % Frame border color
showstringspaces=false, % Don't put marks in string spaces
showtabs=false, % Display tabs in the code as lines
stepnumber=5, % The step distance between line numbers, i.e. how often will lines be numbered
tabsize=4, % Number of spaces per tab in the code
}


\begin{document}

\title{Composable and Hygienic Typed Syntax Macros}
\maketitle

\section{Wyvern Prelude}
\begin{lstlisting}[style=wyvern]
type TypeParser = objtype
	def parse(ps : ParseStream) : Result(Type * Exp)
	metadata : HasTSL = new 
		val parser = (* parser generator *)

type Type = casetype
	Named of ID
	Objtype of List(MemberDecl)
	Casetype of List(CaseDecl)
	Arrow of Type * Type
	metadata : HasTSL = new
		val parser = (* type quasiquotes *)

type MemberList = casetype
	Nil  of Unit
	Cons of Label * Type * MemberList

type CaseList = casetype
	Nil  of Unit
	Cons of Label * Type * CaseList

type ExpParser = objtype
	def parse(ps : ParseStream) : Result(Exp)
	metadata : HasTSL = new 
		val parser = (* parser generator *)

type Exp = casetype
	Var of ID
	Lam of ID * Exp
	Ap of Exp * Exp
	(* ... *)
	metadata : HasTSL = new
		val parser = (* exp quasiquotes *)

type Result(T) = casetype
	OK of Exp * ParseStream
	Error of String * Location
\end{lstlisting}

\section{Syntax \& Type Checking}
\subsection{Syntax}
\[
\begin{array}{rlrlrl}
	\rho		~::=&~ \theta;e\\				
	\theta		~::=&~ \emptyset								&\tau 		~::=&~ \mathbf{named}[T]	& \omega 		~::=&~ 	\emptyset\\
				| ~	&~ \theta; T[\mathbf{explicit}, \tau, e]	&|~	& ~ \mathbf{objtype}[\omega]		& |~&  	~l[\mathbf{val}, \tau];\omega\\
				| ~	&~ \theta; T[\mathbf{tykw}, k, body, e]		&|~	& ~ \mathbf{casetype}[\chi]			& |~&	~l[\mathbf{def}, \tau];\omega\\
				| ~	&~ \theta;k[\mathbf{ty},e,\tau]				&|~ & ~ \mathbf{arrow}[\tau, \tau]		& \chi 			~::=&~	\emptyset ~ \\
				| ~ &~ \theta;k[\mathbf{bk}(\tau),e]			&	&									& |~&	~C[\tau];\omega\\
				| ~ &~ \theta;k[\mathbf{wk},e]\\
	e 			~::=&~ x 								&\hat{e}	~::=&~ 	x 										& i 		~::=&~ 	x\\
				| ~ &~ \mathbf{easc}[\tau](e)			& 		 	| ~ &~ 	\mathbf{hasc}[\tau](\hat{e})			& 		 	| ~ &~	\mathbf{iasc}[\tau](\dot{e})\\
				| ~ &~ \mathbf{elet}(e; x.e)     		& 		 	| ~ &~ 	\mathbf{hlet}(\hat{e}; x.\hat{e})		& 		 	| ~ &~	\mathbf{ilet}(i;x.i)\\
				| ~ &~ \mathbf{elam}(x.e)     			& 		 	| ~ &~ 	\mathbf{hlam}(x.\hat{e})				& 		 	| ~ &~	\mathbf{ilam}(x.i)\\
				| ~ &~ \mathbf{eap}(e;e)     			& 		 	| ~ &~ 	\mathbf{hap}(\hat{e};\hat{e})			& 		 	| ~ &~	\mathbf{iap}(i;i)\\
				| ~ &~ \mathbf{enew}(m)     			& 		 	| ~ &~	\mathbf{hnew}(\hat{m})					& 		 	| ~ &~	\mathbf{inew}(\dot{m})\\
				| ~ &~ \mathbf{eprj}[l](e)     			& 		 	| ~ &~	\mathbf{hprj}[l](\hat{e})				& 		 	| ~ &~	\mathbf{iprj}[l](i)\\
				| ~ &~ \mathbf{einj}[C](e)     			& 		 	| ~ &~	\mathbf{hinj}[C](\hat{e})				& 		 	| ~ &~	\mathbf{iinj}[C](i)\\
				| ~ &~ \mathbf{ecase}[e]\{r\}     		& 		 	| ~ &~	\mathbf{hcase}[\hat{e}]\{\hat{r}\}		& 		 	| ~ &~	\mathbf{icase}[i]\{\dot{r}\}\\
				| ~ &~ \mathbf{etoast}(e)     			& 		 	| ~ &~	\mathbf{htoast}(\hat{e})				& 		 	| ~ &~	\mathbf{itoast}[i]\\
				| ~ &~ \mathbf{emetadata}[T]     		& 		 	| ~ &~	\mathbf{hmetadata}[T]\\
				| ~ &~ \mathbf{termtsmdef}[k]     		&			| ~ &~ 	\mathbf{htermtsmdef}[k]\\
				| ~ &~ \mathbf{typetsmdef}[k]			& 			| ~ &~ 	\mathbf{htypetsmdef}[k]\\
				| ~ &~ \mathbf{lit}[T]					& 		 	| ~ &~ 	\mathbf{spliced}[e]\\
				| ~ &~ \mathbf{ekey}[k,body]\\
	m 			~::=&~ \emptyset						&\hat{m}	~::=&~ \emptyset								&\dot{m}	~::=&~ \emptyset\\
				| ~ &~ \mathbf{eval}[l](e);m 			&			| ~ &~ \mathbf{hval}[l](\hat{e});\hat{m} 		&			| ~ &~ \mathbf{ival}[l](i);\dot{m}\\
				| ~ &~ \mathbf{edef}[l](x.e);m 			&			| ~ &~ \mathbf{hdef}[l](x.\hat{e});\hat{m}		&			| ~ &~ \mathbf{idef}[l](x.i);\dot{m}\\
	r 			~::=&~ \emptyset 						&\hat{r} 	~::=&~ \emptyset 								&\dot{r} 	~::=&~ \emptyset\\
				| ~ &~ \mathbf{erule}[C](x.e);r 		& 			| ~ &~ \mathbf{hrule}[C](x.\hat{e});\hat{r} 	&			| ~ &~ \mathbf{irule}[C](x.i);\dot{r}
\end{array}
\]
\subsection{Context Definition}
\[
\begin{array}{rrl}
\text{Keyword Context}	&	\Delta 	~::=&~ 	\emptyset\\
						&			| ~ &~ 	\Delta;k[\mathbf{ty}(\gamma,\delta)]\\
						&			| ~ &~ 	\Delta;k[\mathbf{syn}(\delta,\gamma)]\\
						&			| ~ &~ 	\Delta;k[\mathbf{ana}(\gamma)]\\
\text{Type Context}		&	\Theta 	~::=&~ \emptyset\\
						&			| ~ &~ \Theta,T[\delta,\mu] \\
						&	\delta 	~::=&~ ? ~~ | ~~ \tau\\
						&	\mu	   	~::=&~ ? ~~ | ~~ i:\tau\\
						& 	\gamma  ~::=&~ ? ~~ | ~~ i\\
\text{Typing Context}	&	\Gamma 	~::=&~ \emptyset\\
						&			| ~ &~ \Gamma,x:\tau\\
\end{array}
\]

\subsection{Type Checking and Elaboration}
\begin{definition}[Context Override]Given two type contexts $\Theta_1$ and $\Theta_2$, we define $\Theta_1\Theta_2$ as a new context $\Theta'$, which satisfies:
\[
	\Theta_1\Theta_2 = \Theta' = \{~T[\delta,\mu]~|~ (T\notin dom(\Theta_2)\land T[\delta,\mu]\in\Theta_1)\lor(T[\delta,\mu]\in\Theta_2) ~\}
\]
Similarly, we define $\Delta_1\Delta_2$ as a new keyword context $\Delta'$, which satisfies:
\[
	\begin{array}{rl}
	\Delta_1\Delta_2=\Delta'=&\{~k[\mathbf{tytsm}(\gamma,\delta)]~|~ (k\notin dom(\Delta_2) \land k[\mathbf{tytsm}(\gamma,\delta)]\in\Delta_1)\lor(k[\mathbf{tytsm}(\gamma,\delta)]\in\Delta_2)  ~\}\\
							 &\cup~\{~k[\mathbf{syntsm}(\delta,\gamma)]~|~ (k\notin dom(\Delta_2) \land k[\mathbf{syntsm}(\delta,\gamma)]\in\Delta_1) \lor(k[\mathbf{syntsm}(\delta,\gamma)]\in\Delta_2)  ~\}\\
							 &\cup~\{~k[\mathbf{anatsm}(\gamma)]~|~ (k\notin dom(\Delta_2) \land k[\mathbf{anatsm}(\gamma)]\in\Delta_1) \lor(k[\mathbf{anatsm}(\gamma)]\in\Delta_2)  ~\}
	\end{array}
\]
\end{definition}
By this definition, we are able to present the `override' of $\Theta_1$ (or $\Delta_1$) by a new context $\Theta_2$ (or $\Delta_2$), which can update the old context with new elements from the new context.

\flyingbox{$\rho \sim (\Theta;\Delta)\rightsquigarrow i:\tau$}
\begin{center}
\AXC{$\vdash_{\Theta_{0}}^{\emptyset}\theta\sim(\Theta;\Delta)$ ~~~~ $\emptyset\vdash_{\Theta_0\Theta}^{\Delta}e\rightsquigarrow i\Rightarrow \tau$}      \RightLabel{(compile)}
\UIC{$\theta;e\sim(\Theta;\Delta)\rightsquigarrow i:\tau$}
\DP
\end{center}

\flyingbox{${\myvdash}\theta\sim (\Theta;\Delta)$}
\begin{center}
\AXC{
	\stackanchor
	{$\vdash_{\Theta_{0}}^{\emptyset}\theta \sim_{names}(\Theta_{names};\Delta_{names})$}
	{$\vdash_{\Theta_{0}\Theta_{names}}^{\Delta_{names}}\theta \sim_{defs}(\Theta_{defs};\Delta_{defs})$ ~~~~ $\vdash^{\Delta_{defs}}_{\Theta_{0}\Theta_{defs}}\theta \sim_{exts}(\Theta;\Delta) $}
} \RightLabel{(rec-decls)}
\UIC{$\vdash_{\Theta_{0}}^{\Delta} \theta \sim (\Theta;\Delta)$} 
\DP
\end{center}

\flyingbox{$\vdash_{\Theta}^{\Delta}\theta\sim_{names} (\Theta;\Delta)$}
\begin{center}
\AXC{} \RightLabel{(empty-names)}
\UIC{${\vdash_{\Theta}^{\Delta}} \emptyset \sim_{names} (\emptyset;\emptyset)$}
\DP
\end{center}
\begin{center}
\AXC{${\vdash_{\Theta}^{\Delta}}\theta' \sim_{names} (\Theta';\Delta') ~~~~~~ T\notin {dom}(\Theta) ~~~~~~ T\notin dom(\Theta')$} \RightLabel{(type-names)}
\UIC{${\vdash_{\Theta}^{\Delta}} \theta';T[\mathbf{explicit},\tau,e_m] \sim_{names} (\Theta',T[?,?];\Delta')$}
\DP
\end{center}

\begin{center}
\AXC{${\vdash_{\Theta}^{\Delta}}\theta' \sim_{names} (\Theta';\Delta') ~~~~~~ T\notin {dom}(\Theta) ~~~~~~ T\notin dom(\Theta')$} \RightLabel{(type-names-2)}
\UIC{${\vdash_{\Theta}^{\Delta}} \theta';T[\mathbf{tykw},k,body,e_m] \sim_{names} (\Theta',T[?,?];\Delta')$}
\DP
\end{center}

\begin{center}
\AXC{${\vdash_{\Theta}^{\Delta}}\theta' \sim_{names} (\Theta';\Delta') ~~~~~~ \nexists~k.(k[\mathbf{ty}(\_,\_)]\in \Delta\Delta')$} \RightLabel{(typetsm-names)}
\UIC{${\vdash_{\Theta}} \theta';k[\mathbf{tytsm}(e,\tau)] \sim_{names} (\Theta';\Delta',k[\mathbf{ty}(?,?)])$}
\DP
\end{center}

\begin{center}
\AXC{${\vdash_{\Theta}^{\Delta}}\theta' \sim_{names} (\Theta';\Delta') ~~~~~~ \nexists~k.(k[\mathbf{syn}(\_,\_)]\in \Delta\Delta' \lor k[\mathbf{ana}(\_)]\in \Delta\Delta')$} \RightLabel{(syntsm-names)}
\UIC{${\vdash_{\Theta}} \theta';k[\mathbf{syntsm}(\tau,e)] \sim_{names} (\Theta';\Delta',k[\mathbf{syn}(?,?)])$}
\DP
\end{center}

\begin{center}
\AXC{${\vdash_{\Theta}^{\Delta}}\theta' \sim_{names} (\Theta';\Delta') ~~~~~~ \nexists~k.(k[\mathbf{syn}(\_,\_)]\in \Delta\Delta' \lor k[\mathbf{ana}(\_)]\in \Delta\Delta')$} \RightLabel{(anatsm-names)}
\UIC{${\vdash_{\Theta}} \theta';k[\mathbf{anatsm}(e)] \sim_{names} (\Theta';\Delta',k[\mathbf{ana}(?)])$}
\DP
\end{center}


\flyingbox{${\myvdash}\theta\sim_{defs} (\Theta;\Delta)$}
\begin{center}
\AXC{} \RightLabel{~~~ (empty-defs)}
\UIC{${\myvdash} \emptyset \sim_{defs} (\emptyset;\emptyset)$}
\DP
\end{center}

\begin{center}
\AXC{${\vdash_{\Theta}}\theta' \sim_{defs} (\Theta';\Delta')$ ~~~~ ${\vdash_{\Theta\Theta'}}\tau$}\RightLabel{(type-defs)}
\UIC{${\myvdash}\theta';T[\mathbf{explicit}(\tau,e_m)] \sim_{defs} (\Theta',T[\tau,?];\Delta)$}
\DP
\end{center}

\begin{center}
\AXC{
	\stackanchor
	{\stackanchor
		{\stackanchor
			{$\Theta_0\subset\Theta$ ~~~~ $\myvdash\theta'\sim_{defs}(\Theta';\Delta')$ ~~~~ $k[\mathbf{ty}(i,\tau_m)]\in\Delta'$}
			{$\texttt{parsestream}(body)=i_{ps}$}
		}
		{$\mathbf{iap}(\mathbf{iprj}[parse](\mathbf{iprj}[parser](i_{k}));i_{ps})\Downarrow(i_{type},i_m)$}
	}
	{$\vdash_{\Theta\Theta'}i_{type}\uparrow \tau$ ~~~~ $\vdash_{\Theta\Theta'} \tau$ ~~~~ $\vdash_{\Theta\Theta'} i_m \Leftarrow \tau_m$}
}\RightLabel{(type-defs-2)}
\UIC{${\myvdash} \theta';T[\mathbf{tsmap}(k,body,e_m)] \sim_{defs} \Theta',T[\tau,i_m:\tau_m]$}
\DP
\end{center}

\begin{center}
\AXC{$\myvdash\theta'\sim_{defs}(\Theta';\Delta')$ ~~~~ $\vdash_{\Theta\Theta'}\tau$ ~~~~ $\vdash_{\Theta\Theta'}^{\Delta\Delta'}e\rightsquigarrow i\Leftarrow\mathbf{named}[TypeParser]$} \RightLabel{(tytsm-defs)}
\UIC{$\myvdash\theta';k[\mathbf{tytsm}(e,\tau)]\sim_{defs}(\Theta';\Delta',k[\mathbf{ty}(i,\tau)])$}
\DP
\end{center}

\begin{center}
\AXC{$\myvdash\theta'\sim_{defs}(\Theta';\Delta')$ ~~~~ $\vdash_{\Theta\Theta'}\tau$} \RightLabel{(syntsm-defs)}
\UIC{$\myvdash\theta';k[\mathbf{syn}(\tau,e)]\sim_{defs}(\Theta';\Delta',k[\mathbf{syn}(\tau,?)])$}
\DP
\end{center}

\begin{center}
\AXC{$\myvdash\theta'\sim_{defs}(\Theta';\Delta')$} \RightLabel{(anatsm-defs)}
\UIC{$\myvdash\theta';k[\mathbf{ana}(e)]\sim_{defs}(\Theta';\Delta',k[\mathbf{ana}(?)])$}
\DP
\end{center}


\flyingbox{${\myvdash}\theta\sim_{exts} (\Theta;\Delta)$}
\begin{center}
\AXC{} \RightLabel{(empty-exts)}
\UIC{${\myvdash} \emptyset \sim_{exts} (\emptyset;\emptyset)$}
\DP
\end{center}

\begin{center}
\AXC{$\vdash^{\Delta}_{\Theta}\theta'\sim_{exts}(\Theta';\Delta')$ ~~~~ $T[\tau,?]\in\Theta$ ~~~~ $\emptyset\vdash^{\Delta\Delta'}_{\Theta\Theta'}e_m\rightsquigarrow i_m\Rightarrow \tau_m$}			\RightLabel{(type-exts)}
\UIC{$\vdash^{\Delta}_{\Theta}\theta';T[\mathbf{explicit}(\tau,e_m)] \sim_{exts} (\Theta',T[\tau,i_m:\tau_m];\Delta')$}
\DP
\end{center}

\begin{center}
\AXC{
	\stackanchor
	{$\vdash^{\Delta}_{\Theta}\theta'\sim_{exts}(\Theta';\Delta')$ ~~~~ $T[\tau,i_m:\tau_m]\in\Theta$}
	{$\vdash_{\Theta\Theta'}^{\Delta\Delta'} e_m\rightsquigarrow i'_m\Leftarrow\mathbf{arrow}(\tau_m,\tau''_m)$ ~~~~ $\mathbf{iap}(i'_m; i_m) \Downarrow i''_m$}
}\RightLabel{(type-exts-2)}
\UIC{$\vdash_{\Theta}\theta';T[\mathbf{tsmap}(k,body,e_m)] \sim_{exts} (\Theta',T[\tau,i'_m:\tau'_m];\Delta')$}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta}^{\Delta}\theta'\sim_{exts}(\Theta';\Delta')$ ~~~~ $k[\mathbf{syn}(\tau,?)]\in \Delta$ ~~~~ $\emptyset\vdash_{\Theta\Theta'}^{\Delta\Delta'}e\rightsquigarrow i\Leftarrow \mathbf{named}[TypeParser]$} \RightLabel{(tytsm-exts)}
\UIC{$\vdash_{\Theta}^{\Delta} \theta';k[\mathbf{ana}(e)]\sim_{exts}(\Theta;\Delta',k[\mathbf{syn}(\tau,i)])$}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta}^{\Delta}\theta'\sim_{exts}(\Theta';\Delta')$ ~~~~ $\emptyset\vdash_{\Theta\Theta'}^{\Delta\Delta'}e\rightsquigarrow i\Leftarrow \mathbf{named}[TypeParser]$}	\RightLabel{(syntsm-exts)}
\UIC{$\vdash_{\Theta}^{\Delta} \theta';k[\mathbf{ana}(e)]\sim_{exts}(\Theta;\Delta',k[\mathbf{ana}(i)])$}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta}^{\Delta}\theta'\sim_{exts}(\Theta';\Delta')$ ~~~~ $k[\mathbf{ty}(i,\tau)]\in\Delta$}	\RightLabel{(anatsm-exts)}
\UIC{$\vdash_{\Theta}^{\Delta} \theta';k[\mathbf{tytsm}(e,\tau)]\sim_{exts}(\Theta;\Delta',k[\mathbf{ty}(i,\tau)])$}
\DP
\end{center}

\doublebox{$\vdash_{\Theta} i\uparrow \tau$}{$\vdash_{\Theta}\tau\downarrow i$}
\begin{center}
\AXC{$\vdash_{\Theta} i\uparrow T$}
\UIC{$\vdash_{\Theta} \mathbf{iinj}[Named](i)\uparrow \mathbf{named}[T]$}
%%% the next rule
\AXC{$T\downarrow i_{id}$}
\UIC{$\mathbf{named}[T]\downarrow \mathbf{iinj}[Named](i_{id})$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta} i\uparrow \omega$}
\UIC{$\vdash_{\Theta} \mathbf{iinj}[Objtype](i)\uparrow \mathbf{objtype}[\omega]$}
%%% the next rule
\AXC{$\omega\downarrow i$}
\UIC{$\mathbf{objtype}[\omega]\downarrow\mathbf{iinj}[Objtype](i)$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta} i\uparrow \chi$}
\UIC{$\vdash_{\Theta} \mathbf{iinj}[Casetype](i)\uparrow \mathbf{casetype}[\chi]$}
%%% the next rule
\AXC{$\chi\downarrow i$}
\UIC{$\mathbf{casetype}[\omega]\downarrow\mathbf{iinj}[Casetype](i)$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta} i_1\uparrow \tau_1$ ~~~~ $\vdash_{\Theta} i_2\uparrow \tau_2$}
\UIC{$\vdash_{\Theta} \mathbf{iinj}[Arrow]((i_1, i_2))\uparrow \mathbf{arrow}(\tau_1,\tau_2)$}
%%%
\AXC{$\tau_1\downarrow i_1$ ~~~~ $\tau_2\downarrow i_2$}
\UIC{$\mathbf{arrow}(\tau_1,\tau_2) \downarrow\mathbf{iinj}[Arrow]((i_1, i_2))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta} i\Leftarrow MemberList$}
\UIC{$\vdash_{\Theta}\mathbf{iinj}[Nil](i)\uparrow \emptyset$}
%%%
\AXC{}
\UIC{$\emptyset \downarrow\mathbf{iinj}[Nil](i)$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{
	\stackanchor
	{$\vdash_{\Theta} i\Leftarrow MemberList$ ~~~~ $i_l\uparrow l$}
	{$\vdash_{\Theta} i_t\uparrow \tau$ ~~~~ $\vdash_{\Theta} i_c\uparrow \omega$}
}
\UIC{$\vdash_{\Theta}\mathbf{iinj}[Cons]((i_l, i_t, i_c))\uparrow l[\tau],\omega$}
%%%
\AXC{$l\downarrow i_l$ ~~~~ $\tau\downarrow i_t$ ~~~~ $\omega\downarrow i_c$}
\UIC{$l[\tau],\omega \downarrow \mathbf{iinj}[Cons]((i_l,i_t,i_c))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta} i\Leftarrow CaseList$}
\UIC{$\vdash_{\Theta}\mathbf{iinj}[Nil](i)\uparrow \emptyset$}
%%%
\AXC{}
\UIC{$\emptyset \downarrow\mathbf{iinj}[Nil](i)$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{
	\stackanchor
	{$\vdash_{\Theta} i\Leftarrow CaseList$ ~~~~ $i_l\uparrow C$}
 	{$\vdash_{\Theta} i_t\uparrow \tau$ ~~~~ $\vdash_{\Theta} i_c\uparrow \chi$}
 }
\UIC{$\vdash_{\Theta}\mathbf{iinj}[Cons]((i_l, i_t, i_c))\uparrow C[\tau],\chi$}
%%%
\AXC{$C\downarrow i_l$ ~~~~ $\tau\downarrow i_t$ ~~~~ $\chi\downarrow i_c$}
\UIC{$C[\tau],\chi \downarrow \mathbf{iinj}[Cons]((i_l,i_t,i_c))$}
\noLine
\BIC{}
\DP
\end{center}

\doublebox{$\vdash_{\Theta}i\uparrow\hat{e}$}{$i\downarrow i$}
\begin{center}
\AXC{$i_{id}\uparrow x$}
\UIC{$\vdash_{\Theta}\mathbf{iinj}[Var](i_{id})\uparrow x$}
%%%
\AXC{$x\downarrow i_{id}$}
\UIC{$x\downarrow \mathbf{iinj}[Var](i_{id})$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta} i_{1}\uparrow \tau$ ~~~~ $\vdash_{\Theta} i_2\uparrow\hat{e}$}
\UIC{$\vdash_{\Theta}\mathbf{iinj}[Asc]((i_1,i_2))\uparrow \mathbf{hasc}[\tau](\hat{e})$}
%%%%
\AXC{$\tau\downarrow i_1$ ~~~~ $i\downarrow i_2$}
\UIC{$\mathbf{iasc}[\tau](i)\downarrow \mathbf{iinj}{Asc}((i_1,i_2))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$i_{id}\uparrow x$ ~~~~ $\vdash_{\Theta}i\uparrow \hat{e}$}
\UIC{$\vdash_{\Theta}\mathbf{iinj}[Lam]((i_{id},i))\uparrow \mathbf{hlam}(x.\hat{e})$}
%%%
\AXC{$x\downarrow i_{id}$ ~~~~ $i\downarrow i'$}
\UIC{$\mathbf{ilam}(x.i)\downarrow \mathbf{iinj}[Lam]((i_{id},i'))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\vdash_{\Theta}i_1\uparrow\hat{e}_1$ ~~~~ $\vdash_{\Theta}i_2\uparrow\hat{e}_2$}
\UIC{$\vdash_{\Theta}\mathbf{iinj}[Ap]((i_1,i_2))\uparrow \mathbf{hap}(\hat{e}_1,\hat{e}_2)$}
%%%
\AXC{$i_1\downarrow i'_1$ ~~~~ $i_2\downarrow i'_2$}
\UIC{$\mathbf{iap}(i_1;i_2)\downarrow \mathbf{iinj}[Ap]((i'_1,i'_2))$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
... ...
\end{center}

\begin{center}
\AXC{$\mathsf{body}(i_{ps})=body$ ~~~~ $\mathsf{eparse}(body)=e$}
\UIC{$\vdash_{\Theta}\mathbf{iinj}[Spliced](i_{ps})\uparrow \mathbf{spliced}[e]$}
\DP
\end{center}


\subsection{Context Formation}

\flyingbox{$\vdash_{\Theta} \Delta$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} \emptyset$}
%%% the next rule
\AXC{$\Theta_{0}\subset\Theta$ ~~~~ $\vdash_{\Theta} \Delta$ ~~~~ $\nexists~k.(k[\mathbf{ty}(\_,\_)]\in\Delta)$ ~~~~ $\vdash_{\Theta}\delta$ ~~~~ $\vdash_{\Theta}\gamma:\mathbf{named}[TypeParser]$}
\UIC{$\vdash_{\Theta}\Delta;k[\mathbf{ty}(\gamma,\delta)]$}
\noLine
\BIC{}
\DP
\end{center}

\begin{center}
\AXC{$\Theta_{0}\subset\Theta$ ~~~~ $\vdash_{\Theta} \Delta$ ~~~~ $\nexists~k.(k[\mathbf{syn}(\_,\_)]\in \Delta\lor k[\mathbf{ana}(\_)]\in \Delta)$ ~~~~ $\vdash_{\Theta}\gamma:\mathbf{named}[ExpParser]$}
\UIC{$\vdash_{\Theta}\Delta;k[\mathbf{ana}(\gamma)]$}
\DP
\end{center}

\begin{center}
\AXC{
	{$\Theta_{0}\subset\Theta$ ~~~~ $\vdash_{\Theta} \Delta$ ~~~~ $\nexists~k.(k[\mathbf{syn}(\_,\_)]\in \Delta\lor k[\mathbf{ana}(\_)]\in \Delta)$} ~~~~
	{$\vdash_{\Theta}\delta$~~~~ $\vdash_{\Theta}\gamma:\mathbf{named}[ExpParser]$}
}
\UIC{$\vdash_{\Theta}\Delta;k[\mathbf{bk}(\delta), \gamma]$}
\DP
\end{center}

\flyingbox{$\vdash \Theta$}
\begin{center}
\AXC{}
\UIC{$\vdash \emptyset$}
%%% the next rule
\AXC{$\vdash \Theta$ ~~~~ $T\notin dom(\Theta)$ ~~~~ $\vdash_{\Theta,T[?,?]}\delta~ok$ ~~~~ $\vdash_{\Theta,T[\delta,?]}\mu~ok$}
\UIC{$\vdash\Theta,T[\delta,\mu]$}
\noLine
\BIC{}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta}{\tau}$}
\begin{center}
\AXC{$\vdash_{\Theta} \omega$}
\UIC{$\vdash_{\Theta} \mathbf{objtype}[\omega]$}
%%% the next rule
\AXC{$\vdash_{\Theta} \chi$}
\UIC{$\vdash_{\Theta} \mathbf{casetype}[\chi]$}
%%% the next rule
\AXC{$\vdash_{\Theta} \tau_1$ ~~~~ $\vdash_{\Theta}\tau_2$}
\UIC{$\vdash_{\Theta} \mathbf{arrow}[\tau_1,\tau_2]$}
%%% the next rule
\AXC{$T[\tau,\mu]\in\Theta$}
\UIC{$\vdash_{\Theta} \mathbf{named}[T]$}
\noLine
\QIC{}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta} \omega$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} \emptyset$}
%%% the next rule
\AXC{$l\notin dom(\omega)$ ~~~~ $\vdash_{\Theta}\tau$ ~~~~ $\vdash_{\Theta}\omega$}
\UIC{$\vdash_{\Theta} l[\mathbf{def},\tau];\omega$}
%%%
\AXC{$l\notin dom(\omega)$ ~~~~ $\vdash_{\Theta}\tau$ ~~~~ $\vdash_{\Theta}\omega$}
\UIC{$\vdash_{\Theta} l[\mathbf{val},\tau];\omega$}
\noLine
\TIC{}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta} \chi$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} \emptyset$}
%%% the next rule
\AXC{$C\notin dom(\chi)$ ~~~~ $\vdash_{\Theta}\tau$ ~~~~ $\vdash_{\Theta}\chi$}
\UIC{$\vdash_{\Theta} C[\tau];\chi$}
\noLine
\BIC{}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta} \delta$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} ?$}
%%% the next rule
\AXC{$\vdash_{\Theta} \tau$}
\UIC{$\vdash_{\Theta} \tau$}
\noLine
\BIC{}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta} \mu$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} ?$}
%%% the next rule
\AXC{$\vdash_{\Theta}\tau$ ~~~~ $\emptyset\vdash_{\Theta} i\Leftarrow \tau$}
\UIC{$\vdash_{\Theta} i:\tau$}
\noLine
\BIC{}
\DP
\end{center}


\flyingbox{$\vdash_{\Theta} \gamma:\tau$}
\begin{center}
\AXC{$\vdash_{\Theta}\tau$}
\UIC{$\vdash_{\Theta} ?:\tau$}
%%% the next rule
\AXC{$\vdash_{\Theta}\tau$ ~~~~ $\emptyset\vdash_{\Theta} i\Leftarrow \tau$}
\UIC{$\vdash_{\Theta} i:\tau$}
\noLine
\BIC{}
\DP
\end{center}

\flyingbox{$\vdash_{\Theta} \Gamma$}
\begin{center}
\AXC{}
\UIC{$\vdash_{\Theta} \emptyset$}
%%% the next rule
\AXC{$\vdash_{\Theta} \Gamma$ ~~~~ $\emptyset\vdash_{\Theta} \tau$}
\UIC{$\vdash_{\Theta} \Gamma,x:\tau$}
\noLine
\BIC{}
\DP
\end{center}

\subsection{Statics for externel terms}

\begin{center}
\AXC{
	\stackanchor{
		\stackanchor
		{$\Theta_0\subset\Theta$ ~~~~ $T[\delta,i_m:\mathbf{named}[HasTSL]]\in\Theta$ ~~~~ $\mathsf{parsestream}(body)=i_{ps}$}
		{$\mathbf{iap}(\mathbf{iprj}[parse](\mathbf{iprj}[parser](i_m));i_{ps})\Downarrow \mathbf{iinj}[OK]((i_{ast},i'_{ps}))$}
	}
	{$i_{ast}\uparrow \hat{e}$ ~~~~ $\Gamma;\emptyset\vdash_{\Theta}\hat{e}\rightsquigarrow i\Leftarrow \mathbf{named}[T]$}
}	\RightLabel{(T-lit)}
\UIC{$\Gamma\vdash_{\Theta}\mathbf{lit}[body]\rightsquigarrow i\Leftarrow \mathbf{named}[T]$}
\DP
\end{center}


\begin{center}
\AXC{$\Theta_0\subset\Theta$ ~~~~ $k[\mathbf{syn}(\tau,i)] \in \Delta$}\RightLabel{(T-syntsmdef)}
\UIC{$\Gamma\myvdash \mathbf{termtsmdef}[k] \rightsquigarrow i\Rightarrow \mathbf{named}[ExpParser]$}
\DP
\end{center}

\begin{center}
\AXC{$\Theta_0\subset\Theta$ ~~~~ $k[\mathbf{ana}(i)] \in \Delta$}\RightLabel{(T-anatsmdef)}
\UIC{$\Gamma\myvdash \mathbf{termtsmdef}[k] \rightsquigarrow i\Rightarrow \mathbf{named}[ExpParser]$}
\DP
\end{center}

\begin{center}
\AXC{$\Theta_0\subset\Theta$ ~~~~ $k[\mathbf{ty}(i,\tau)]\in\Delta$} \RightLabel{(T-typetsmdef)}
\UIC{$\Gamma\myvdash \mathbf{typetsmdef}[k]\rightsquigarrow i \Rightarrow \mathbf{named}[TypeParser]$}
\DP
\end{center}

\begin{center}
\AXC{
	\stackanchor
	{$\Theta_0 \subset \Theta$ ~~~~ $k[\mathbf{ana}(i_k)]\in\Theta$ ~~~~ $\mathsf{parsestream}(body)=i_{ps}$}
	{$\mathbf{iap}(\mathbf{iprj}[parse](i_k); i_{ps});\Downarrow \mathbf{iinj}[OK]((i_{ast}, i'_{ps}))$ ~~~~ $i_{ast}\uparrow \hat{e}$ ~~~~ $\Gamma;\emptyset\myvdash \hat{e} \rightsquigarrow i \Leftarrow \tau$}
}\RightLabel{(T-ana)}
\UIC{$\Gamma\myvdash\mathbf{etsmap}[k,body] \rightsquigarrow i \Leftarrow \tau$}  
\DP
\end{center}

\begin{center}
\AXC{
	\stackanchor
	{$\Theta_0 \subset \Theta$ ~~~~ $k[\mathbf{syn}(\tau,i_k)]\in\Theta$ ~~~~ $\mathsf{parsestream}(body)=i_{ps}$}
	{$\mathbf{iap}(\mathbf{iprj}[parse](i_k); i_{ps})\Downarrow \mathbf{iinj}[OK]((i_{ast}, i'_{ps}))$ ~~~~ $i_{ast}\uparrow \hat{e}$ ~~~~ $\Gamma;\emptyset\myvdash \hat{e} \rightsquigarrow i \Leftarrow \tau$}
} \RightLabel{(T-syn)}
\UIC{$\Gamma\myvdash\mathbf{etsmap}[k,body] \rightsquigarrow i\Rightarrow \tau$}  
\DP
\end{center}

\section{Metatheory}
\begin{theorem}[Internal Type Safety]
If $\vdash\Theta$, and $\emptyset\vdash_{\Theta}i\Leftarrow\tau$ or $\vdash_{\Theta}i\Rightarrow\tau$, then either $i~\texttt{val}$ or $i\mapsto i'$ such that $\emptyset\vdash_{\Theta}i'\Leftarrow\tau$.
\end{theorem}

\begin{theorem}[External Type Preservation]
If $\vdash\Theta$, $\vdash_{\Theta_0\Theta}\Delta$ $\vdash_{\Theta_0\Theta}\Gamma$, and $\Gamma\vdash_{\Theta_0\Theta}^{\Delta} e\rightsquigarrow i\Leftarrow\tau$ or $\Gamma\vdash_{\Theta_0\Theta}^{\Delta} e\rightsquigarrow i\Rightarrow\tau$ then $\Gamma\vdash_{\Theta_0\Theta} i\Leftarrow\tau$.
\end{theorem}

\begin{lemma}[Translational Type Preservation]
If $\vdash\Theta$, $\vdash_{\Theta_0\Theta} \Delta$, $\vdash_{\Theta_0\Theta}\Gamma_{out}$, $\vdash_{\Theta_0\Theta}\Gamma$, $dom(\Gamma_{out})\cap dom(\Gamma)=\emptyset$ and $\Gamma_{out};\Gamma\vdash_{\Theta\Theta_0}^{\Delta}\hat{e}\rightsquigarrow i\Leftarrow\tau$ or $\Gamma_{out};\Gamma\vdash_{\Theta\Theta_0}^{\Delta}\hat{e}\rightsquigarrow i\Rightarrow \tau$ then $\Gamma_{out};\Gamma\vdash_{\Theta_0\Theta}i\Leftarrow \tau$.
\end{lemma}

\begin{theorem}[Compilation]
If ~$\rho\sim(\Theta;\Delta)\rightsquigarrow i:\tau$ then $\vdash\Theta$, $\vdash_{\Theta_0\Theta}\Delta$ and $\emptyset\vdash_{\Theta_0\Theta} i\Leftarrow\tau$.
\end{theorem}



\todo{To be removed}
\begin{theorem}[Internal Type Safety]
If $\vdash\Theta$, and $\emptyset\vdash_{\Theta}i\Leftarrow\tau$ or $\vdash_{\Theta}i\Rightarrow\tau$, then either $i~\texttt{val}$ or $i\mapsto i'$ such that $\emptyset\vdash_{\Theta}i'\Leftarrow\tau$.
\end{theorem}
\begin{proof}
As the keyword extension on TSL framework does not extend internal Wyvern expressions ($i$), and this is the same as the proof in TSL. 
\end{proof}

\begin{theorem}[External Type Preservation]
If ~$\vdash_{\Theta_0}\Delta$, $\vdash\Theta$, $\vdash_{\Theta_0\Theta}\Psi$, $\vdash_{\Theta_0\Theta}\Gamma$, and $\Gamma\vdash_{\Theta_0\Theta}^{\Delta;\Psi} e\rightsquigarrow i\Leftarrow\tau$ or $\Gamma\vdash_{\Theta_0\Theta}^{\Delta;\Psi} e\rightsquigarrow i\Rightarrow\tau$ then $\Gamma\vdash_{\Theta} i\Leftarrow\tau$.
\end{theorem}
\begin{proof}
%Based on TSL proof of the external type preservation, we need to proof the following cases on keywords extension (Expressions for parser access is presented in the \todo{TR}, thus the corresponding proofs of the case for the expression is omitted here. ):
%\begin{itemize}
%\item $e=\mathbf{ekey}[k,body](e)$. According to the rule T-bk and T-wk, $\Gamma\vdash_{\Theta}\mathbf{ekey}[k,body](e_0) \rightsquigarrow i \Rightarrow \tau \Longrightarrow \Gamma;\emptyset\myvdash \hat{e} \rightsquigarrow i \Rightarrow \tau$. According to Lemma 1, $\Gamma;\emptyset\myvdash \hat{e} \rightsquigarrow i \Rightarrow \tau \Longrightarrow \Gamma;\emptyset\vdash_{\Theta} i\Rightarrow\tau$.
%\end{itemize}

To prove the theorem, we only need to consider the keyword invocation term, as other cases have similar proofs to those in TSL paper~\cite{TSLs}.
\begin{itemize}
\item $e=\mathbf{ekey}[k,body]$. 
\end{itemize} 
\end{proof}

\begin{lemma}[Translational Type Preservation]
If $\vdash_{\Theta_0}\Delta$, $\vdash_{\Theta_0}\Theta$, $\vdash_{\Theta_0\Theta}\Psi$ and $\vdash_{\Theta_0\Theta}\Gamma_{out}$, $\vdash_{\Theta_0\Theta}\Gamma$, $dom(\Gamma_{out})\cap dom(\Gamma)=\emptyset$ and $\Gamma_{out};\Gamma\vdash_{\Theta\Theta_0}^{\Delta;\Psi}\hat{e}\rightsquigarrow i\Leftarrow\tau$ or $\Gamma_{out};\Gamma\vdash_{\Theta\Theta_0}^{\Delta;\Psi}\hat{e}\rightsquigarrow i\Rightarrow \tau$ then $\Gamma_{out}\Gamma\vdash_{\Theta}i\Leftarrow \tau$.
\end{lemma}

\begin{theorem}[Compilation]
If ~$\rho\sim\Delta\sim\Theta\sim\Psi\rightsquigarrow i:\tau$~ then $\vdash_{\Theta_0}\Delta$,\ $\vdash_{\Theta_0}\Theta$, $\vdash_{\Theta_0\Theta}\Psi$ and $\emptyset\vdash_{\Theta_0\Theta} i\Leftarrow\tau$.
\end{theorem}
\begin{proof}
This theorem can be proved with the following two lemmas for the formation of $\Delta$ and $\Theta$.
\end{proof}

\begin{lemma}[Type Keyword Declarations] 
If $\vdash_{\Theta_0}\eta\sim\Delta$, then $\vdash_{\Theta_0}\Delta$.
\end{lemma}
\begin{proof}
The proof is simple a induction on $\vdash_{\Theta_0}\Delta$ and using the External Type Preservation Theorem. (Not shown)
\end{proof}

\begin{lemma}[Expression Keyword Declarations] If $\vdash_{\Theta}\kappa\sim\Psi$, then $\vdash_{\Theta}\Psi$.
\end{lemma}

\begin{lemma}[Type Declaration]
If $\vdash_{\Theta_0}^{\Delta}\theta\sim\Theta$ then $\vdash\Theta_0\Theta$.
\end{lemma}
\begin{proof}
By induction on the formation of $\Theta$, we have the following three cases:
\begin{itemize}
\item $\vdash_{\Theta}\emptyset\sim\emptyset \Longrightarrow \vdash{\emptyset}$.
\item ${\vdash^{\Delta}_{\Theta}} \theta';T[\mathbf{explicit},\tau,e_m,\kappa] \sim \Theta',T[\tau,i_m:\tau_m,\dot\kappa] \Longrightarrow \vdash_{\Theta}\Theta',T[\tau,i_m:\tau_m,\dot{\kappa}]$. 

By induction, we have $\vdash_{\Theta}\Theta'$. And by the rule (ctx-explicit-type), we have $\vdash_{\Theta\Theta',T[?,?,?]}^{\Delta}\tau, \myvdash\dot\kappa$ and $\emptyset\vdash_{\Theta\Theta',T[\tau,?,?]}^{\Delta}e\rightsquigarrow i_m\Rightarrow\tau_m$. With External Type Preservation Lemma, we have $\vdash_{\Theta}\Theta',T[\tau,i_m:\tau_m,\dot{\kappa}]$.
\item $\myvdash \theta';T[\mathbf{tykw},k,body,e_m,\kappa] \sim \Theta',T[\tau,i''_m:\tau'_m,\dot{\kappa}\dot{\kappa}'] \Longrightarrow \vdash_{\Theta}\Theta',T[\tau,i''_m:\tau'_m,\dot{\kappa}\dot{\kappa}'].$

By induction, we have $\myvdash\Theta'$. And by rule (ctx-typekw-type), we have (1) $\vdash_{\Theta\Theta',T[?,?,?]}^{\Delta}\tau$. (2).$\dot\kappa\dot\kappa'$ is well formed the the fact that $\myvdash \dot\kappa$~~~~ $\vdash^{\Delta}_{\Theta\Theta',T[\tau,i'_m:\tau'_m,?]}\kappa\rightsquigarrow\dot{\kappa}'$ ~~~~ $dom(\dot{\kappa})\cap dom(\dot{\kappa}')=\emptyset$. (3) $i''_m:\tau'_m$ is well formed by the formation of $i'_m$ and the application of $i'_m$ on $i_m$. Thus we have the formation of the \textbf{tykw} construction.
\end{itemize}
With the three cases proved, we have the formation of type declaration proved.
\end{proof}


\end{document}
