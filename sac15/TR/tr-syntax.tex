%!TEX root=sac15-tr.tex
\section{Syntax}


\begin{figure}[ht]
\hspace{-5px}$\begin{array}{rll}
      &\textbf{Abstract Forms}   & \textbf{Concrete Forms}\\
      \text{Programs}		&	\rho~::=~ d;e\\
      \text{Declarations}	&	d~::=~\emptyset\\
      						&	\mytab d;\mathbf{anatsm}(s,e)          & \textcd{syntax}~s~\textcd{=}~e\\
      						&	\mytab d;\mathbf{syntsm}(s,\tau,e)    & \textcd{syntax}~s : \tau~\textcd{=}~e\\
      						&	\mytab d;\mathbf{tytsm}(s,\kappa, e) & \textcd{syntax}~s::\kappa~\textcd{=}\,e\\
      						& 	\mytab d; \mathbf{tydecl}(\mathtt{T}, \tau, e)  & \textcd{decltype}~\mathtt{T}~\textcd{=}~\tau\\
                            && 	~~~ \textcd{syntax = }e\\
      						& 	\mytab d; \mathbf{tyaptsm}(\mathtt{T}, s, body, e)   & \textcd{decltype}~\mathtt{T}~\textcd{=}~\mathit{s~dform}\\
                            &&	~~~ \textcd{syntax = }e\\
%      \text{Object Fields}\\
%      \omega~::=~\emptyset                      \\
%      \tabularspace l[\mathbf{val},\tau];\omega                 & \textcd{val}~l : \tau\\
%      \tabularspace l[\mathbf{def},\tau];\omega                 & \textcd{def}~l : \tau\\
%      \text{Casetype Cases}\\
%      \chi~::=~\emptyset                      \\                 
%      \tabularspace C[\tau];\chi                   & C~\textcd{of}~\tau\\
      \text{External Terms}	&	e~::= ...                              & \\
      &	\mytab\mathbf{lit}[body]             & \mathit{dform}\\
      &	\mytab\mathbf{eaptsm}[s,body]       & \mathit{s~dform}\\
      \text{Translational Terms}	& \hat{e}~::= ... \\
      								&\mytab\mathbf{spliced}[e] \\
      \text{Internal Terms}			& i~::= ...
  \end{array}$
\mycaption{Abstract and concrete forms for declarations and terms. Metavariable $s$ ranges over TSM names, $\mathtt{T}$ over type names, $dform$ over delimited forms in the main paper, and $body$ over their bodies. Translational and internal terms are used in the semantics only. Elided forms are given in \cite{TSLs}.}
\label{formal-syntax}
\end{figure}

In the pure functional Wyvern definition, a Wyvern program consists two parts: 1) declarations $d$, consisting of both TSM declarations and type declarations and 2) an external term $e$ representing the program body.

\paragraph{Declarations}
The declarations for analytical TSM has the abstract form $\mathbf{anatsm}(s,e)$, consisting of the macro name $s$ and the parser associated with the macro $e$. A synthetic TSM declaration is different in the sense that the type $\tau$ of the TSM is explicitly declared, and a type-level TSM contains the kind information $\kappa$ for the type along with its macro name $s$ and parser $e$.

The type declarations contain two forms, namely explicit type declaration and type-level TSM application. An explicit type declaration $\mathbf{tydecl}(\mathtt{T},\tau,e)$ contains the type name $\mathtt{T}$, the type structure $\tau$ and the optional associate TSL parser $e$. To define a type using a type-level TSM, one should replace the type structure $\tau$, defined in Fig.~\ref{syntax-types}, with a TSM application term: $s \mathit{dform}$, by applying the type level TSM $s$ to the literals in delimited forms $\mathit{dforms}$, the type structure will be generated during the elaboration phase, which will be presented in the Sec.~\ref{tr-semantics}.

\paragraph{Terms} Together with TSL external term forms, we supplement an expression $\mathbf{eaptsm}[s,body]$, which allows users to directly access the parser inside a TSM declaration. The external terms will elaborate to internal Wyvern terms, which contain neither literals nor the form for accessing the TSM or TSL parsers of a named type or macro explicitly, during the elaboration phase. The elaboration rules will be described in the next section.

\paragraph{Types and Kinds}
Wyvern types and kinds are described below in Fig.~\ref{syntax-types}. With type operators and kinds defined, we enable users to define type parameters within the language. Translational types are used for hygiene purpose in the elaboration phase for parameterized types.

\begin{figure}[ht]
\[
	\begin{array}{llcl}
      \text{Kinds}\\
      \mytab	\kappa ::=  \mathtt{Ty}  ~|~ \kappa \rightarrow \kappa\\
      \text{Types}\\
      \mytab	 \tau  ::=  \mathtt{T} ~|~ \tau \rightarrow \tau ~|~ \mathbf{objtype}[\omega] ~|~ \mathbf{casetype}[\chi] ~|~  t ~|~ \lambda[\kappa](t.\tau) ~|~ \tau(\tau) \\
      \text{Translational Types}\\
      \mytab\hat{\tau} ~ ::= ... ~|~ \mathbf{spliced}[\tau]
  \end{array}
\]
\mycaption{Syntax for types and kinds. Metavariable $t$ ranges over type variables. Object type and case type declarations $\omega$ and $\chi$ are taken from \cite{TSLs}.
%Metavariable $T$ ranges over type names, $l$ over member labels, $C$ over case names, $x$ over term variables, $X$ over type variables.
}\label{syntax-types}
\end{figure}