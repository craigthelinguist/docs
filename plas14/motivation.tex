% !TEX root = plas14.tex

\section{Introduction / Motivation}

\todo{Revise, rewrite.}

Weaknesses categorized as \emph{injection vulnerabilities} have topped
rankings of the most critical web application vulnerabilities for
several years in a row amongst industry groups \cite{owasp, cwsans}.
Web application vulnerabilities achieve top rankings by being quite
onerous. Injection vulnerabilities are tedious and
difficult to prevent, and are often easily exploitable with
severe technical consequences.

Injection vulnerabilities can occur anywhere that user input may be erroneously
executed as code. In essence, an injection attack on a web application
occurs when a user---anyone with access to the application and a
vulnerable input field---submits maliciously crafted input that has
been made to appear and execute as code in a specific browser context.
The term \emph{browser context} refers to the browser's parsing state
when processing a string. If the browser is parsing a string as HTML,
it is in an HTML context. Likewise, if the browser has determined
a string is CSS and is processing it using its CSS engine, we call
the context the CSS context.

Given an injection vulnerability, the browser context gives us a clue
of what specific category the vulnerability falls under.
For example, a malicious input that can force the browser into a Javascript
context, for example by including a \texttt{<script>} tag within the HTML,
is typically referred to as a Cross-Site Scripting (XSS) vulnerability.
Additionally, the browser context helps us determine a sound way to
fix the vulnerability. An input that is supposed to appear in an HTML
context can be HTML entity encoded, for example replacing control characters such
as \texttt{<} with escapes such as \texttt{\&lt};, to ensure that the browser will
not change to an unintended context and process it as code. 

The injected input is typically aimed at changing the browser or web application's
behavior, altering state at the client or server, or stealing information.
Injection vulnerabilities are exploited by attackers to achieve goals such as
gaining unauthorized access to the system or to private information
within it, corrupting the system's data, or disturbing system availability.

There are many ways to exploit injection vulnerabilities. An attacker could use their own browser to directly exploit a vulnerability, or they could trick an unsuspecting victim into running the exploit by clicking a link or visiting a malicious page. There are also tools such as sqlmap \cite{sqlmap} that are capable of automatically finding
and exploiting SQL injection (SQLi) vulnerabilities, even ones that would
be complicated for a human to exploit. Given these diverse sources
of attacks and the ability for an attacker to cause damage to the
application and victimize the application's users, developers have
great incentive to avoid injection vulnerabilities.


\subsection{Motivating Example}

\todo{Revise, rewrite, add.}

Web blogs are a convenient
example of such an application. A web blog, or simply a blog, is a
website that promotes discussion and information sharing on a specific
topic or a set of topics and that consists of discrete entries called posts.
Typically, a blog author will write posts by typing up the message
and formatting it in a text field that is available only to the blog's
authors. This message is later published for public consumption. The
post author formats their post by using HTML and CSS. However, the
post author does not need access to the full subset of HTML, and there
is in fact a lot of incentive for blog hosting providers (e.g. Blogger
\cite{blogger}) to limit the HTML/CSS tags that are available. In other words, sometimes the developer wants to override the default of non-executability, but control execution by limiting the set of tags that are interpreted by the browser.

Due to their relative simplicity and ubiquity, we use XSS and SQLi
vulnerabilities as the platform for illustrating our approach. The
approach generalizes to other web application injection vulnerabilities.
Figure \ref{fig:Motivating-Example-Code} shows a simple example that
contains an XSS and SQLi vulnerability in a PHP-like psuedocode. This
sample presents the user with a prompt to enter her username. When
the user enters her username and hits the submit button, a SQL query
is executed to get her last login time from a database table named
UserLog. Her last login time is then printed in a message below
the form, along with the username she entered. 

A SQLi vulnerability exists because the username the user entered
is concatenated into the SQL statement exactly as it was entered.
If the user had entered SQL code as their username instead, the extra
SQL statements they entered would be executed by the database. For
example, entering \texttt{';DROP TABLE UserLog; -{}- }as the username
would cause the UserLog table to be deleted from the database. The
attacker could have just as easily injected SQL to perform operations
such as adding fake data to the database, dumping the contents of
the database to try to steal password hashes, etc. 

The XSS vulnerability is equally simple.
The XSS vulnerability exists because the user name is being directly
written to a context the attacker can leverage to execute Javascript.
An attacker could enter the username \texttt{<script> alert(``XSS!''); </script>},
thus causing a Javascript pop-up to appear. The XSS exploit could
have also read the user's cookie and sent it to a different website,
defaced the website to turn it into a phishing form, or set-up a \texttt{document.onkeypress}
event handler to keylog the webpage. These exploits don't need to
be entered into the form directly.

The form uses the HTTP GET method, which allows the attacker to enter
his exploit into the URL using the \texttt{usr} parameter. As a
result, the attacker could craft a URL that contains the exploit and
trick a user into clicking the malicious link, thus causing the user's
browser to execute the exploit instead.


\begin{figure}
\begin{lstlisting}
let user_input_s = readline_user
let author_input_s = readline_author
let user_input : HTML = parse_user(user_input_s)
let author_input : HTML_A = parse_author(author_input_s)
let page : HTML = ~
   >html
      >title Best Author's Blog
      >body
      >h1 Post Title
      >div
         < admin_input : HTML_A (* htmla_to_html(author_input)*)
      >h2 Comments
      >div
         < user_input
      ... 
\end{lstlisting}
\caption{A Wyvern Example}
\label{fig:wyvern-example}
\end{figure}


\begin{figure}
\begin{lstlisting}
casetype HTML_A
   IFrame of HTMLA
   Div of HTMLA
   ...

casetype HTML
   Div of HTML
   ...
\end{lstlisting}
\caption{Wyvern HTML Type}
\label{fig:wyvern-example}
\end{figure}
