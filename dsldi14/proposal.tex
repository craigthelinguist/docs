\documentclass[letterpaper, notitlepage]{article}
\usepackage{bussproofs}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames]{color} % Required for specifying custom colors and referring to colors by name
\usepackage{listings}
\usepackage[top=1in, bottom=1in, left=1.25in, right=1.25in]{geometry}
\usepackage{xcolor}
\usepackage{parcolumns}
\usepackage{bera}% optional; just for the example
\usepackage[font=small,labelfont=bf]{caption}

\definecolor{DarkGreen}{rgb}{0.0,0.4,0.0} % Comment color
\definecolor{highlight}{RGB}{255,251,204} % Code highlight color
% This is the "centered" symbol
\def\fCenter{{\mbox{\Large$\rightarrow$}}}

% Optional to turn on the short abbreviations
\EnableBpAbbreviations

% This is the "centered" symbol
\def\fCenter{{\mbox{\Large$\rightarrow$}}}

\newcommand{\blue}[1] {\textcolor{blue}{#1}}
\newcommand{\flyingbox}[1]{\begin{flushleft}\fbox{{#1}}\end{flushleft}}
\newcommand{\doublebox}[2]{\begin{flushleft}\fbox{{#1}}\ \fbox{{#2}}\end{flushleft}}
\newcommand{\myvdash}{\vdash_{\Theta}^{\Delta_{\kappa}}}
\newcommand{\todo}[1]{{\bf \{TODO: {#1}\}}}
\newcommand{\code}[1]{\texttt{\footnotesize #1}}

% Optional to turn on the short abbreviations
\EnableBpAbbreviations

% \alwaysRootAtTop  % makes proofs upside down
% \alwaysRootAtBottom % -- this is the default setting

\lstdefinestyle{wyvern}{ % Define a style for your code snippet, multiple definitions can be made if, for example, you wish to insert multiple code snippets using different programming languages into one document
%backgroundcolor=\color{highlight}, % Set the background color for the snippet - useful for highlighting
basicstyle=\footnotesize\ttfamily, % The default font size and style of the code
breakatwhitespace=false, % If true, only allows line breaks at white space
breaklines=true, % Automatic line breaking (prevents code from protruding outside the box)
captionpos=b, % Sets the caption position: b for bottom; t for top
commentstyle=\usefont{T1}{pcr}{m}{sl}\color{DarkGreen}, % Style of comments within the code - dark green courier font
deletekeywords={}, % If you want to delete any keywords from the current language separate them by commas
%escapeinside={\%}, % This allows you to escape to LaTeX using the character in the bracket
firstnumber=1, % Line numbers begin at line 1
frame=lines, % Frame around the code box, value can be: none, leftline, topline, bottomline, lines, single, shadowbox
frameround=tttt, % Rounds the corners of the frame for the top left, top right, bottom left and bottom right positions
keywords=[1]{new, objtype, type, casetype, val, def, metadata, keyword, of, fn},
keywordstyle={[1]\ttfamily\color{blue!90!black}},
keywordstyle={[3]\ttfamily\color{red!80!orange}},
morekeywords={}, % Add any functions no included by default here separated by commas
numbers=left, % Location of line numbers, can take the values of: none, left, right
numbersep=8pt, % Distance of line numbers from the code box
numberstyle=\tiny\color{Gray}, % Style used for line numbers
rulecolor=\color{black}, % Frame border color
showstringspaces=false, % Don't put marks in string spaces
showtabs=false, % Display tabs in the code as lines
stepnumber=1, % The step distance between line numbers, i.e. how often will lines be numbered
tabsize=4, % Number of spaces per tab in the code
}



\begin{document}
\title{Composable Syntax Macros}
\author{Stanley Wang, Cyrus Omar and Jonathan Aldrich\\
Carnegie Mellon University\\
\{stwong,comar,aldrich\}@cs.cmu.edu}
\date{}
\maketitle

\section{Introduction}
Domain specific languages are designed to solve problems in certain domains. An user benefits from the clear notation and powerful expressiveness using DSLs to solve these problems. However, in a complicated project, problems from different domains come up together thus no DSL alone is sufficient. Thus general purpose languages like Java are always used in this situation rather DSLs. Common ways to deal with problems in certain domains in general purpose languages are either building libraries in the language with APIs exporting to users, or encoding DSLs as strings arguments to DSL engines. But both ways have their flaws, as exporting complicated library calls always leads to redundant code while using strings to represent DSLs may damage the safety of the language.
\par
Based on our previous Type-Specific Languages works, we extend the language with the ability to access of DSLs using expression keywords, which enable user encoding expressions using DSL. With extensible keywords, users are allowed to switch between host languages and DSLs. Our talk includes the usage and the mechanisms we build to support syntax extension using keywords.

\section{Extensible Keywords in Wyvern}
In this section, we show several examples built in wyvern to illustrate the usage of both "black-box" keywords and "white-box" keywords. Generally speaking, a "black-box" keyword is declared with a return type, thus the return type is determined without referring to the inner expression it transformed to. While a "white-box" keyword is not, the return type of the "white-box" keyword will be derived from the internal expression after literal transformation.
\par
We begin with a "black-box" keyword example of constructing XML using literals with user defined syntax. Using TSL mechanism, we are able to construct a value of type XML using XML dsl literals. On the left side of Figure.\ref{xml}, XML code is inserted into Wyvern to construct \texttt{x}. The parser defined in metadata of the type XML will be used to parse the literals and then initialize fields and methods in object. 
\par
But once the user want to use an alternative syntax to build the object, for example, using a simpler representation of data structure to build XML, TSL alone is not enough. Thus a 'black-box' expression keyword is used in this case to extend TSL expressiveness. The keyword \texttt{simpleXML} is declared with a return type (\texttt{XML}) and a parser. The return type indicates that the literal will be transformed into an expression of XML type, which will be used during typechecking process, while the parser is used to transform the listerals into an expression. The usage is presented on the right side of Fig.\ref{xml}. We use abbreviated literals to construct an XML value with keyword \texttt{simpleXML}, which has the same effect as the example on the left side.

\begin{figure*}[htb!]
\begin{parcolumns}{2}
\colchunk[1]{
\begin{lstlisting}[style=wyvern]
type XML = casetype 
  ...
  metadata = new : HasTSL
    val parser = ~
      ... (parser for standard XML syntax)
val x : XML = ~
  <book id=1>
    <title>XXX</title>
    <author>XXX</author>
  </book>
\end{lstlisting}}
\colchunk[2]{
\begin{lstlisting}[style=wyvern]
keyword simpleXML : XML = new
  val parser = ~
    ... (parser for simple XML syntax)
val x : XML = simpleXML ~
  >book[id=1]
    >title XXX
    >author XXX
\end{lstlisting}
}\end{parcolumns}
\vspace{-10px}
\caption{Building a value of type XML using a TSL providing the standard syntax (left) or using a ``black-box'' expression keyword providing a simpler layout-sensitive syntax (right).}
\label{xml}
\end{figure*}

\begin{figure*}[htb!]
\begin{center}
\begin{lstlisting}[style=wyvern]
type Bool = casetype
  True
  False
  keyword if = new
    val parser = fn self => ~
      EXP BOUNDARY 'else' BOUNDARY EXP
        fn e1, e2 => ~
          case %self%
            True => %e1%
            False => %e2%
x:Bool = ...
x.if {branch_1} else {branch_2}
\end{lstlisting}
\end{center}
\caption{``White-box'' keyword \texttt{if} defined as a member of  type \texttt{Bool}}
\label{if}
\end{figure*}
\par

Another example presented below is the usage of a "white-box" keyword \texttt{if} in Fig.\ref{if}. Type Bool is defined as a casetype with two cases, namely True and False. The general way to use a Bool value in condition switch is to write a condition expression and associate each condition with a branch expression, which can be redundant if there exists too many cases inside the type. And we can deal with this defining a "white-box" keyword \texttt{if} inside type \texttt{Bool}. Case analysis is no longer necessary in the syntax (line 6) and with two branch expression written in the literals, the parser defined in line 5 will transform the literals into the usage with case analysis. By "white-box" keyword in this case, it means that the return type of the invocation of \texttt{if} will not be determined before transformation. And the return type will be determined from the expression after transformation, which allows more flexible usage of expression types.

\section{Mechanisms to support keyword extension}
The mechanism used to support expression keyword macros include indent delimited parsing and hygiene, which are designed in our TSL paper. By entending the formal system based on TSL, we are able to support the usage of keywords. Details will be presented in our talks.

\section{Reference}

\end{document}



