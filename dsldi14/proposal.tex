\documentclass[letterpaper, notitlepage]{article}
\usepackage{bussproofs}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames]{color} % Required for specifying custom colors and referring to colors by name
\usepackage{listings}
\usepackage[top=1in, bottom=1in, left=1.25in, right=1.25in]{geometry}
\usepackage{xcolor}
\usepackage{parcolumns}
\usepackage{bera}% optional; just for the example
\usepackage[font=small,labelfont=bf]{caption}

\definecolor{DarkGreen}{rgb}{0.0,0.4,0.0} % Comment color
\definecolor{highlight}{RGB}{255,251,204} % Code highlight color
% This is the "centered" symbol
\def\fCenter{{\mbox{\Large$\rightarrow$}}}

% Optional to turn on the short abbreviations
\EnableBpAbbreviations

% This is the "centered" symbol
\def\fCenter{{\mbox{\Large$\rightarrow$}}}

\newcommand{\blue}[1] {\textcolor{blue}{#1}}
\newcommand{\flyingbox}[1]{\begin{flushleft}\fbox{{#1}}\end{flushleft}}
\newcommand{\doublebox}[2]{\begin{flushleft}\fbox{{#1}}\ \fbox{{#2}}\end{flushleft}}
\newcommand{\myvdash}{\vdash_{\Theta}^{\Delta_{\kappa}}}
\newcommand{\todo}[1]{{\bf \{TODO: {#1}\}}}
\newcommand{\code}[1]{\texttt{\footnotesize #1}}

% Optional to turn on the short abbreviations
\EnableBpAbbreviations

% \alwaysRootAtTop  % makes proofs upside down
% \alwaysRootAtBottom % -- this is the default setting

\lstdefinestyle{wyvern}{ % Define a style for your code snippet, multiple definitions can be made if, for example, you wish to insert multiple code snippets using different programming languages into one document
%backgroundcolor=\color{highlight}, % Set the background color for the snippet - useful for highlighting
basicstyle=\footnotesize\ttfamily, % The default font size and style of the code
breakatwhitespace=false, % If true, only allows line breaks at white space
breaklines=true, % Automatic line breaking (prevents code from protruding outside the box)
captionpos=b, % Sets the caption position: b for bottom; t for top
commentstyle=\usefont{T1}{pcr}{m}{sl}\color{DarkGreen}, % Style of comments within the code - dark green courier font
deletekeywords={}, % If you want to delete any keywords from the current language separate them by commas
%escapeinside={\%}, % This allows you to escape to LaTeX using the character in the bracket
firstnumber=1, % Line numbers begin at line 1
frame=lines, % Frame around the code box, value can be: none, leftline, topline, bottomline, lines, single, shadowbox
frameround=tttt, % Rounds the corners of the frame for the top left, top right, bottom left and bottom right positions
keywords=[1]{new, objtype, type, casetype, val, def, metadata, keyword, of},
keywordstyle={[1]\ttfamily\color{blue!90!black}},
keywordstyle={[3]\ttfamily\color{red!80!orange}},
morekeywords={}, % Add any functions no included by default here separated by commas
numbers=left, % Location of line numbers, can take the values of: none, left, right
numbersep=8pt, % Distance of line numbers from the code box
numberstyle=\tiny\color{Gray}, % Style used for line numbers
rulecolor=\color{black}, % Frame border color
showstringspaces=false, % Don't put marks in string spaces
showtabs=false, % Display tabs in the code as lines
stepnumber=5, % The step distance between line numbers, i.e. how often will lines be numbered
tabsize=4, % Number of spaces per tab in the code
}


\begin{document}
\section{Introduction}
Domain specific languages are designed specially to solve problems in a particular domain. An user benefits from the clear notation and powerful expressiveness using DSLs to solve certain problems. However, in a complicated project, problems from different domains come up together thus no DSL alone is sufficient. Thus general purpose languages like Java are always used instead of DSLs. Common ways to deal with problems in certain domains in general purpose languages are building libraries in the language and exporting API calls to user, or using strings to represent DSLs and using strings as arguments to be passed to DSL engines. But both ways have their flaws, as exporting complicated library calls always leads to redundant code while using strings to represent DSLs may damage the safety of the language.
\par
Based on our previous Type-Specific Languages works, we extend the language with the ability to access of DSLs using user-defined type-associated keywords. With extensible keywords, users are allowed to switch between host languages and DSLs in expression level, or create a type using DSLs. In the following section, we will give an example using keywords mechanism to extend host language with user defined DSL libraries.

\section{Extensible Keywords in Wyvern}
We begin with an extensible keywords example of building XML from user defined syntax. In our TSL works, we are able to construct an object using dsl literals. On the left side of Figure.\ref{xml}, we directly insert the XML literals into the host language, and the parser defined in metadata of the type XML will be used to parse the literals inside and then initialize the object. But in some cases, the user may use other format literals to generate the XML object for simplicity. Thus expression keywords are used in this case to extend TSL expressiveness. On the right side of Figure.\ref{xml}, we use the keyword toXML to construct an object. The keyword toXML, defined as a global keyword, acts like an expression as it takes in DSL literals and then return an object of XML type. In this way, literals in the right side of figure 1 will be parsed by the parser declared in the keyword declaration. 

\begin{figure*}[htb]
\begin{parcolumns}{2}
\colchunk[1]{
\begin{lstlisting}[style=wyvern]
type XML = objtype
	metadata = new : HasTSL
		val parser ~
			...
val x : XML = ~
	<book id=1>
		<title> XXX </title>
		<Author> XXX </Author>
	</book>
\end{lstlisting}
}
\colchunk[2]{
\begin{lstlisting}[style=wyvern]
type XML = objtype
	... (* XML definition as before *)
keyword toXML : XML = new : ExprKw
	val parser = ~
		...
val x : XML = toXML ~
	book : id = 1
		title : XXX
		author : XXX
\end{lstlisting}
}
\end{parcolumns}
\caption{Building XML object using TSL and expression keyword}
\label{xml}
\end{figure*}

\begin{figure*}[htb!]
\begin{parcolumns}{2}
\colchunk[1]{
\begin{lstlisting}[style=wyvern, caption=Keyword 'if' defined in type Bool]
type Bool = casetype
	case True
	case Talse
	keyword if:ExprKw = new ~
		... (* Keyword parser *)

x:Bool = ...
x.if {[exp] else [exp]}
\end{lstlisting}
\begin{lstlisting}[style=wyvern, caption=DB example with type keyword and TSL]
type DB = DBSchema ~
	Table Employee 
		ID  int,
		Name char(50)

val d : DB = ~ 
	content to <mysql://localhost:3306/>
	as "username":"password"
\end{lstlisting}
}
\colchunk[2]{
\begin{lstlisting}[style=wyvern, caption=The DB example after elaboration to inner wyvern code]
type DB = objtype 
  	val connection : URL
  	val username : String
  	val password : String
  	val connect() : bool
  	val stmts (s:SQL) : List
  	val Employee : objtype
		def getID (x:Int) : List
		def getName (x:String) : List
	metadata = new : HasTSL
		parser = ~ 
			...
val d : DB = new
 	val connection = "<mysql://localhost:3306/>" 
  	val username = "username" 
  	... (* other fields definition *)
  	val Employee = new
  		...
		def getID (x:Int) : List = stmts({~})
	    	SELECT * FROM Employee WHERE id=%x%
\end{lstlisting}
}
\end{parcolumns}
\end{figure*}
\par
Another example is the usage of keyword \texttt{if} in Listing 1. Bool here is defined as a casetype, and when we use the type in a branch condition, we need to do case analysis first. But with the definition of \texttt{if} as a keyword inside type \texttt{Bool}, we can use an abbreviate form to write the branch condition. The parser will access the variable and transform it into a branch condition with case analysis. Thus expression keywords enable more flexible representation of expressions.
\par
In a more complicated example, we present the usage of Type Keywords along with TSL. In this example, we first declare a type DB using Type Keyword, we declare the structure we want to use to map to the database. And fields and methods in the type will be generated automatically by parser. The type will be transformed to the more complicated representation after parsing presented in Listing 3. Besides generating the type structure, a TSL metadata will also be generated by the parser to construct the type. The value \texttt{d} in the example will be constructed with DSL literals, which will be elaborated to the right side construction code. And this bridge the usage of keyword type construction with the object initialization using TSL.

\section{Mechanisms to support keyword extension}
To achieve the goal of integrating extensible keywords in the host language, we need mechanisms to support indent delimits parsing, code transformation and hygiene. Detailed formal rules for these mechanisms are not presented here for brevity consideration.
\par
Parsing and transformation are of the same method we use in TSL paper. Expression keywords here are associated with the type name to make the extension composable while type keywords are defined in global environment with package name to avoid conflicts in different imports.
\end{document}



