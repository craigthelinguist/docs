\documentclass[runningheads]{llncs}

\usepackage{times}

\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage[T1]{fontenc}
%\usepackage[defaultmono]{droidmono}
\usepackage{proof,amssymb,enumerate}
\usepackage{math-cmds}
\usepackage{listings}
%\setcounter{tocdepth}{3}
%\renewcommand*\ttdefault{txtt}
\usepackage[scaled]{beramono}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{graphicx}
\usepackage{url}
\usepackage{mathtools}
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}
\usepackage{caption}
\usepackage{subcaption}
\captionsetup{compatibility=false}

\usepackage{fancyvrb}
\renewcommand{\theFancyVerbLine}{%
\color{gray}\ttfamily{\scriptsize
\arabic{FancyVerbLine}}}

\def\implies{\Rightarrow}
\newcommand{\TODO}[1]{\textbf{[TODO: #1]}}
\newcommand{\keyw}[1]{\textbf{#1}}
\newcommand{\minisec}[1]{\vspace{2ex}\noindent\textbf{#1}}


\newtheorem{thm}{Theorem}
\newtheorem{dfn}{Definition}

\lstset{tabsize=2, 
basicstyle=\ttfamily\fontsize{8pt}{1em}\selectfont, 
commentstyle=\itshape\ttfamily, 
stringstyle=\ttfamily,
numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily, language=ML,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,xleftmargin=15pt, morekeywords=[1]{tyfam,opfam,let,fn,val,def,casetype,objtype,metadata,of,*,datatype,new,toast,from,import,architecture,connect,component,package,resource,class,this,language},deletekeywords={for,double,in,type},classoffset=0,belowskip=\smallskipamount,
moredelim=**[is][\color{cyan}]{SSTR}{ESTR},
moredelim=**[is][\color{OliveGreen}]{SHTML}{EHTML},
moredelim=**[is][\color{purple}]{SCSS}{ECSS},
moredelim=**[is][\color{brown}]{SSQL}{ESQL},
moredelim=**[is][\color{orange}]{SCOLOR}{ECOLOR},
moredelim=**[is][\color{magenta}]{SPCT}{EPCT}, 
moredelim=**[is][\color{gray}]{SNAT}{ENDNAT}, 
moredelim=**[is][\color{blue}]{SURL}{EURL},
moredelim=**[is][\color{SeaGreen}]{SQT}{EQT},
moredelim=**[is][\color{Periwinkle}]{SGRM}{EGRM},
moredelim=**[is][\color{Sepia}]{SID}{EID},
moredelim=**[is][\color{Sepia}]{SUS}{EUS}
}
\lstloadlanguages{Java,VBScript,XML,HTML}


\let\li\lstinline

%% Save the class definition of \subparagraph
\let\llncssubparagraph\subparagraph
%% Provide a definition to \subparagraph to keep titlesec happy
\let\subparagraph\paragraph
%% Load titlesec
\usepackage[compact]{titlesec}
%% Revert \subparagraph to the llncs definition
\let\subparagraph\llncssubparagraph


\begin{document}

\title{Language-Based Architectural Control}
%\author{~}
%\institute{~}
\author{Jonathan Aldrich \and others$^{1}$}
\institute{Carnegie Mellon University and Victoria University of Wellington$^{1}$\\
\texttt{\scriptsize \{aldrich\}@cs.cmu.edu}
and
\texttt{\scriptsize others@ecs.vuw.ac.nz}$^{1}$}
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}
\authorrunning{Aldrich, ...} % To fix excessive length.

\maketitle

\begin{sloppypar}
\begin{abstract}
%The abstract should summarize the contents of the paper and should
%contain at least 70 and at most 150 words. It should be written using the
%\emph{abstract} environment.
Software architects design systems to achieve quality attributes like security, reliability, and performance. Key to achieving these quality attributes are design constraints governing how components of the system  are configured, communicate and access resources. Unfortunately, identifying, specifying, communicating and enforcing important design  constraints -- achieving \emph{architectural control} -- can be difficult, particularly in large software systems.

We argue for the development of architectural frameworks, built atop language mechanisms that provide for  domain-specific syntax, editor services and explicit control over capabilities, that help increase architectural control. In particular, we argue for concise, centralized architectural descriptions which are responsible for specifying constraints and passing a minimal set of capabilities to downstream system components, or explicitly entrusting them to individuals within a team. By integrating these architectural descriptions directly into the language, the type system can help enforce technical constraints and editor services can help enforce social constraints. We sketch our approach in the context of distributed systems.

\keywords{software architecture;
architectural control;
distributed systems;
capabilities;
layered architectures;
alias control;
domain specific languages}

\end{abstract}

\section{Motivation: Architecture and System Qualities}
%Software architects are tasked with precisely formulating a software system's goals and enforcing technical and social constraints that can achieve this goals as the system evolves. 
The central task of a software architect is designing an architecture that enables the designed system's central goals to be achieved~\cite{bass-software-architecture-in-practice}.  Typically many designs can support the intended functionality of a system; what distinguishes a good architecture from a bad one is how well the design achieves \emph{quality attributes} such as security, reliability, and performance.

Quality attribute goals can often be satisfied by imposing architectural constraints on the system.  For example, the principle of least privilege is a well-known architectural constraint; it limits the privileges of each component to the minimum necessary to support the component's functionality, thus enhancing the security of a system.  Likewise, constraints concerning the redundance and independence of failure-prone components can aid in achieving reliability concerns.  Broadly speaking, a constraint is architectural in nature if it is essential to achieving critical system-wide quality attributes.

Unfortunately, delivering systems with desired qualities can be challenging in practice.  Two significant sources of the challenge include missed or incorrect constraints, and inadequate constraint enforcement.  If an architect is not an expert in a software system's target domain, the architect may miss constraints that are important to achieving goals in that domain.  For example, many architects who were not familiar with the intricacies of Secure Sockets Layer (SSL) configured their SSL libraries to unnecessarily use a heartbeat protocol,\footnote{SSL's heartbeat feature is only needed for long-lasting, possibly idle connections} and/or neglected to properly enable SSL certificate checking.  The result was exposure to the Heartbleed bug in the first case~\cite{Heartbleed}, and to a man-in-the-middle attack in the second~\cite{most-dangerous-code-in-the-world}.

Even if the relevant constraints are identified and specified correctly by the architect, ensuring that they are followed can be quite difficult.  A standard defense against SQL injection attacks, for example, is ensuring that prepared statements are used to construct SQL queries.  Ensuring that this constraint if followed, however, requires scanning all SQL queries in the entire program; any query that is missed could potentially violate the policy.  Similar issues apply to common defenses against other attacks, such as cross-site scripting (XSS).


\section{Architectural Control}

The problems above suggest that in practice, architects do not have sufficient control of the architecture of their software systems.  \emph{\textbf{Architectural control}} is the ability of software architects to ensure that they have identified, specified, and enforced design constraints that are sufficient for the system's implementation to meet its goals.  Although tools can aid in achieving architectural control---and in fact, this paper proposes ways of building better tools for doing so---our definition of the term is focused on the practice of software engineering, which can be enhanced by tools but not replaced by them.

Today, architects use primarily informal processes to achieve architectural control.  To learn about the constraints relevant in a domain, they learn from domain experts and consult documentation of frameworks that capture domain knowledge.  To enforce the constraints they specify, they rely on informal communication with the engineers building the system, as well as quality-control practices such as testing, inspection, and static analysis.  Unfortunately, testing is good at evaluating functionality but is poorly suited to enforcing many quality attributes; inspection can work well but is limited by the fallibility of the humans carrying it out; and static analysis tools are often too low-level to directly enforce the desired qualities.  As a result, the degree of architectural control achieved in practice often falls short of what is needed to produce highly reliable and secure systems.


\minisec{Architectural Control in Java.}  To illustrate the challenges with achieving architectural control in the state of the practice, consider the problem of achieving architectural control for a simple distributed system to be illustrated in Java.  We will examine a simple sub-problem: understanding what messages are sent over the network, and ensuring the correct protocol is used.  Such an understanding is useful for a security analyst to assess the attack surface of the system; for a reliability analysis of what might occur if a network link fails; or for a performance analysis assessing where bottlenecks might lie.  In Java, achieving this understanding may be difficult for the following reasons:

\begin{itemize}

\item There are many parts of the standard Java library that can do network I/O; we must examine how the program uses each of them. Furthermore, we must scan all parts of the program---and all third-party libraries it uses---to find all uses of the network.

\item If libraries are loaded at run time, by default they have the same access to the network as does the program that loaded them; thus we must know which libraries are to be loaded and scan them too.  Restricting dynamically loaded libraries is possible using Java classloaders and security managers, but the technique used is complex and makes program construction awkward (the loaded code must execute in a new thread, for example).  Furthermore, it is easy for developers to implement this technique incorrectly, sacrificing architectural control in the process.

\item Once the architect identifies a component that directly accesses the network, she may want to know how that component shares this ability with other parts of the system---and this involves understanding the component's interface.  The combination of aliasing, subtyping, and downcasts supported by Java makes this difficult, however.  If the component returns a value of type \texttt{Object} to clients, does this give clients the ability to send messages over the network?  The \texttt{Object} interface itself provides no networking methods, but the value may be downcast to an arbitrary type that may, in general, support network access.

\item In practice, systems are built in a layered manner, with high-level communication libraries built on lower ones.  All paths through the network stack must be examined for the architect to get a full picture of the messages sent over the network and the protocols used.  The aliasing and casting problem in the previous bullet makes this more difficult.

\item A security analyst might want to ensure that SSL is being used---and might conclude, upon seeing that Socket objects are obtained from code such as \texttt{SSLSocketFactory.getDefault().createSocket(host,port)}, that all is secure.  Unfortunately, the Java SSL libraries, like many others~\cite{most-dangerous-code-in-the-world}, are \emph{insecure} by default; they do not validate the server's certificate, opening the door to a man-in-the-middle attack.  This insecurity, and the need to configure SSL Socket Factories to secure them, is not mentioned in the API documentation;\footnote{http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLSocketFactory.html} it can only be found deep in the JSSE reference guide.\footnote{http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html}

\end{itemize}


\minisec{Achieving Architectural Control.} How can architects do better at controling the architecture of their systems?  We believe there are three key elements to achieving architectural control in practice:

\begin{itemize}

\item \textbf{Accessible Guidance.}  Because it is difficult for architects to be expert in every domain and with all component software used, it is essential that architects be able to leverage effective and accessible guidance concerning (A) what are the important potential constraints to consider with respect to a domain or a component, and (B) what is the basis for choosing among and configuring those constraints.  For example, an SSL library or component should make its configuration parameters obvious (e.g. used by the main classes in the library), provide documentation on how to choose them, ensure that the default configuration is secure, and support reusable configurations (e.g. so an organization can easily standardize a configuration appropriate to its domain).
% Software frameworks are often used to capture domain knowledge in a reusable library, and as such should include not just functionality but also explicit guidance concerning the architectural constraints that are relevant in the target domain.

\item \textbf{Centralized Specification.}  The reality of team-based development in the large is that it is not possible for a single person to review and understand all the project artifacts.  For an architect to achieve architectural control, therefore, requires that the specification of architectural constraints be centralized---and, to fit modern agile processes, we would like to see this specification manifest in code.  An ideal scenario of centralized specification would place all architectural constraints in a small set of files that is under source control, and where all revisions are personally reviewed and approved by the architect.  In our distributed system example, we envision that the architect could look at the system's entry point, together with the interfaces of the components mentioned there, and immediately determine (A) all of the components that can directly access the network, (B) which components might dynamically load code, and whether they give that loaded code network access; (C) component interfaces that are complete in the sense of showing all methods that can be invoked by clients; and (D) where to look for architecturally-relevant configuration information or higher-level layers of the architecture.

%An architecture specification could fulfill this role in document-centric processes, but in agile organizations where a lot of the architecture is distributed and embedded as documentation in the code, this becomes challenging.  Centralized specification is also challenging with respect to constraint enforcement mechanisms such as types; in a type system, the specification is spread throughout the program, easing enforcement but also making it difficult for the architect to understand whether the types correctly specify the desired architectural constraints. 

\item \textbf{Semi-automated Enforcement.}  Finally, once the proper architectural constraints have been identified and specified in a central way, the architect must be confident that they will be followed in the implementation of the software system.  Process-based mechanisms are important, but are also as fallible as the humans carrying out that process.  Fully automated tool-based mechanisms may not be feasible for enforcing many architectural constraints.  However, we outline a vision below in which the type system and run-time semantics of an \emph{architecture-exposing programming language} will semi-automatically enforce a variety of important architectural constraints, given input from developers in the form of partial, type-like specifications.

%Where feasible, therefore, the ideal is to provide semi-automated tools that can enforce the system's architectural constraints whenever the system's code is modified or executed.  In practice, full automation may not be feasible, e.g. type-like specifications may be required for tools based on type systems.  Furthermore, in practice tools may not be able to enforce exactly the constraint that the architect cares about, but the closer they can come, the more assistance the tools can provide to a process-based enforcement approach.

\end{itemize}

Finally, while architectural control is clearly desirable, in practice any mechanisms used to achieve it must be cost-effective.  We would like to realize the benefits of architectural control while minimizing sacrificed productivity.  In the ideal case, we would like to explore whether we can build tools that move the productivity-control curve outward, providing better architectural control while at the same time actually enhancing the productivity of a development team.


\TODO{Overview and outline of the rest of the paper}


\section{Prior Work}

\TODO{a lot of missing text here.  What follows are notes and fragments.}

Haskell's monads provide a potential technical foundation for architectural control~\cite{Haskell-monads}.  In practice, however, monads impose an overly strict discipline, requiring every operation that might transitively perform IO to use the IO monad; for many architectural control purposes, simply describing which components perform IO might be sufficient.  The syntactic overhead of IO monads also leads to an escape hatch, \texttt{unsafePerformIO}, which when used subverts architectural control.  Finally, in Haskell's design all IO operations are in one monad, whereas we believe many architects will find it useful to distinguish different forms of IO.

Dynamic capability systems.  Mark Miller's E and Bracha's Newspeak module system

Ownership - useful but insufficient due to downcasts.


\section{Architecture-Exposing Languages and Frameworks}

We propose \emph{architecture-exposing programming languages and frameworks} as a solution to providing better support for architectural control.  An \emph\textbf{architecture-exposing language} is a programming language that provides primitives to facilitate exposing architecture and enforcing constraints in a centralized way.  In addition to languages, we leverage software frameworks, because frameworks are already used to capture domain-specific architectures and to impose architectural constraints on applications that extend them~\cite{JaspanThesis}.  An \emph\textbf{architecture-exposing framework} is one that is specifically designed to encapsulate and enforce architectural constraints, while making important architectural choices more visible to architects that design their applications on top of the framework.

To make these ideas concrete, we sketch the design of a distributed system application and framework in a future version of Wyvern, a programming language we are currently designing.  We show how four technical characteristics---extensible languages, capability-based module systems, architectural layering in frameworks, and typed interfaces---may serve to provide a practical initial step towards providing architectural control in this domain.  Our concrete goal will be to show how the specific problem from the previous section---understanding the messages and protocols used in a distributed system---can be rendered not just possible but easy.


\subsection{Making Architecture Explicit in an Extensible Language}

   
\begin{figure}[t]
\begin{lstlisting}
def package feedback

import FeedbackClient, FeedbackServer
import resource wyvern.network
import resource wyvern.distributed.SSLSOAPConnector(network)
import extension wyvern.distributed.architecture

architecture feedback
    component client : FeedbackClient
    component server : FeedbackServer
    connect client.out, server.in
        with SSLSOAPConnector
            certificateAuthority = <verisigninc.com>
\end{lstlisting}
\caption{Client-Server Architecture}
\label{f-architecture}
%\vspace{-10px}
\end{figure}

Figure~\ref{f-architecture} shows one way of making the architecture of a simple client-server system explicit, so that it is easy for the architect to observe the messages exchanged and protocols used over the network.  The approach is inspired by ArchJava's custom connector support~\cite{ArchJava-connectors}, although we envision supporting architecture syntax via Wyvern's library-based language extension mechanism~\cite{TSLs-ECOOP14} rather than making it a core part of the language.

The code shows a client-server application for gathering feedback.  The architecture is simple: there are clients, servers, and a connection between the client's \texttt{out} and server's \texttt{in} ports that sends SOAP messages over SSL.  Here SSLSOAPConnector is a connection library that (unlike the standard Java library) checks server certificates unless otherwise specified, with a default set of widely-accepted certificate authorities that has been overridden here to specify only the VeriSign CA.

Looking at the client code in Figure~\ref{f-client}, we can see that the client declares the \texttt{out} port as an \texttt{IPClient} object that is parameterized by the high-level interface used for communication with the server.  The \texttt{FeedbackInterface} is not shown, but it consists of a single \texttt{provideFeedback} method that accepts a string.  When the client program is invoked---we envision that our Wyvern VM would support a command line syntax of the form \texttt{wyvern feedback client server.feedback.com 'my feedback here'}---the \texttt{run} method is called with the command line arguments.  The client program executes by connecting to the server---yielding an object of type \texttt{FeedbackInterface}---and then the \texttt{provideFeedback} method is invoked on this object.

Similarly, when the server code in Figure~\ref{f-server} runs, it initializes its \texttt{in} port to listen for incoming connections, passing a callback to be invovked when a connection is received.  The callback function returns an object of type \texttt{FeedbackInterface}, and the implementation responds to client messages by printing feedback to a log.

The implementation details of the approach are beyond the scope of this paper, but would follow ideas from~\cite{ArchJava-connectors,TSLs-ECOOP14}.  While using metaprogramming and/or reflection techniques to implement the domain-specific language for architecture may be a challenging task, they are not necessarily more challenging than the reflective techniques used in existing framework implementations such as Ruby on Rails.  Complex implementations are often acceptable in frameworks if they provide corresponding simplicity or other advantages to framework users.

\minisec{Discussion.}  

\TODO{Write the rest of me!  See separate outline document}



Goals: ensure that SSL is used in a simple client-server application.  be able to audit the messages exchanged.

Related goals (think of some and discuss them.  Maybe use of an authentication architecture?  Maybe a temporal constraint that authentication succeeds before some resource is accessed.)




\begin{figure}[t]
\begin{lstlisting}
package feedback

import FeedbackInterface
import wyvern.distributed.IPClient
import wyvern.distributed.IPAddress

class FeedbackClient
    val out = IPClient<FeedbackInterface>()
    def run(address : IPAddress, feedback : String)
        val server = out.connect(address)
        server.provideFeedback(feedback)
\end{lstlisting}
\caption{Client code}
\label{f-client}
%\vspace{-10px}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}
package feedback

import FeedbackInterface
import wyvern.distributed.IPServer
import wyvern.distributed.IPAddress
#import resource wyvern.logging.stdlog

class FeedbackServer
    val in = IPServer<FeedbackInterface>()
    def run() = in.listen(this.callback)
    def callback() : FeedbackInterface
        new FeedbackInterface
            def provideFeedback(feedback:String)
                stdlog(feedback)

\end{lstlisting}
\caption{Server code}
\label{f-server}
%\vspace{-10px}
\end{figure}



\bibliographystyle{abbrv}
\bibliography{research}

\end{sloppypar}
\end{document}
