\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\allowdisplaybreaks
 
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\textit{Case}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{
  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~#1}
  \fi
  \item
}

\begin{document}

%\begin{itemize}
%\item Run-time forms cannot appear in the source code of a program. Furthermore, we maintain an invariant that method definitions (and thus all declarations) do not contain any method call stack frames.
%\item $\sigma_e$ (the external type of an object) has no object fields ($\keywadj{var}$s) in it. Thus, object fields are private and directly accessible only by the object itself. For all other objects, object's fields are accessible only via object's methods.
%\end{itemize}

\begin{property}
\label{prop:no-rt-forms}
The run-time expression forms $l$ and $l.m(l) \rhd e$ do not appear in the program source code.
\end{property}

\noindent This property is enforced by the syntactic check of the source code of a program.

\vspace{10pt}

\begin{property}
\label{prop:mcsf-def-bind}
Method call stack frames ($l.m(l) \rhd e$) do not appear in method definitions and the bodies of the $\keywadj{bind}$ constructs.
\end{property}

\begin{proof}
The proof is by induction over execution steps.

\noindent\underline{\textit{Base case:}} By Property~\ref{prop:no-rt-forms}, there are no method call stack frames in the program source code.

\noindent\underline{\textit{Inductive case:}} The absence of method call stack frames in the method definitions and the bodies of the $\keywadj{bind}$ constructs is maintained by all evaluation rules. Cases of \textsc{E-Method} and \textsc{E-Bind} involve substitution; however, substituted expression is a value (location), and thus substitution preserves the property.\qed
\end{proof}

\vspace{3pt}

\begin{property}
\label{prop:fields-private}
Object fields are private to the objects they belong to and access to them can occur only inside methods of the objects to which they belong.
\end{property}

\noindent The typing rules contain information about what object is (or will be, in case of an object creation) the receiver of the enclosing method. Then from the \textsc{T-Field} and \textsc{T-Assign} rules, it can be seen that, for a field access to occur, the receiver must be the object to which the field belongs.



\newpage

\begin{mdframed}
\begin{lemma}
\label{l:ses-e}
If $l.m(l') \rhd E' \not\in E$, then $pointsto(E[e], \mu) = pointsto(e, \mu) \cup pointsto(subexps(E), \mu)$.
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the $pointsto(e, \mu)$ rules.

\noindent\underline{\textit{Case \textsc{pointsto-empty}:}} By \textsc{subexps-e-empty}, $subexps([~]) = \varnothing$, and the result is immediate.

\noindent\underline{\textit{Case \textsc{pointsto-var}:}} $pointsto(x, \mu) = \varnothing~~~~~~~~~~~~~~~~~~~~~~~~~~(\textsc{pointsto-var}, \textsc{pointsto-empty})~[1]$
\vspace{-7pt}
\begin{align*}
pointsto(E[x], \mu) &= pointsto(subexps(E), \mu) & (\textsc{pointsto-var})\\
&= pointsto(x, \mu) \cup pointsto(subexps(E), \mu) & (by~[1])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-new}:}} $pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}), \mu) = pointsto(\overline{d}, \mu)~~~~(\textsc{pointsto-new}, \textsc{pointsto-empty})~[2]$
\vspace{-7pt}
\begin{align*}
pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) &= pointsto(\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-new})\\
&= pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}), \mu) \cup pointsto(subexps(E), \mu) & (by~[2])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-principal}:}} From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}}$.
\vspace{-7pt}
\begin{align*}
pointsto(l, \mu) &= \{ l \} & (\textsc{pointsto-principal}, \textsc{pointsto-empty})~[3]\\
pointsto(E[l], \mu) &= \{ l \} \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-principal})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (by~[3])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-data}:}} From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{pure}}$.
\vspace{-7pt}
\begin{align*}
pointsto(l, \mu) &= \varnothing & (\textsc{pointsto-data}, \textsc{pointsto-empty})~[4]\\
pointsto(E[l], \mu) &= pointsto(subexps(E), \mu) & (\textsc{pointsto-data})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (by~[4])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-call-principal}:}} From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}}$.

\noindent$~~~~~pointsto(l.m(l') \rhd e', \mu) = \{ l \}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(\textsc{pointsto-call-principal}, \textsc{pointsto-empty})~[5]$
\vspace{-7pt}
\begin{align*}
pointsto(E[l.m(l') \rhd e'], \mu) &= \{ l \} \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-principal})\\
&= pointsto(l.m(l') \rhd e', \mu) \cup pointsto(subexps(E), \mu) & (by~[5])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-call-data}:}} From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{pure}}$.

$~~~pointsto(l.m(l') \rhd e', \mu) = pointsto(e', \mu)~~~~~~~~~~~~~~~~~~~~~(\textsc{pointsto-call-data}, \textsc{pointsto-empty})~[6]$
\vspace{-7pt}
\begin{align*}
pointsto(E[l.m(l') \rhd e'], \mu) &= pointsto(e', \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-data})\\
&= pointsto(l.m(l') \rhd e', \mu) \cup pointsto(subexps(E), \mu) & (by~[6])
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:simplify-a-stack}
If $l.m(l') \rhd E' \not\in E$, then $auth_{stack}(E[l.m(l') \rhd e'], \mu) = auth_{stack}(l.m(l') \rhd e', \mu)$.
\end{lemma}
\end{mdframed}

\begin{proof} $~~auth_{stack}(E[l.m(l') \rhd e'], \mu) = pointsto(e', \mu) \cup auth_{stack}(l, e', \mu)~~~~~~~~~~~~~~~(\textsc{auth-stack})$
\vspace{-7pt}
\begin{align*}
auth_{stack}(l.m(l') \rhd e', \mu) &= pointsto(e', \mu) \cup auth_{stack}(l, e', \mu)& (\textsc{auth-stack})
\end{align*}
Thus, $auth_{stack}(E[l.m(l') \rhd e'], \mu) = auth_{stack}(l.m(l') \rhd e', \mu)$.
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:pt-all-pure}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l.m(l') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item for $1 \leq i \leq k$, $l_i \mapsto \{ x \Rightarrow \overline{d_i} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{70pt} [callers in all method call stack frames are pure]}
\end{enumerate}
then
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup^k_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)
\end{align*}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $E_0[e]$ on the stack.

\noindent\underline{\textit{Base case:}} $k = 1$\\
\noindent$pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(subexps(E_1), \mu) \cup pointsto(E_0[e], \mu) & (\textsc{pointsto-call-data}) \\
&= pointsto(subexps(E_1), \mu) \cup pointsto(subexps(E_0), \mu) \cup pointsto(e, \mu) & (Lemma~\textit{\ref{l:ses-e}}) \\
&= \bigcup^1_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)
\end{align*}

\noindent\underline{\textit{Inductive case:}} $k > 1$\\
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(subexps(E_k), \mu) & (\textsc{pointsto-call-data}) \\
& \cup pointsto(E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= pointsto(subexps(E_k), \mu) \cup pointsto(subexps(E_{k-1}), \mu)& (\textsc{pointsto-call-data}) \\
& \cup pointsto(E_{k-2}[l_{k-2}.m_{k-2}(l_{k-2}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
%&= \bigcup^k_{i = 2} pointsto(subexps(E_i), \mu) \cup pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{pointsto-call-data} \times (k - 3)) \\
&= \bigcup^k_{i = 1} pointsto(subexps(E_i), \mu) \cup pointsto(E_0[e], \mu) & (\textsc{pointsto-call-data} \times (k - 2)) \\
&= \bigcup^k_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) & (Lemma~\textit{\ref{l:ses-e}})
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:pt-has-stateful}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l.m(l') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $\exists j$, such that $1 \leq j \leq k$, $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$
\intuition{\newline [there is at least one method call stack frame that has a principal caller]}
\end{enumerate}
then
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup^k_{i = p} pointsto(subexps(E_i), \mu) \cup \{ l_p\},
\end{align*}
where $1 \leq p \leq k$ and $p$ is the greatest index, such that $l_p \mapsto \{ x \Rightarrow \overline{d_p} \}_{\keywadj{stateful}} \in \mu$.

\intuition{\noindent[$l_p$ is the first (furthest from $e$) principal method caller on the stack]}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $E_0[e]$ on the stack.

\noindent\underline{\textit{Base case:}} $k = 1$, and since $l_1$ is the only method call stack frame, $l_1 \mapsto \{ x \Rightarrow \overline{d_1} \}_{\keywadj{stateful}} \in \mu$ and $p = 1$.
\begin{align*}
pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) &= pointsto(subexps(E_1), \mu) \cup \{ l_1 \} & (\textsc{pointsto-call-principal})
\end{align*}

\noindent\underline{\textit{Inductive case:}} $k > 1$\\
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(subexps(E_k), \mu) & (\textsc{pointsto-call-data}) \\
& \cup pointsto(E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= pointsto(subexps(E_k), \mu) \cup pointsto(subexps(E_{k-1}), \mu)& (\textsc{pointsto-call-data}) \\
& \cup pointsto(E_{k-2}[l_{k-2}.m_{k-2}(l_{k-2}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^k_{i = p+1} pointsto(subexps(E_i), \mu) & (\textsc{pointsto-call-data} \times (k - p - 2)) \\
& \cup pointsto(E_p[l_p.m_p(l_p') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
%& \cup pointsto(E_p[l_p.m_p(l_p') \rhd E_{p-1}[l_{p-1}.m_{p-1}(l_{p-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^k_{i = p} pointsto(subexps(E_i), \mu) \cup \{ l_p \} & (\textsc{pointsto-call-principal})
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:main-a-stack}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$ \intuition{\hspace{270pt} [$l$ is a principal]}
\item $\forall i$, such that $l_i = l$, $i \in \{ q_1, q_2, \dots, q_{r_1} \}$, where $0 \leq r_1 \leq k$ \intuition{\newline [the set of indices of all method call stack frames where $l$ is the caller; this set can be empty]}
\item $\forall i \in \{ q_1, q_2, \dots, q_{r_1} \}$, if $\exists j$, such that
\begin{enumerate}
\item $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$ and \intuition{\hspace{220pt} [$l_j$ is a principal]}
\item $\forall t$, such that $i > t > j$ and $l_t \mapsto \{ x \Rightarrow \overline{d_t} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{40pt} [all callers between $l_i$ and $l_j$ are pure]}
\end{enumerate}
$j \in \{ p_1, p_2, \dots, p_{r_2}\}$ where $0 \leq r_2 \leq r_1$
\intuition{\newline [the maximal set of indices of principal callers immediately after method call stack frames where $l$ is the caller; this set can be smaller than the one above only by one element; this set can also be empty; such principals can be $l$ itself]}
\end{enumerate}
then
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e, \mu)\\
\end{cases}
\end{align*}
\intuition{[If $r_2 < r_1$, then there are only pure principals after the last method call stack frame where $l$ is the caller. In other words, $l$ was the last principal caller on the stack.\\
If $r_2 = r_1$, then the last method call stack frame where $l$ is the caller is followed by a method call stack frame with a principal caller that is not $l$. If $r_2 = r_1 = 0$, then there are no method call stack frames with principal callers on the stack.\\
Since the set in 4(b) can include indices of method call stack frames where the caller is $l$, the difference between $r_1$ and $r_2$ is at most $1$, i.e. $r_2 \le r_1 \le r_2 + 1$.]}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $e$ on the stack.\\

\noindent\underline{\underline{\textit{Base case:}}} $k = 1$. Depending on the values of $r_1$ and $r_2$, there are two possibilities.

\noindent\underline{\textit{Case $r_2 < r_1$:}} $r_1 = 1$, $r_2 = 0$, and $l_1 = l$\\
\noindent$auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E_0[e], \mu) \cup auth_{stack}(l, E_0[e], \mu) & (\textsc{auth-stack}) \\
&= pointsto(E_0[e], \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}}) \\
&= pointsto(subexps(E_0), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:ses-e}})
\end{align*}

\noindent\underline{\textit{Case $r_2 = r_1$:}} $r_1 = r_2 = 0$, and $l_1 \neq l$
\vspace{-7pt}
\begin{align*}
auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) &= auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})
\end{align*}

\noindent\underline{\underline{\textit{Inductive case:}}} $k > 1$\\
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_{q_1}.m_{q_1}(l_{q_1}') \rhd E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&= pointsto(E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd E_{q_1-2}[l_{q_1-2}.m_{q_1-2}(l_{q_1-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (\textsc{auth-stack})\\
&\cup auth_{stack}(l, E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd E_{q_1-2}[l_{q_1-2}.m_{q_1-2}(l_{q_1-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (Lemma~\textit{\ref{l:pt-has-stateful}})\\
&\cup auth_{stack}(l, E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd E_{q_1-2}[l_{q_1-2}.m_{q_1-2}(l_{q_1-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
& =\bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, l_{q_2}.m_{q_2}(l_{q_2}') \rhd E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (\textsc{auth-stack})\\
&\cup pointsto(E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd E_{q_2-2}[l_{q_2-2}.m_{q_2-2}(l_{q_2-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&\cup auth_{stack}(l, E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd E_{q_2-2}[l_{q_2-2}.m_{q_2-2}(l_{q_2-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} \bigcup^{q_2-1}_{i = p_2} pointsto(subexps(E_i), \mu) \cup \{ l_{p_2} \}& (Lemma~\textit{\ref{l:pt-has-stateful}})\\
&\cup auth_{stack}(l, E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd E_{q_2-2}[l_{q_2-2}.m_{q_2-2}(l_{q_2-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&\vdots\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} \\
&\cup auth_{stack}(l, E_{q_{r_2}-1}[l_{q_{r_2}-1}.m_{q_{r_2}-1}(l_{q_{r_2}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)
%&\cup auth_{stack}(l, E_{q_{r_2}-1}[l_{q_{r_2}-1}.m_{q_{r_2}-1}(l_{q_{r_2}-1}') \rhd E_{q_{r_2}-2}[l_{q_{r_2}-2}.m_{q_{r_2}-2}(l_{q_{r_2}-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)
\end{align*}
Depending on the values of $r_1$ and $r_2$, there are two possibilities.

\noindent\underline{\textit{Case $r_2 < r_1$:}} There is no other stateful callers after $l_{q_{r_2+1}}$, i.e.\\
$\forall l_0.m_0(l_0') \rhd E''' \in E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}')  \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ]$, \mbox{$l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{pure}} \in \mu$}, which implies that there are also no method call stack frames with $l$ as the caller after $l_{q_{r_2+1}}$, i.e.\\
$l.m'(l'') \rhd E'' \not\in E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}')  \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ]$\\

\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, l_{q_{r_2+1}}.m_{q_{r_2+1}}(l_{q_{r_2+1}}') \rhd E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}')  \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (\textsc{auth-stack})\\
&\cup pointsto(E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&\cup auth_{stack}(l, E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:pt-all-pure}})\\
&\cup \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)\\
&\cup auth_{stack}(l, E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}

\noindent\underline{\textit{Case $r_2 = r_1$:}} There are no method call stack frames with $l$ as the caller after $l_{q_{r_2+1}}$, i.e.\\
$l.m'(l'') \rhd E'' \not\in E_{q_{r_2}-1}[l_{q_{r_2}-1}.m_{q_{r_2}-1}(l_{q_{r_2}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ]$\\

\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, e, \mu)
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:pt-ses}
If $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$, then $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the $subexps(E)$ rules.\\

\noindent\underline{\textit{Case \textsc{subexps-e-empty}:}} By \textsc{pointsto-empty}, $pointsto(\varnothing, \mu') = pointsto(\varnothing, \mu) = \varnothing$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-method1}:}} $pointsto(subexps(E.m(e'')), \mu) = pointsto(e'', \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(E.m(e'')), \mu') = pointsto(e'', \mu') \cup pointsto(subexps(E), \mu')$.

Since we are considering small-step semantics and $e''$ is evaluated only after $E$ is fully evaluated, there were no changes to $e''$ at this evaluation steps, and $pointsto(e'', \mu') = pointsto(e'', \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(E.m(e'')), \mu') =pointsto(subexps(E.m(e'')), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-method2}:}} $pointsto(subexps(l.m(E)), \mu) = pointsto(l, \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(l.m(E)), \mu') = pointsto(l, \mu') \cup pointsto(subexps(E), \mu')$.

By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(l.m(E)), \mu') =pointsto(subexps(l.m(E)), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-field}:}} $pointsto(subexps(E.f), \mu) = pointsto(subexps(E), \mu)$, and similarly,\\
$pointsto(subexps(E.f), \mu') = pointsto(subexps(E), \mu')$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$, and thus $pointsto(subexps(E.f), \mu') =pointsto(subexps(E.f), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-assign1}:}} $pointsto(subexps(E.f = e''), \mu) = pointsto(e'', \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(E.f = e''), \mu') = pointsto(e'', \mu') \cup pointsto(subexps(E), \mu')$.

Since we are considering small-step semantics and $e''$ is evaluated only after $E$ is fully evaluated, there were no changes to $e''$ at this evaluation steps, and $pointsto(e'', \mu') = pointsto(e'', \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(E.f = e''), \mu') =pointsto(subexps(E.f = e''), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-bind}:}} $pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu) = pointsto(e'', \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu') = pointsto(e'', \mu') \cup pointsto(subexps(E), \mu')$.

Since we are considering small-step semantics and $e''$ is evaluated only after $E$ is fully evaluated, there were no changes to $e''$ at this evaluation steps, and $pointsto(e'', \mu') = pointsto(e'', \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu') =pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-assign2}:}} $pointsto(subexps(l.f = E), \mu) = pointsto(l, \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(l.f = E), \mu') = pointsto(l, \mu') \cup pointsto(subexps(E), \mu')$.

By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(l.f = E), \mu') =pointsto(subexps(l.f = E), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-stackframe}:}} $pointsto(subexps(l.m(l') \rhd E), \mu) = pointsto(l, \mu) \cup pointsto(l', \mu)$\\
$\cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(l.m(l') \rhd E), \mu') = pointsto(l, \mu') \cup pointsto(l', \mu) \cup pointsto(subexps(E), \mu')$.

By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$ and\\
$pointsto(l', \mu') = pointsto(l', \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(l.m(l') \rhd E), \mu') =pointsto(subexps(l.m(l') \rhd E), \mu)$.
\qed
\end{proof}


\newpage
\begin{mdframed}
\begin{lemma}
\label{l:a-diff}
If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$ \intuition{\hspace{230pt} [$e$ can make a step of evaluation]}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$ \intuition{\hspace{270pt} [$l$ is a principal]}
\item $\forall i$, such that $l_i = l$, $i \in \{ q_1, q_2, \dots, q_{r_1} \}$, where $0 \leq r_1 \leq k$ \intuition{\newline [the set of indices of all method call stack frames where $l$ is the caller; this set can be empty]}
\item $\forall i \in \{ q_1, q_2, \dots, q_{r_1} \}$, if $\exists j$, such that
\begin{enumerate}
\item $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$ and \intuition{\hspace{220pt} [$l_j$ is a principal]}
\item $\forall t$, such that $i > t > j$ and $l_t \mapsto \{ x \Rightarrow \overline{d_t} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{40pt} [all callers between $l_i$ and $l_j$ are pure]}
\end{enumerate}
$j \in \{ p_1, p_2, \dots, p_{r_2}\}$ where $0 \leq r_2 \leq r_1$
\intuition{\newline [the maximal set of indices of principal callers immediately after method call stack frames where $l$ is the caller; this set can be smaller than the one above only by one element; this set can also be empty; such principals can be $l$ itself]}
\end{enumerate}
then
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e']] \dots ], \mu')$\\
$\setminus~auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & \text{if } r_2 < r_1\\
    \setminus~auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')& \text{if } r_2 = r_1\\
    \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{cases}
\end{align*}
\intuition{[If $r_2 < r_1$, then there are only pure principals after the last method call stack frame where $l$ is the caller. In other words, $l$ was the last principal caller on the stack.\\
If $r_2 = r_1$, then the last method call stack frame where $l$ is the caller is followed by a method call stack frame with a principal caller that is not $l$. If $r_2 = r_1 = 0$, then there are no method call stack frames with principal callers on the stack.\\
Since the set in 5(b) can include indices of method call stack frames where the caller is $l$, the difference between $r_1$ and $r_2$ is at most $1$, i.e. $r_2 \le r_1 \le r_2 + 1$.]}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $e$ and $e'$ on the stack.\\

\noindent\underline{\underline{\textit{Base case:}}} $k = 1$. Depending on the values of $r_1$ and $r_2$, there are two possibilities.

\noindent\underline{\textit{Case $r_2 < r_1$:}} $r_1 = 1$, $r_2 = 0$, and $l_1 = l$\\
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup pointsto(subexps(E_0), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:main-a-stack}})
\end{align*}
Similarly,
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu')$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup pointsto(subexps(E_0), \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu')\\
&= auth_{store}(l, \mu') \cup pointsto(subexps(E_0), \mu) \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & (Lemma~\textit{\ref{l:pt-ses}})
\end{align*}
Then 
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu')~\setminus~auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') \setminus auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}


\noindent\underline{\textit{Case $r_2 = r_1$:}} $r_1 = r_2 = 0$, and $l_1 \neq l$\\
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})
\end{align*}
Similarly,
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu') = auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')$. Then\\
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu')~\setminus~auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu') \setminus auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}

\noindent\underline{\underline{\textit{Inductive case:}}} $k > 1$\\
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) & (\textsc{auth-config})\\
&\cup auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=
\begin{cases}
    auth_{store}(l, \mu)\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu)\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e, \mu)\\
\end{cases} & (Lemma~\textit{\ref{l:main-a-stack}})
\end{align*}
Similarly,
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e']] \dots ], \mu')$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') & (\textsc{auth-config})\\
&\cup auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e']] \dots ], \mu')\\
&=
\begin{cases}
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu') \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu')\\\\
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu') \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e', \mu')\\
\end{cases} & (Lemma~\textit{\ref{l:main-a-stack}})\\
&=
\begin{cases}
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu')\\\\
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e', \mu')\\
\end{cases} & (Lemma~\textit{\ref{l:pt-ses}})
\end{align*}
Then 
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e']] \dots ], \mu') \setminus auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & \text{if } r_2 < r_1\\
    \setminus~auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')& \text{if } r_2 = r_1\\
    \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{cases}
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:sub-in-ses}
If $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$ and $z \in E$, then $subexps([l / z]E) = \{ l \} \cup subexps(E)$.
\end{lemma}
\end{mdframed}

\begin{proof}
The proof is by a straightforward induction on the $subexps(E)$ rules.\qed
\end{proof}


\newpage
\begin{mdframed}
\begin{lemma}
\label{l:sub-in-pt}
If $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$ and $l'.m'(l'') \rhd E \not\in e$, then
\[
pointsto([l / z]e, \mu) =
\begin{cases}
    pointsto(l, \mu) \cup pointsto(e, \mu) & \text{if } z \in e\\
    pointsto(e, \mu) & \text{if } z \not\in e\\
\end{cases}
\]
\end{lemma}
\end{mdframed}

\begin{proof} There are two cases depending on whether $z$ is in $e$ or not.\\

\noindent\underline{\underline{\textit{Case $z \in e$:}}} We prove this case by simultaneous induction on the $pointsto(d, \mu)$, $pointsto(\overline{d}, \mu)$, and $pointsto(e, \mu)$ rules.

\noindent\underline{\textit{Case \textsc{pointsto-def}:}}
\vspace{-7pt}
\begin{align*}
pointsto([l / z](\keyw{def} m(x : \tau_1) : \tau_2 = e')) &= pointsto(\keyw{def} m(x : \tau_1) : \tau_2 = [l / z]e', \mu)\\
&= pointsto([l / z]e', \mu) & (\textsc{pointsto-def})\\
&= pointsto(l, \mu) \cup pointsto(e', \mu) & (by~IH)\\
&= pointsto(l, \mu) \cup pointsto(\keyw{def} m(x : \tau_1) : \tau_2 = e', \mu) & (\textsc{pointsto-def})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-varx}:}} Since there is only one variable, $x = z$.
\vspace{-7pt}
\begin{align*}
pointsto([l / z](\keyw{var} f : \tau = x), \mu) &= pointsto(\keyw{var} f : \tau = l, \mu)\\
&= pointsto(l, \mu) & (\textsc{pointsto-varl})\\
&= pointsto(l, \mu) \cup pointsto(\keyw{var} f : \tau = x, \mu) & (\textsc{pointsto-varx})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-varl}:}} Since there are no variables, the substitution cannot take place, and the case is true by contradiction.

\noindent\underline{\textit{Case \textsc{pointsto-decls}:}} $pointsto([l / z]\overline{d}, \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup_{d \in \overline{d}} pointsto([l / z]d, \mu) & (\textsc{pointsto-decls})\\
&= pointsto(l, \mu) \bigcup_{d \in \overline{d}} pointsto(d, \mu) & (by~cases~\textsc{pointsto-def}, \textsc{pointsto-varx},~and~\textsc{pointsto-varl})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{pointsto-decls})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-empty}:}} $z \not\in \varnothing$ and the case is true by contradiction.

\noindent\underline{\textit{Case \textsc{pointsto-var}:}} $e = E[x]$. There are three subcases depending on whether $x = z$ and $z \in E$.

\noindent\underline{\textit{Subcase $x \neq z$ and $z \in E$:}} $[l / z]E[x] = E'[x]$, where $E' = [l / z]E$.
\begin{align*}
pointsto([l / z]E[x], \mu) &= pointsto(E'[x], \mu)\\
&= pointsto(subexps(E'), \mu) & (\textsc{pointsto-var})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[x], \mu) & (\textsc{pointsto-var})
\end{align*}

\noindent\underline{\textit{Subcase $x = z$ and $z \not\in E$:}} $[l / z]E[x] = E[l]$.\\
$pointsto([l / z]E[x], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E[l], \mu)\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-principal, pointsto-data, pointsto-empty})\\
&= pointsto(l, \mu) \cup pointsto(E[x], \mu) & (\textsc{pointsto-var})
\end{align*}

\noindent\underline{\textit{Subcase $x = z$ and $z \in E$:}} $[l / z]E[x] = E'[l]$, where $E' = [l / z]E$.\\
$pointsto([l / z]E[x], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E'[l], \mu)\\
&= pointsto(l, \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-principal, pointsto-data, pointsto-empty})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[x], \mu) & (\textsc{pointsto-var})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-principal} or \textsc{pointsto-data}:}} $e = E[l']$ and $z \in E$. Then $[l / z]E[l'] = E'[l']$, where \mbox{$E' = [l / z]E$}.\\
$pointsto([l / z]E[l'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E'[l'], \mu)\\
&= pointsto(l', \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-principal, pointsto-data, pointsto-empty})\\
&= pointsto(l', \mu) \cup pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[l'], \mu) & (\textsc{pointsto-principal, pointsto-data, pointsto-empty})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-new}:}} There are three subcases depending on whether $z \in \overline{d}$ and $z \in E$.

\noindent\underline{\textit{Subcase $z \not\in \overline{d}$ and $z \in E$:}} $[l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})] = E'[\keywadj{new}_s(x \Rightarrow \overline{d})]$, where $E' = [l / z]E$.
\begin{align*}
pointsto([l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) &= pointsto(E'[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu)\\
&= pointsto(\overline{d}, \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-new})\\
&= pointsto(\overline{d}, \mu) \cup pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) & (\textsc{pointsto-new})
\end{align*}

\noindent\underline{\textit{Subcase $z \in \overline{d}$ and $z \not\in E$:}} $[l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})] = E[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})]$.\\
$pointsto([l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})], \mu)\\
&= pointsto([l / z]\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-new})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (by~case~\textsc{pointsto-decls})\\
&= pointsto(l, \mu) \cup pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) & (\textsc{pointsto-new})
\end{align*}

\noindent\underline{\textit{Subcase $z \in \overline{d}$ and $z \in E$:}} $[l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})] = E'[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})]$, where $E' = [l / z]E$.\\
$pointsto([l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E'[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})], \mu)\\
&= pointsto([l / z]\overline{d}, \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-new})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(subexps(E'), \mu) & (by~case~\textsc{pointsto-decls})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) & (\textsc{pointsto-new})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-call-principal} or \textsc{pointsto-call-data}:}} Since both the cases have method call stack frames and the premise prohibits that, the cases are true by contradiction.\\

\noindent\underline{\underline{\textit{Case $z \not\in e$:}}} $[l / z]e = e$ and $pointsto([l / z]e, \mu) = pointsto(e, \mu)$.\\
\qed
\end{proof}



\newpage

\begin{theorem}[Authority Safety] If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{stateful}} \in \mu'$,
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$, and
\item $auth(l, e', \mu') \setminus auth(l, e, \mu) \supseteq \{ l_0 \}$,
\end{enumerate}
then one of the following must be true:
\begin{itemize}
\item \textbf{Object creation:}
\begin{enumerate}
\item $e = E[l.m(l') \rhd E'[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d_0})]]$ and
\item $e' = E[l.m(l') \rhd E'[l_0]]$, where
\item $\forall l_a.m_a(l_a') \rhd E'' \in E'$, $l_a \mapsto \{ x \Rightarrow \overline{d_a}\}_{\keywadj{pure}} \in \mu$ \intuition{\newline [there are only pure principals after the last method call stack frame where $l$ is the caller.]}
\end{enumerate}

\item \textbf{Method call:}
\begin{enumerate}
\item $e = E[l.m(l_0)]$ and
\item $e' = E[l.m(l_0) \rhd [l_0/y][l/x]e'']$
\item $y \in e''$ \intuition{\hspace{100pt} [the passed-in argument $y$ is used in the method body $e''$]}
\end{enumerate}

\item \textbf{Method return:}
\begin{enumerate}
\item $e = E[l.m(l') \rhd E'[l_a.m_a(l_a') \rhd l_0]]$ and
\item $e' = E[l.m(l') \rhd E'[l_0]]$, where
\item $\forall l_b.m_b(l_b') \rhd E'' \in E'$, $l_b \mapsto \{ x \Rightarrow \overline{d_b}\}_{\keywadj{pure}} \in \mu$ \intuition{\newline [there are only pure principals after the last method call stack frame where $l$ is the caller.]}
\end{enumerate}
\end{itemize}

\end{theorem}

\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy

\noindent\fbox{\parbox{\widthof{Case \textsc{E-Congruence}:}}{Case \textsc{E-Congruence}:}} $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$

Let us enumerate method call stack frames in $E$:
\begin{align*}
E[e] &= E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ]\\
E[e'] &= E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e']] \dots ]
\end{align*}
where
\begin{enumerate}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E' \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $\forall i$, such that $l_i = l$, $i \in \{ q_1, q_2, \dots, q_{r_1} \}$, where $0 \leq r_1 \leq k$ \intuition{\newline [the set of indices of all method call stack frames where $l$ is the caller; this set can be empty]}
\item $\forall i \in \{ q_1, q_2, \dots, q_{r_1} \}$, if $\exists j$, such that
\begin{enumerate}
\item $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$ and \intuition{\hspace{230pt} [$l_j$ is a principal]}
\item $\forall t$, such that $i > t > j$ and $l_t \mapsto \{ x \Rightarrow \overline{d_t} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{60pt} [all callers between $l_i$ and $l_j$ are pure]}
\end{enumerate}
$j \in \{ p_1, p_2, \dots, p_{r_2}\}$ where $0 \leq r_2 \leq r_1$
\intuition{\newline [the maximal set of indices of principal callers immediately after method call stack frames where $l$ is the caller; this set can be smaller than the one above only by one element; this set can also be empty; such principals can be $l$ itself]}
\end{enumerate}
Then
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e']] \dots ], \mu')$\\
$\setminus~auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & \text{if } r_2 < r_1\\
    \setminus~auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')& \text{if } r_2 = r_1\\
    \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{cases} & (Lemma~\textit{\ref{l:a-diff}})
\end{align*}
\intuition{[If $r_2 < r_1$, then there are only pure principals after the last method call stack frame where $l$ is the caller. In other words, $l$ was the last principal caller on the stack.\\
If $r_2 = r_1$, then the last method call stack frame where $l$ is the caller is followed by a method call stack frame with a principal caller that is not $l$. If $r_2 = r_1 = 0$, then there are no method call stack frames with principal callers on the stack.\\
Since the set in 3(b) can include indices of method call stack frames where the caller is $l$, the difference between $r_1$ and $r_2$ is at most $1$, i.e. $r_2 \le r_1 \le r_2 + 1$.]}\\
Thus the changes in authority when $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$ depend on what expressions are in $e~|~\mu \longrightarrow e'~|~\mu'$. Let us consider all possible $e$ and $e'$.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-New}:}}{Subcase \textsc{E-New}:}}
\mbox{$e = \keywadj{new}_s(x \Rightarrow \overline{d_a})$}, \mbox{$e' = l_a$}, and \mbox{$E[\keywadj{new}_s(x \Rightarrow \overline{d_a})]~|~\mu \longrightarrow E[l_a]~|~\mu'$}, where\\
\mbox{$\mu' = \mu, l_a \mapsto \{ x \Rightarrow \overline{d_a} \}_s$}.

By \textsc{auth-store}, $auth_{store}(l, \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu)$ and $auth_{store}(l, \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu')$. By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$. By \textsc{pointsto-decls} and the $pointsto(d, \mu)$ rules, $pointsto(\overline{d}, \mu)$ depends only on what is in $\overline{d}$ and whether it is stateful. Then since the only change to the store was the addition of a new object $l_a$, and by inversion on \textsc{E-New}, $l_a \not\in dom(\mu)$ and $\keywadj{new}_s(x \Rightarrow \overline{d_a})$ is a closed term, i.e. it is fully defined and all objects in $\overline{d_a}$ must be in the store at the time of the object creation (\textsc{T-Store}), $pointsto(l_a, \mu) \not\in pointsto(\overline{d}, \mu')$. Thus, $auth_{store}(l, \mu') = auth_{store}(l, \mu)$.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_a, \mu') \cup auth_{stack}(l, l_a, \mu')\\
& \setminus pointsto(\keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu) \cup auth_{stack}(l, \keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu)\\
&= pointsto(l_a, \mu') \setminus pointsto(\keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= pointsto(l_a, \mu') \setminus pointsto(\overline{d_a}, \mu) & (\textsc{pointsto-new}, \textsc{pointsto-empty})
\end{align*}
There are two possibilities depending on whether $l_a$ is a principal or not.

\noindent\underline{\textit{Case $l_a$ is a principal:}}
\vspace{-7pt}
\begin{align*}
auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) &= \{ l_a \} \setminus pointsto(\overline{d_a}, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty}) 
\end{align*}
Since $l_a$ points to a fresh memory location and our language requires an object to be allocated in memory before it can be used, $\{ l_a \} \not\in pointsto(\overline{d_a}, \mu)$, the authority of $l$ increases, which is in accordance with the \textbf{\textit{object creation}} case, and the theorem holds.

\noindent\underline{\textit{Case $l_a$ is pure:}}
\vspace{-7pt}
\begin{align*}
auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) &= \varnothing \setminus pointsto(\overline{d_a}, \mu) & (\textsc{pointsto-data}, \textsc{pointsto-empty})
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_a, \mu') \setminus auth_{stack}(l, \keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu)\\
&= \varnothing & (\textsc{auth-stack-nocall} \times 2)
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Method}:}}{Subcase \textsc{E-Method}:}}
$e = l_a.m(l_b)$, \mbox{$e' = l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a$}, \mbox{$\mu' = \mu$}, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$. Since $e_a$ is a method definition, by Property~\ref{prop:mcsf-def-bind}, $e_a$ has no method call stack frames.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}} \noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\begin{align*}
&= pointsto(l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu)\\
&\setminus pointsto(l_a.m(l_b), \mu) \cup auth_{stack}(l, l_a.m(l_b), \mu)\\
&= pointsto(l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})\\
&\setminus pointsto(l_a.m(l_b), \mu)
\end{align*}
There are three possibilities depending on whether $l_a = l$ and whether it is a principal or not.

\noindent\underline{\textit{Case $l_a = l$:}} Since $l$ is a principal, $l_a$ is a principal too.\\
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= \{ l_a \} \cup auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) & (\textsc{pointsto-call-principal}, \textsc{pointsto-empty})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{subexps-e-method2})\\
&= \{ l_a \} \cup pointsto([l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
&= \{ l_a \} \cup pointsto([l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
&= pointsto(l_a, \mu) \cup pointsto([l_b / y][l_a / x]e_a, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)
\end{align*}
\vspace{-25pt}
\begin{align*}
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x, y \not\in e_a
\end{cases} & (Lemma~\textit{\ref{l:sub-in-pt}} \times 2)\\
&=
\begin{cases}
    pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) & \text{if } x, y \not\in e_a
\end{cases}\\
&\subseteq pointsto(e_a, \mu)\\
&= auth_{store}(l, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu)
\end{align*}
By \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $auth_{store}(l, \mu) \supseteq pointsto(e_a, \mu)$, and therefore, $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) = \varnothing$. Thus, the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is a principal:}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= \{ l_a \} \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{pointsto-call-principal}, \textsc{pointsto-empty})\\
&= pointsto(l_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is pure:}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto([l_b / y][l_a / x]e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{pointsto-call-data}, \textsc{pointsto-empty})
\end{align*}
\vspace{-25pt}
\begin{align*}
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x, y \not\in e_a
\end{cases} & (Lemma~\textit{\ref{l:sub-in-pt}} \times 2)\\
&=
\begin{cases}
    pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) &\text{if } x, y \not\in e_a
\end{cases}\\
&\subseteq pointsto(e_a, \mu)\\
&= auth_{store}(l, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu)
\end{align*}
By \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $auth_{store}(l, \mu) \supseteq pointsto(e_a, \mu)$, and therefore, $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) = \varnothing$. Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}} \noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) \setminus auth_{stack}(l, l_a.m(l_b), \mu)\\
&= auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
There are two possibilities depending on whether $l_a = l$ or not.

\noindent\underline{\textit{Case $l_a = l$:}} Since $l$ is a principal, $l_a$ is a principal too.\\
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto([l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack})\\
&= pointsto([l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
\begin{align*}
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a~~~~~~~~~(Lemma~\textit{\ref{l:sub-in-pt}} \times 2)\\
    pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    pointsto(e_a, \mu) & \text{if } x, y \not\in e_a
\end{cases}\\
&=
\begin{cases}
    auth_{store}(l, \mu) \cup pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \in e_a\\
    auth_{store}(l, \mu) \cup pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    auth_{store}(l, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \not\in e_a
\end{cases}
\end{align*}
Since $l_a = l$ and by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $auth_{store}(l, \mu) \supseteq pointsto(l_a, \mu) \cup pointsto(e_a, \mu)$. Then $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \in e_a\\
    auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \not\in e_a
\end{cases}\\
&=
\begin{cases}
    pointsto(l_b, \mu) & \text{if } y \in e_a\\
    \varnothing & \text{if } y \not\in e_a\\
\end{cases}\\
&=
\begin{cases}
    \{ l_b \} & \text{if } y \in e_a \text{ and } l_b \text { is a principal}~~~(\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
    \varnothing & \text{otherwise}\\
\end{cases}
\end{align*}
Thus, if $y \in e_a$ and $l_b$ is a principal, the authority of $l$ increases, which is in accordance with the \textbf{\textit{method call}} case, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$:}} $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) = \varnothing~~~~~~~~~~~~(\textsc{auth-stack-nocall})$\\
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Field}:}}{Subcase \textsc{E-Field}:}}
$e = l_a.f$, $e' = l_b$, $\mu' = \mu$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$.

By Property~\ref{prop:fields-private}, the object field that is being accessed must belong to the caller of the last method call stack frame on the stack. Then $l_1 = l_a$, and by definition of a principal, since $l_1$ has fields, it is a principal.

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}} Since $l_1$ is a principal, $l = l_1 = l_a$.\\
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_b, \mu) \cup auth_{stack}(l, l_b, \mu) \setminus pointsto(l.f, \mu) \cup auth_{stack}(l, l.f, \mu)\\
&= pointsto(l_b, \mu) \setminus pointsto(l.f, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \setminus auth_{store}(l, \mu) \cup pointsto(l.f, \mu)
\end{align*}
By inversion on \textsc{E-Field}, $\keyw{var} f : \tau = l_b \in \overline{d}$. Then by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu) \supseteq pointsto(l_b, \mu)$, and
\begin{align*}
auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) &= auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) \cup pointsto(l.f, \mu) = \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}} $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_b, \mu) \setminus auth_{stack}(l, l_a.f, \mu)\\ 
&= \varnothing & (\textsc{auth-stack-nocall} \times 2)
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Assign}:}}{Subcase \textsc{E-Assign}:}}
$e = (l_a.f = l_b)$, $e' = l_b$, and by inversion on \textsc{E-Assign}, $l_a \mapsto \{ x \Rightarrow \overline{d_a} \}_{s} \in \mu$, \mbox{$\keyw{var} f : \tau = l_c \in \overline{d_a}$}, $\overline{d_a}' = [\keyw{var} f : \tau = l_b/\keyw{var} f : \tau = l_c]\overline{d_a}$, and $\mu' = [l_a \mapsto \{ x \Rightarrow \overline{d_a}' \}_{s}/l_a \mapsto \{ x \Rightarrow \overline{d_a} \}_{s}]\mu$.

By Property~\ref{prop:fields-private}, the object field that is being accessed must belong to the caller of the last method call stack frame on the stack. Then $l_1 = l_a$, and by definition of a principal, since $l_1$ has fields, it is a principal.

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}} Since $l_1$ is a principal, in this case, $l = l_1 = l_a$.

Since in this step of evaluation, the only change to the store is the substitution of $l_c$ with $l_b$ in one of $l$'s fields, by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu') \setminus auth_{store}(l, \mu) \subseteq pointsto(l_b, \mu')$. [1]

By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l_b, \mu') = pointsto(l_b, \mu)$. \hspace{12pt} [2]

\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup pointsto(l_b, \mu') \cup auth_{stack}(l, l_b, \mu')\\
&\setminus~auth_{store}(l, \mu) \cup pointsto(l.f = l_b, \mu) \cup auth_{stack}(l, l.f = l_b, \mu)\\
&= auth_{store}(l, \mu') \cup pointsto(l_b, \mu') \setminus auth_{store}(l, \mu) \cup pointsto(l.f = l_b, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= auth_{store}(l, \mu') \cup pointsto(l_b, \mu') \setminus auth_{store}(l, \mu) \cup pointsto(l, \mu) \cup pointsto(l_b, \mu) & (\textsc{subexps-e-assign2})\\
&\subseteq pointsto(l_b, \mu') \setminus pointsto(l, \mu) \cup pointsto(l_b, \mu) & (by~[1])\\
&= \varnothing & (by~[2])
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}} Since $l_1$ is a principal and $l_1 = l_a$, in this case, $l \neq l_a$ and $r_2 = r_1 \neq 0$.

Since $l \neq l_a$ and, in this step of evaluation, the only change to the store is the substitution of $l_c$ with $l_b$ in one of $l_1$'s fields, by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu') = auth_{store}(l, \mu)$. [3]

\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup auth_{stack}(l, l_b, \mu') \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, l_a.f = l_b, \mu)\\
&= auth_{store}(l, \mu') \setminus auth_{store}(l, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= \varnothing & (by~[3])
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Bind}:}}{Subcase \textsc{E-Bind}:}}
$e = \keyw{bind} x = l_a~\keyw{in} e_a$, $e' = [l_a/x]e_a$, $\mu' = \mu$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$. Since $e_a$ is a method definition, by Property~\ref{prop:mcsf-def-bind}, $e_a$ has no method call stack frames.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto([l_a/x]e_a, \mu) \cup auth_{stack}(l, [l_a/x]e_a, \mu)\\
&\setminus pointsto(\keyw{bind} x = l_a~\keyw{in} e_a, \mu) \cup auth_{stack}(l, \keyw{bind} x = l_a~\keyw{in} e_a, \mu)\\
&= pointsto([l_a/x]e_a, \mu) \setminus pointsto(\keyw{bind} x = l_a~\keyw{in} e_a, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= pointsto([l_a/x]e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & (\textsc{subexps-e-bind})\\
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & \text{if } x \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a
\end{cases} & (Lemma~\textit{\ref{l:sub-in-pt}})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, [l_a/x]e_a, \mu) \setminus auth_{stack}(l, \keyw{bind} x = l_a~\keyw{in} e_a, \mu)\\
&= \varnothing & (\textsc{auth-stack-nocall} \times 2)
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-StackFrame}:}}{Subcase \textsc{E-Stackframe}:}}
$e = l_a.m(l_b) \rhd l_c$, $e' = l_c$, $\mu' = \mu$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu) \cup auth_{stack}(l, l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
There are three possibilities depending on whether $l_a = l$ and whether it is a principal or not.

\noindent\underline{\textit{Case $l_a = l$:}} Since $l$ is a principal, $l_a$ is a principal too.\\
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup pointsto(l_c, \mu) \cup auth_{stack}(l, l_c, \mu) & (\textsc{auth-stack})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is a principal:}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu)\\
& \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus \{ l_a \} \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{pointsto-call-principal}, \textsc{pointsto-empty})\\
&= pointsto(l_c, \mu) \setminus \{ l_a \} & (\textsc{auth-stack-nocall})\\
&=
\begin{cases}
    \{ l_c \} \setminus \{ l_a \} & \text{if } l_c \text{ is a principal}~~~(\textsc{pointsto-principal})\\
    \varnothing & \text{if } l_c \text{ is pure}~~~~~~~~~~~(\textsc{auth-stack-nocall})
\end{cases}
\end{align*}
Thus if $l_a \neq l$, $l_a$ is a principal, and $l_c$ is a principal, then the authority of $l$ increases, which is in accordance with the \textbf{\textit{method return}} case, and the theorem holds. If $l_a \neq l$, $l_a$ is a principal, and $l_c$ is pure, then the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is pure:}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus pointsto(l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{pointsto-call-data}, \textsc{pointsto-empty})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_c, \mu) \setminus auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= \varnothing \setminus auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{auth-stack-nocall})\\
&= \varnothing
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\\
\qed
\end{proof}


\bibliographystyle{plain}
\bibliography{bibtex}

\end{document}