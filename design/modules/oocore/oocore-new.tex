\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\allowdisplaybreaks
 
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\textit{Case}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{
  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~#1}
  \fi
  \item
}

\begin{document}

%\begin{itemize}
%\item Run-time forms cannot appear in the source code of a program. Furthermore, we maintain an invariant that method definitions (and thus all declarations) do not contain any method call stack frames.
%\item $\sigma_e$ (the external type of an object) has no object fields ($\keywadj{var}$s) in it. Thus, object fields are private and directly accessible only by the object itself. For all other objects, object's fields are accessible only via object's methods.
%\end{itemize}

\begin{property}
\label{prop:no-rt-forms}
The run-time expression forms $l$ and $l.m(l) \rhd e$ do not appear in the program source code.
\end{property}

\noindent This property is enforced by the syntactic check of the source code of a program.

\vspace{10pt}

\begin{property}
\label{prop:mcsf-def-bind}
Method call stack frames ($l.m(l) \rhd e$) do not appear in method definitions and the bodies of the $\keywadj{bind}$ constructs.
\end{property}

\begin{proof}
The proof is by induction over execution steps.

\noindent\underline{\textit{Base case:}} By Property~\ref{prop:no-rt-forms}, there are no method call stack frames in the program source code.

\noindent\underline{\textit{Inductive case:}} The absence of method call stack frames in the method definitions and the bodies of the $\keywadj{bind}$ constructs is maintained by all evaluation rules. Cases of \textsc{E-Method} and \textsc{E-Bind} involve substitution; however, substituted expression is a value (location), and thus substitution preserves the property.\qed
\end{proof}

\vspace{3pt}

\begin{property}
\label{prop:fields-private}
Object fields are private to the objects they belong to and access to them can occur only inside methods of the objects to which they belong.
\end{property}

\noindent The typing rules contain information about what object is (or will be, in case of an object creation) the receiver of the enclosing method. Then from the \textsc{T-Field} and \textsc{T-Assign} rules, it can be seen that, for a field access to occur, the receiver must be the object to which the field belongs.



\newpage

\begin{mdframed}
\begin{lemma}
\label{l:ses-e}
If $l.m(l') \rhd E' \not\in E$, then $pointsto(E[e], \mu) = pointsto(e, \mu) \cup pointsto(subexps(E), \mu)$.
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the $pointsto(e, \mu)$ rules.

\noindent\underline{\textit{Case \textsc{pointsto-empty}:}} By \textsc{subexps-e-empty}, $subexps([~]) = \varnothing$, and the result is immediate.

\noindent\underline{\textit{Case \textsc{pointsto-var}:}} $pointsto(x, \mu) = \varnothing~~~~~~~~~~~~~~~~~~~~~~~~~~(\textsc{pointsto-var}, \textsc{pointsto-empty})~[1]$
\vspace{-7pt}
\begin{align*}
pointsto(E[x], \mu) &= pointsto(subexps(E), \mu) & (\textsc{pointsto-var})\\
&= pointsto(x, \mu) \cup pointsto(subexps(E), \mu) & (by~[1])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-new}:}} $pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}), \mu) = pointsto(\overline{d}, \mu)~~~~(\textsc{pointsto-new}, \textsc{pointsto-empty})~[2]$
\vspace{-7pt}
\begin{align*}
pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) &= pointsto(\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-new})\\
&= pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}), \mu) \cup pointsto(subexps(E), \mu) & (by~[2])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-principal}:}} From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}}$.
\vspace{-7pt}
\begin{align*}
pointsto(l, \mu) &= \{ l \} & (\textsc{pointsto-principal}, \textsc{pointsto-empty})~[3]\\
pointsto(E[l], \mu) &= \{ l \} \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-principal})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (by~[3])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-data}:}} From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{pure}}$.
\vspace{-7pt}
\begin{align*}
pointsto(l, \mu) &= \varnothing & (\textsc{pointsto-data}, \textsc{pointsto-empty})~[4]\\
pointsto(E[l], \mu) &= pointsto(subexps(E), \mu) & (\textsc{pointsto-data})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (by~[4])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-call-principal}:}} From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}}$.

\noindent$~~~~~pointsto(l.m(l') \rhd e', \mu) = \{ l \}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(\textsc{pointsto-call-principal}, \textsc{pointsto-empty})~[5]$
\vspace{-7pt}
\begin{align*}
pointsto(E[l.m(l') \rhd e'], \mu) &= \{ l \} \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-principal})\\
&= pointsto(l.m(l') \rhd e', \mu) \cup pointsto(subexps(E), \mu) & (by~[5])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-call-data}:}} From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{pure}}$.

$~~~pointsto(l.m(l') \rhd e', \mu) = pointsto(e', \mu)~~~~~~~~~~~~~~~~~~~~~(\textsc{pointsto-call-data}, \textsc{pointsto-empty})~[6]$
\vspace{-7pt}
\begin{align*}
pointsto(E[l.m(l') \rhd e'], \mu) &= pointsto(e', \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-data})\\
&= pointsto(l.m(l') \rhd e', \mu) \cup pointsto(subexps(E), \mu) & (by~[6])
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:simplify-a-stack}
If $l.m(l') \rhd E' \not\in E$, then $auth_{stack}(E[l.m(l') \rhd e'], \mu) = auth_{stack}(l.m(l') \rhd e', \mu)$.
\end{lemma}
\end{mdframed}

\begin{proof} $~~auth_{stack}(E[l.m(l') \rhd e'], \mu) = pointsto(e', \mu) \cup auth_{stack}(l, e', \mu)~~~~~~~~~~~~~~~(\textsc{auth-stack})$
\vspace{-7pt}
\begin{align*}
auth_{stack}(l.m(l') \rhd e', \mu) &= pointsto(e', \mu) \cup auth_{stack}(l, e', \mu)& (\textsc{auth-stack})
\end{align*}
Thus, $auth_{stack}(E[l.m(l') \rhd e'], \mu) = auth_{stack}(l.m(l') \rhd e', \mu)$.
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:pt-all-pure}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l.m(l') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item for $1 \leq i \leq k$, $l_i \mapsto \{ x \Rightarrow \overline{d_i} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{70pt} [callers in all method call stack frames are pure]}
\end{enumerate}
then
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup^k_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)
\end{align*}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $E_0[e]$ on the stack.

\noindent\underline{\textit{Base case:}} $k = 1$\\
\noindent$pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(subexps(E_1), \mu) \cup pointsto(E_0[e], \mu) & (\textsc{pointsto-call-data}) \\
&= pointsto(subexps(E_1), \mu) \cup pointsto(subexps(E_0), \mu) \cup pointsto(e, \mu) & (Lemma~\textit{\ref{l:ses-e}}) \\
&= \bigcup^1_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)
\end{align*}

\noindent\underline{\textit{Inductive case:}} $k > 1$\\
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(subexps(E_k), \mu) & (\textsc{pointsto-call-data}) \\
& \cup pointsto(E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= pointsto(subexps(E_k), \mu) \cup pointsto(subexps(E_{k-1}), \mu)& (\textsc{pointsto-call-data}) \\
& \cup pointsto(E_{k-2}[l_{k-2}.m_{k-2}(l_{k-2}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
%&= \bigcup^k_{i = 2} pointsto(subexps(E_i), \mu) \cup pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{pointsto-call-data} \times (k - 3)) \\
&= \bigcup^k_{i = 1} pointsto(subexps(E_i), \mu) \cup pointsto(E_0[e], \mu) & (\textsc{pointsto-call-data} \times (k - 2)) \\
&= \bigcup^k_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) & (Lemma~\textit{\ref{l:ses-e}})
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:pt-has-stateful}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l.m(l') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $\exists j$, such that $1 \leq j \leq k$, $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$
\intuition{\newline [there is at least one method call stack frame that has a principal caller]}
\end{enumerate}
then
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup^k_{i = p} pointsto(subexps(E_i), \mu) \cup \{ l_p\},
\end{align*}
where $1 \leq p \leq k$ and $p$ is the greatest index, such that $l_p \mapsto \{ x \Rightarrow \overline{d_p} \}_{\keywadj{stateful}} \in \mu$.

\intuition{\noindent[$l_p$ is the first (furthest from $e$) principal method caller on the stack]}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $E_0[e]$ on the stack.

\noindent\underline{\textit{Base case:}} $k = 1$, and since $l_1$ is the only method call stack frame, $l_1 \mapsto \{ x \Rightarrow \overline{d_1} \}_{\keywadj{stateful}} \in \mu$ and $p = 1$.
\begin{align*}
pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) &= pointsto(subexps(E_1), \mu) \cup \{ l_1 \} & (\textsc{pointsto-call-principal})
\end{align*}

\noindent\underline{\textit{Inductive case:}} $k > 1$\\
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(subexps(E_k), \mu) & (\textsc{pointsto-call-data}) \\
& \cup pointsto(E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= pointsto(subexps(E_k), \mu) \cup pointsto(subexps(E_{k-1}), \mu)& (\textsc{pointsto-call-data}) \\
& \cup pointsto(E_{k-2}[l_{k-2}.m_{k-2}(l_{k-2}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^k_{i = p+1} pointsto(subexps(E_i), \mu) & (\textsc{pointsto-call-data} \times (k - p - 2)) \\
& \cup pointsto(E_p[l_p.m_p(l_p') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
%& \cup pointsto(E_p[l_p.m_p(l_p') \rhd E_{p-1}[l_{p-1}.m_{p-1}(l_{p-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^k_{i = p} pointsto(subexps(E_i), \mu) \cup \{ l_p \} & (\textsc{pointsto-call-principal})
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:main-a-stack}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$ \intuition{\hspace{270pt} [$l$ is a principal]}
\item $\forall i$, such that $l_i = l$, $i \in \{ q_1, q_2, \dots, q_{r_1} \}$, where $0 \leq r_1 \leq k$ \intuition{\newline [the set of indices of all method call stack frames where $l$ is the caller; this set can be empty]}
\item $\forall i \in \{ q_1, q_2, \dots, q_{r_1} \}$, if $\exists j$, such that
\begin{enumerate}
\item $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$ and \intuition{\hspace{220pt} [$l_j$ is a principal]}
\item $\forall t$, such that $i > t > j$ and $l_t \mapsto \{ x \Rightarrow \overline{d_t} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{40pt} [all callers between $l_i$ and $l_j$ are pure]}
\end{enumerate}
$j \in \{ p_1, p_2, \dots, p_{r_2}\}$ where $0 \leq r_2 \leq r_1$
\intuition{\newline [the maximal set of indices of principal callers immediately after method call stack frames where $l$ is the caller; this set can be smaller than the one above only by one element; this set can also be empty; such principals can be $l$ itself]}
\end{enumerate}
then
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e, \mu)\\
\end{cases}
\end{align*}
\intuition{[If $r_2 < r_1$, then there are only pure principals after the last method call stack frame where $l$ is the caller. In other words, $l$ was the last principal caller on the stack.\\
If $r_2 = r_1$, then the last method call stack frame where $l$ is the caller is followed by a method call stack frame with a principal caller that is not $l$. If $r_2 = r_1 = 0$, then there are no method call stack frames with principal callers on the stack.\\
Since the set in 4(b) can include indices of method call stack frames where the caller is $l$, the difference between $r_1$ and $r_2$ is at most $1$, i.e. $r_2 \le r_1 \le r_2 + 1$.]}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $e$ on the stack.\\

\noindent\underline{\underline{\textit{Base case:}}} $k = 1$. Depending on the values of $r_1$ and $r_2$, there are two possibilities.

\noindent\underline{\textit{Case $r_2 < r_1$:}} $r_1 = 1$, $r_2 = 0$, and $l_1 = l$\\
\noindent$auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E_0[e], \mu) \cup auth_{stack}(l, E_0[e], \mu) & (\textsc{auth-stack}) \\
&= pointsto(E_0[e], \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}}) \\
&= pointsto(subexps(E_0), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:ses-e}})
\end{align*}

\noindent\underline{\textit{Case $r_2 = r_1$:}} $r_1 = r_2 = 0$, and $l_1 \neq l$
\vspace{-7pt}
\begin{align*}
auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) &= auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})
\end{align*}

\noindent\underline{\underline{\textit{Inductive case:}}} $k > 1$\\
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_{q_1}.m_{q_1}(l_{q_1}') \rhd E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&= pointsto(E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd E_{q_1-2}[l_{q_1-2}.m_{q_1-2}(l_{q_1-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (\textsc{auth-stack})\\
&\cup auth_{stack}(l, E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd E_{q_1-2}[l_{q_1-2}.m_{q_1-2}(l_{q_1-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (Lemma~\textit{\ref{l:pt-has-stateful}})\\
&\cup auth_{stack}(l, E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd E_{q_1-2}[l_{q_1-2}.m_{q_1-2}(l_{q_1-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
& =\bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, l_{q_2}.m_{q_2}(l_{q_2}') \rhd E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (\textsc{auth-stack})\\
&\cup pointsto(E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd E_{q_2-2}[l_{q_2-2}.m_{q_2-2}(l_{q_2-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&\cup auth_{stack}(l, E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd E_{q_2-2}[l_{q_2-2}.m_{q_2-2}(l_{q_2-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} \bigcup^{q_2-1}_{i = p_2} pointsto(subexps(E_i), \mu) \cup \{ l_{p_2} \}& (Lemma~\textit{\ref{l:pt-has-stateful}})\\
&\cup auth_{stack}(l, E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd E_{q_2-2}[l_{q_2-2}.m_{q_2-2}(l_{q_2-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&\vdots\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} \\
&\cup auth_{stack}(l, E_{q_{r_2}-1}[l_{q_{r_2}-1}.m_{q_{r_2}-1}(l_{q_{r_2}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)
%&\cup auth_{stack}(l, E_{q_{r_2}-1}[l_{q_{r_2}-1}.m_{q_{r_2}-1}(l_{q_{r_2}-1}') \rhd E_{q_{r_2}-2}[l_{q_{r_2}-2}.m_{q_{r_2}-2}(l_{q_{r_2}-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)
\end{align*}
Depending on the values of $r_1$ and $r_2$, there are two possibilities.

\noindent\underline{\textit{Case $r_2 < r_1$:}} There is no other stateful callers after $l_{q_{r_2+1}}$, i.e.\\
$\forall l_0.m_0(l_0') \rhd E''' \in E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}')  \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ]$, \mbox{$l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{pure}} \in \mu$}, which implies that there are also no method call stack frames with $l$ as the caller after $l_{q_{r_2+1}}$, i.e.\\
$l.m'(l'') \rhd E'' \not\in E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}')  \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ]$\\

\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, l_{q_{r_2+1}}.m_{q_{r_2+1}}(l_{q_{r_2+1}}') \rhd E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}')  \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (\textsc{auth-stack})\\
&\cup pointsto(E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&\cup auth_{stack}(l, E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:pt-all-pure}})\\
&\cup \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)\\
&\cup auth_{stack}(l, E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}

\noindent\underline{\textit{Case $r_2 = r_1$:}} There are no method call stack frames with $l$ as the caller after $l_{q_{r_2+1}}$, i.e.\\
$l.m'(l'') \rhd E'' \not\in E_{q_{r_2}-1}[l_{q_{r_2}-1}.m_{q_{r_2}-1}(l_{q_{r_2}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ]$\\

\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, e, \mu)
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:pt-ses}
If $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$, then $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the $subexps(E)$ rules.\\

\noindent\underline{\textit{Case \textsc{subexps-e-empty}:}} By \textsc{pointsto-empty}, $pointsto(\varnothing, \mu') = pointsto(\varnothing, \mu) = \varnothing$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-method1}:}} $pointsto(subexps(E.m(e'')), \mu) = pointsto(e'', \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(E.m(e'')), \mu') = pointsto(e'', \mu') \cup pointsto(subexps(E), \mu')$.

Since we are considering small-step semantics and $e''$ is evaluated only after $E$ is fully evaluated, there were no changes to $e''$ at this evaluation steps, and $pointsto(e'', \mu') = pointsto(e'', \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(E.m(e'')), \mu') =pointsto(subexps(E.m(e'')), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-method2}:}} $pointsto(subexps(l.m(E)), \mu) = pointsto(l, \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(l.m(E)), \mu') = pointsto(l, \mu') \cup pointsto(subexps(E), \mu')$.

By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(l.m(E)), \mu') =pointsto(subexps(l.m(E)), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-field}:}} $pointsto(subexps(E.f), \mu) = pointsto(subexps(E), \mu)$, and similarly,\\
$pointsto(subexps(E.f), \mu') = pointsto(subexps(E), \mu')$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$, and thus $pointsto(subexps(E.f), \mu') =pointsto(subexps(E.f), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-assign1}:}} $pointsto(subexps(E.f = e''), \mu) = pointsto(e'', \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(E.f = e''), \mu') = pointsto(e'', \mu') \cup pointsto(subexps(E), \mu')$.

Since we are considering small-step semantics and $e''$ is evaluated only after $E$ is fully evaluated, there were no changes to $e''$ at this evaluation steps, and $pointsto(e'', \mu') = pointsto(e'', \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(E.f = e''), \mu') =pointsto(subexps(E.f = e''), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-bind}:}} $pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu) = pointsto(e'', \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu') = pointsto(e'', \mu') \cup pointsto(subexps(E), \mu')$.

Since we are considering small-step semantics and $e''$ is evaluated only after $E$ is fully evaluated, there were no changes to $e''$ at this evaluation steps, and $pointsto(e'', \mu') = pointsto(e'', \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu') =pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-assign2}:}} $pointsto(subexps(l.f = E), \mu) = pointsto(l, \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(l.f = E), \mu') = pointsto(l, \mu') \cup pointsto(subexps(E), \mu')$.

By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(l.f = E), \mu') =pointsto(subexps(l.f = E), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-stackframe}:}} $pointsto(subexps(l.m(l') \rhd E), \mu) = pointsto(l, \mu) \cup pointsto(l', \mu)$\\
$\cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(l.m(l') \rhd E), \mu') = pointsto(l, \mu') \cup pointsto(l', \mu) \cup pointsto(subexps(E), \mu')$.

By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$ and\\
$pointsto(l', \mu') = pointsto(l', \mu)$. By induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus $pointsto(subexps(l.m(l') \rhd E), \mu') =pointsto(subexps(l.m(l') \rhd E), \mu)$.
\qed
\end{proof}


\newpage
\begin{mdframed}
\begin{lemma}
\label{l:a-diff}
If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$ \intuition{\hspace{230pt} [$e$ can make a step of evaluation]}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$ \intuition{\hspace{270pt} [$l$ is a principal]}
\item $\forall i$, such that $l_i = l$, $i \in \{ q_1, q_2, \dots, q_{r_1} \}$, where $0 \leq r_1 \leq k$ \intuition{\newline [the set of indices of all method call stack frames where $l$ is the caller; this set can be empty]}
\item $\forall i \in \{ q_1, q_2, \dots, q_{r_1} \}$, if $\exists j$, such that
\begin{enumerate}
\item $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$ and \intuition{\hspace{220pt} [$l_j$ is a principal]}
\item $\forall t$, such that $i > t > j$ and $l_t \mapsto \{ x \Rightarrow \overline{d_t} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{40pt} [all callers between $l_i$ and $l_j$ are pure]}
\end{enumerate}
$j \in \{ p_1, p_2, \dots, p_{r_2}\}$ where $0 \leq r_2 \leq r_1$
\intuition{\newline [the maximal set of indices of principal callers immediately after method call stack frames where $l$ is the caller; this set can be smaller than the one above only by one element; this set can also be empty; such principals can be $l$ itself]}
\end{enumerate}
then
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e']] \dots ], \mu')$\\
$\setminus~auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & \text{if } r_2 < r_1\\
    \setminus~auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')& \text{if } r_2 = r_1\\
    \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{cases}
\end{align*}
\intuition{[If $r_2 < r_1$, then there are only pure principals after the last method call stack frame where $l$ is the caller. In other words, $l$ was the last principal caller on the stack.\\
If $r_2 = r_1$, then the last method call stack frame where $l$ is the caller is followed by a method call stack frame with a principal caller that is not $l$. If $r_2 = r_1 = 0$, then there are no method call stack frames with principal callers on the stack.\\
Since the set in 5(b) can include indices of method call stack frames where the caller is $l$, the difference between $r_1$ and $r_2$ is at most $1$, i.e. $r_2 \le r_1 \le r_2 + 1$.]}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $e$ and $e'$ on the stack.\\

\noindent\underline{\underline{\textit{Base case:}}} $k = 1$. Depending on the values of $r_1$ and $r_2$, there are two possibilities.

\noindent\underline{\textit{Case $r_2 < r_1$:}} $r_1 = 1$, $r_2 = 0$, and $l_1 = l$\\
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup pointsto(subexps(E_0), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:main-a-stack}})
\end{align*}
Similarly,
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu')$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup pointsto(subexps(E_0), \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu')\\
&= auth_{store}(l, \mu') \cup pointsto(subexps(E_0), \mu) \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & (Lemma~\textit{\ref{l:pt-ses}})
\end{align*}
Then 
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu')~\setminus~auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') \setminus auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}


\noindent\underline{\textit{Case $r_2 = r_1$:}} $r_1 = r_2 = 0$, and $l_1 \neq l$\\
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})
\end{align*}
Similarly,
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu') = auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')$. Then\\
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu')~\setminus~auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu') \setminus auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}

\noindent\underline{\underline{\textit{Inductive case:}}} $k > 1$\\
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) & (\textsc{auth-config})\\
&\cup auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=
\begin{cases}
    auth_{store}(l, \mu)\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu)\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e, \mu)\\
\end{cases} & (Lemma~\textit{\ref{l:main-a-stack}})
\end{align*}
Similarly,
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e']] \dots ], \mu')$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') & (\textsc{auth-config})\\
&\cup auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e']] \dots ], \mu')\\
&=
\begin{cases}
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu') \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu')\\\\
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu') \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e', \mu')\\
\end{cases} & (Lemma~\textit{\ref{l:main-a-stack}})\\
&=
\begin{cases}
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu')\\\\
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e', \mu')\\
\end{cases} & (Lemma~\textit{\ref{l:pt-ses}})
\end{align*}
Then 
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e']] \dots ], \mu') \setminus auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & \text{if } r_2 < r_1\\
    \setminus~auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')& \text{if } r_2 = r_1\\
    \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{cases}
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:sub-in-ses}
If $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$ and $z \in E$, then $subexps([l / z]E) = \{ l \} \cup subexps(E)$.
\end{lemma}
\end{mdframed}

\begin{proof}
The proof is by a straightforward induction on the $subexps(E)$ rules.\qed
\end{proof}


\newpage
\begin{mdframed}
\begin{lemma}
\label{l:sub-in-pt}
If $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$ and $l'.m'(l'') \rhd E \not\in e$, then
\[
pointsto([l / z]e, \mu) =
\begin{cases}
    pointsto(l, \mu) \cup pointsto(e, \mu) & \text{if } z \in e\\
    pointsto(e, \mu) & \text{if } z \not\in e\\
\end{cases}
\]
\end{lemma}
\end{mdframed}

\begin{proof} There are two cases depending on whether $z$ is in $e$ or not.\\

\noindent\underline{\underline{\textit{Case $z \in e$:}}} We prove this case by simultaneous induction on the $pointsto(d, \mu)$, $pointsto(\overline{d}, \mu)$, and $pointsto(e, \mu)$ rules.

\noindent\underline{\textit{Case \textsc{pointsto-def}:}}
\vspace{-7pt}
\begin{align*}
pointsto([l / z](\keyw{def} m(x : \tau_1) : \tau_2 = e')) &= pointsto(\keyw{def} m(x : \tau_1) : \tau_2 = [l / z]e', \mu)\\
&= pointsto([l / z]e', \mu) & (\textsc{pointsto-def})\\
&= pointsto(l, \mu) \cup pointsto(e', \mu) & (by~IH)\\
&= pointsto(l, \mu) \cup pointsto(\keyw{def} m(x : \tau_1) : \tau_2 = e', \mu) & (\textsc{pointsto-def})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-varx}:}} Since there is only one variable, $x = z$.
\vspace{-7pt}
\begin{align*}
pointsto([l / z](\keyw{var} f : \tau = x), \mu) &= pointsto(\keyw{var} f : \tau = l, \mu)\\
&= pointsto(l, \mu) & (\textsc{pointsto-varl})\\
&= pointsto(l, \mu) \cup pointsto(\keyw{var} f : \tau = x, \mu) & (\textsc{pointsto-varx})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-varl}:}} Since there are no variables, the substitution cannot take place, and the case is true by contradiction.

\noindent\underline{\textit{Case \textsc{pointsto-decls}:}} $pointsto([l / z]\overline{d}, \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup_{d \in \overline{d}} pointsto([l / z]d, \mu) & (\textsc{pointsto-decls})\\
&= pointsto(l, \mu) \bigcup_{d \in \overline{d}} pointsto(d, \mu) & (by~cases~\textsc{pointsto-def}, \textsc{pointsto-varx},~and~\textsc{pointsto-varl})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{pointsto-decls})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-empty}:}} $z \not\in \varnothing$ and the case is true by contradiction.

\noindent\underline{\textit{Case \textsc{pointsto-var}:}} $e = E[x]$. There are three subcases depending on whether $x = z$ and $z \in E$.

\noindent\underline{\textit{Subcase $x \neq z$ and $z \in E$:}} $[l / z]E[x] = E'[x]$, where $E' = [l / z]E$.
\begin{align*}
pointsto([l / z]E[x], \mu) &= pointsto(E'[x], \mu)\\
&= pointsto(subexps(E'), \mu) & (\textsc{pointsto-var})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[x], \mu) & (\textsc{pointsto-var})
\end{align*}

\noindent\underline{\textit{Subcase $x = z$ and $z \not\in E$:}} $[l / z]E[x] = E[l]$.\\
$pointsto([l / z]E[x], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E[l], \mu)\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-principal, pointsto-data, pointsto-empty})\\
&= pointsto(l, \mu) \cup pointsto(E[x], \mu) & (\textsc{pointsto-var})
\end{align*}

\noindent\underline{\textit{Subcase $x = z$ and $z \in E$:}} $[l / z]E[x] = E'[l]$, where $E' = [l / z]E$.\\
$pointsto([l / z]E[x], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E'[l], \mu)\\
&= pointsto(l, \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-principal, pointsto-data, pointsto-empty})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[x], \mu) & (\textsc{pointsto-var})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-principal} or \textsc{pointsto-data}:}} $e = E[l']$ and $z \in E$. Then $[l / z]E[l'] = E'[l']$, where \mbox{$E' = [l / z]E$}.\\
$pointsto([l / z]E[l'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E'[l'], \mu)\\
&= pointsto(l', \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-principal, pointsto-data, pointsto-empty})\\
&= pointsto(l', \mu) \cup pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[l'], \mu) & (\textsc{pointsto-principal, pointsto-data, pointsto-empty})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-new}:}} There are three subcases depending on whether $z \in \overline{d}$ and $z \in E$.

\noindent\underline{\textit{Subcase $z \not\in \overline{d}$ and $z \in E$:}} $[l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})] = E'[\keywadj{new}_s(x \Rightarrow \overline{d})]$, where $E' = [l / z]E$.
\begin{align*}
pointsto([l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) &= pointsto(E'[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu)\\
&= pointsto(\overline{d}, \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-new})\\
&= pointsto(\overline{d}, \mu) \cup pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) & (\textsc{pointsto-new})
\end{align*}

\noindent\underline{\textit{Subcase $z \in \overline{d}$ and $z \not\in E$:}} $[l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})] = E[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})]$.\\
$pointsto([l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})], \mu)\\
&= pointsto([l / z]\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-new})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (by~case~\textsc{pointsto-decls})\\
&= pointsto(l, \mu) \cup pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) & (\textsc{pointsto-new})
\end{align*}

\noindent\underline{\textit{Subcase $z \in \overline{d}$ and $z \in E$:}} $[l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})] = E'[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})]$, where $E' = [l / z]E$.\\
$pointsto([l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E'[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})], \mu)\\
&= pointsto([l / z]\overline{d}, \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-new})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(subexps(E'), \mu) & (by~case~\textsc{pointsto-decls})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) & (\textsc{pointsto-new})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-call-principal} or \textsc{pointsto-call-data}:}} Since both the cases have method call stack frames and the premise prohibits that, the cases are true by contradiction.\\

\noindent\underline{\underline{\textit{Case $z \not\in e$:}}} $[l / z]e = e$ and $pointsto([l / z]e, \mu) = pointsto(e, \mu)$.\\
\qed
\end{proof}



\newpage

\begin{theorem}[Authority Safety] If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{stateful}} \in \mu'$,
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$, and
\item $auth(l, e', \mu') \setminus auth(l, e, \mu) \supseteq \{ l_0 \}$,
\end{enumerate}
then one of the following must be true:
\begin{itemize}
\item \textbf{Object creation:}
\begin{enumerate}
\item $e = E[l.m(l') \rhd E'[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d_0})]]$ and
\item $e' = E[l.m(l') \rhd E'[l_0]]$, where
\item $\forall l_a.m_a(l_a') \rhd E'' \in E'$, $l_a \mapsto \{ x \Rightarrow \overline{d_a}\}_{\keywadj{pure}} \in \mu$ \intuition{\newline [there are only pure principals after the last method call stack frame where $l$ is the caller.]}
\end{enumerate}

\item \textbf{Method call:}
\begin{enumerate}
\item $e = E[l.m(l_0)]$ and
\item $e' = E[l.m(l_0) \rhd [l_0/y][l/x]e'']$
\item $y \in e''$ \intuition{\hspace{100pt} [the passed-in argument $y$ is used in the method body $e''$]}
\end{enumerate}

\item \textbf{Method return:}
\begin{enumerate}
\item $e = E[l.m(l') \rhd E'[l_a.m_a(l_a') \rhd l_0]]$ and
\item $e' = E[l.m(l') \rhd E'[l_0]]$, where
\item $\forall l_b.m_b(l_b') \rhd E'' \in E'$, $l_b \mapsto \{ x \Rightarrow \overline{d_b}\}_{\keywadj{pure}} \in \mu$ \intuition{\newline [there are only pure principals after the last method call stack frame where $l$ is the caller.]}
\end{enumerate}
\end{itemize}

\end{theorem}

\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy

\noindent\fbox{\parbox{\widthof{Case \textsc{E-Congruence}:}}{Case \textsc{E-Congruence}:}} $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$

Let us enumerate method call stack frames in $E$:
\begin{align*}
E[e] &= E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ]\\
E[e'] &= E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e']] \dots ]
\end{align*}
where
\begin{enumerate}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E' \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $\forall i$, such that $l_i = l$, $i \in \{ q_1, q_2, \dots, q_{r_1} \}$, where $0 \leq r_1 \leq k$ \intuition{\newline [the set of indices of all method call stack frames where $l$ is the caller; this set can be empty]}
\item $\forall i \in \{ q_1, q_2, \dots, q_{r_1} \}$, if $\exists j$, such that
\begin{enumerate}
\item $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$ and \intuition{\hspace{230pt} [$l_j$ is a principal]}
\item $\forall t$, such that $i > t > j$ and $l_t \mapsto \{ x \Rightarrow \overline{d_t} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{60pt} [all callers between $l_i$ and $l_j$ are pure]}
\end{enumerate}
$j \in \{ p_1, p_2, \dots, p_{r_2}\}$ where $0 \leq r_2 \leq r_1$
\intuition{\newline [the maximal set of indices of principal callers immediately after method call stack frames where $l$ is the caller; this set can be smaller than the one above only by one element; this set can also be empty; such principals can be $l$ itself]}
\end{enumerate}
Then
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e']] \dots ], \mu')$\\
$\setminus~auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & \text{if } r_2 < r_1\\
    \setminus~auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')& \text{if } r_2 = r_1\\
    \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{cases} & (Lemma~\textit{\ref{l:a-diff}})
\end{align*}
\intuition{[If $r_2 < r_1$, then there are only pure principals after the last method call stack frame where $l$ is the caller. In other words, $l$ was the last principal caller on the stack.\\
If $r_2 = r_1$, then the last method call stack frame where $l$ is the caller is followed by a method call stack frame with a principal caller that is not $l$. If $r_2 = r_1 = 0$, then there are no method call stack frames with principal callers on the stack.\\
Since the set in 3(b) can include indices of method call stack frames where the caller is $l$, the difference between $r_1$ and $r_2$ is at most $1$, i.e. $r_2 \le r_1 \le r_2 + 1$.]}\\
Thus the changes in authority when $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$ depend on what expressions are in $e~|~\mu \longrightarrow e'~|~\mu'$. Let us consider all possible $e$ and $e'$.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-New}:}}{Subcase \textsc{E-New}:}}
\mbox{$e = \keywadj{new}_s(x \Rightarrow \overline{d_a})$}, \mbox{$e' = l_a$}, and \mbox{$E[\keywadj{new}_s(x \Rightarrow \overline{d_a})]~|~\mu \longrightarrow E[l_a]~|~\mu'$}, where\\
\mbox{$\mu' = \mu, l_a \mapsto \{ x \Rightarrow \overline{d_a} \}_s$}.

By \textsc{auth-store}, $auth_{store}(l, \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu)$ and $auth_{store}(l, \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu')$. By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$. By \textsc{pointsto-decls} and the $pointsto(d, \mu)$ rules, $pointsto(\overline{d}, \mu)$ depends only on what is in $\overline{d}$ and whether it is stateful. Then since the only change to the store was the addition of a new object $l_a$, and by inversion on \textsc{E-New}, $l_a \not\in dom(\mu)$ and $\keywadj{new}_s(x \Rightarrow \overline{d_a})$ is a closed term, i.e. it is fully defined and all objects in $\overline{d_a}$ must be in the store at the time of the object creation (\textsc{T-Store}), $pointsto(l_a, \mu) \not\in pointsto(\overline{d}, \mu')$. Thus, $auth_{store}(l, \mu') = auth_{store}(l, \mu)$.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_a, \mu') \cup auth_{stack}(l, l_a, \mu')\\
& \setminus pointsto(\keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu) \cup auth_{stack}(l, \keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu)\\
&= pointsto(l_a, \mu') \setminus pointsto(\keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= pointsto(l_a, \mu') \setminus pointsto(\overline{d_a}, \mu) & (\textsc{pointsto-new}, \textsc{pointsto-empty})
\end{align*}
There are two possibilities depending on whether $l_a$ is a principal or not.

\noindent\underline{\textit{Case $l_a$ is a principal:}}
\vspace{-7pt}
\begin{align*}
auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) &= \{ l_a \} \setminus pointsto(\overline{d_a}, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty}) 
\end{align*}
Since $l_a$ points to a fresh memory location and our language requires an object to be allocated in memory before it can be used, $\{ l_a \} \not\in pointsto(\overline{d_a}, \mu)$, the authority of $l$ increases, which is in accordance with the \textbf{\textit{object creation}} case, and the theorem holds.

\noindent\underline{\textit{Case $l_a$ is pure:}}
\vspace{-7pt}
\begin{align*}
auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) &= \varnothing \setminus pointsto(\overline{d_a}, \mu) & (\textsc{pointsto-data}, \textsc{pointsto-empty})
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_a, \mu') \setminus auth_{stack}(l, \keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu)\\
&= \varnothing & (\textsc{auth-stack-nocall} \times 2)
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Method}:}}{Subcase \textsc{E-Method}:}}
$e = l_a.m(l_b)$, \mbox{$e' = l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a$}, \mbox{$\mu' = \mu$}, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$. Since $e_a$ is a method definition, by Property~\ref{prop:mcsf-def-bind}, $e_a$ has no method call stack frames.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}} \noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\begin{align*}
&= pointsto(l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu)\\
&\setminus pointsto(l_a.m(l_b), \mu) \cup auth_{stack}(l, l_a.m(l_b), \mu)\\
&= pointsto(l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})\\
&\setminus pointsto(l_a.m(l_b), \mu)
\end{align*}
There are three possibilities depending on whether $l_a = l$ and whether it is a principal or not.

\noindent\underline{\textit{Case $l_a = l$:}} Since $l$ is a principal, $l_a$ is a principal too.\\
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= \{ l_a \} \cup auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) & (\textsc{pointsto-call-principal}, \textsc{pointsto-empty})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{subexps-e-method2})\\
&= \{ l_a \} \cup pointsto([l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
&= \{ l_a \} \cup pointsto([l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
&= pointsto(l_a, \mu) \cup pointsto([l_b / y][l_a / x]e_a, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)
\end{align*}
\vspace{-25pt}
\begin{align*}
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x, y \not\in e_a
\end{cases} & (Lemma~\textit{\ref{l:sub-in-pt}} \times 2)\\
&=
\begin{cases}
    pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) & \text{if } x, y \not\in e_a
\end{cases}\\
&\subseteq pointsto(e_a, \mu)\\
&= auth_{store}(l, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu)
\end{align*}
By \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $auth_{store}(l, \mu) \supseteq pointsto(e_a, \mu)$, and therefore, $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) = \varnothing$. Thus, the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is a principal:}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= \{ l_a \} \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{pointsto-call-principal}, \textsc{pointsto-empty})\\
&= pointsto(l_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is pure:}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto([l_b / y][l_a / x]e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{pointsto-call-data}, \textsc{pointsto-empty})
\end{align*}
\vspace{-25pt}
\begin{align*}
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x, y \not\in e_a
\end{cases} & (Lemma~\textit{\ref{l:sub-in-pt}} \times 2)\\
&=
\begin{cases}
    pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) &\text{if } x, y \not\in e_a
\end{cases}\\
&\subseteq pointsto(e_a, \mu)\\
&= auth_{store}(l, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu)
\end{align*}
By \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $auth_{store}(l, \mu) \supseteq pointsto(e_a, \mu)$, and therefore, $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) = \varnothing$. Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}} \noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) \setminus auth_{stack}(l, l_a.m(l_b), \mu)\\
&= auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
There are two possibilities depending on whether $l_a = l$ or not.

\noindent\underline{\textit{Case $l_a = l$:}} Since $l$ is a principal, $l_a$ is a principal too.\\
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto([l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack})\\
&= pointsto([l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
\begin{align*}
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a~~~~~~~~~(Lemma~\textit{\ref{l:sub-in-pt}} \times 2)\\
    pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    pointsto(e_a, \mu) & \text{if } x, y \not\in e_a
\end{cases}\\
&=
\begin{cases}
    auth_{store}(l, \mu) \cup pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \in e_a\\
    auth_{store}(l, \mu) \cup pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    auth_{store}(l, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \not\in e_a
\end{cases}
\end{align*}
Since $l_a = l$ and by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $auth_{store}(l, \mu) \supseteq pointsto(l_a, \mu) \cup pointsto(e_a, \mu)$. Then $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \in e_a\\
    auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \not\in e_a
\end{cases}\\
&=
\begin{cases}
    pointsto(l_b, \mu) & \text{if } y \in e_a\\
    \varnothing & \text{if } y \not\in e_a\\
\end{cases}\\
&=
\begin{cases}
    \{ l_b \} & \text{if } y \in e_a \text{ and } l_b \text { is a principal}~~~(\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
    \varnothing & \text{otherwise}\\
\end{cases}
\end{align*}
Thus, if $y \in e_a$ and $l_b$ is a principal, the authority of $l$ increases, which is in accordance with the \textbf{\textit{method call}} case, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$:}} $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) = \varnothing~~~~~~~~~~~~(\textsc{auth-stack-nocall})$\\
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Field}:}}{Subcase \textsc{E-Field}:}}
$e = l_a.f$, $e' = l_b$, $\mu' = \mu$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$.

By Property~\ref{prop:fields-private}, the object field that is being accessed must belong to the caller of the last method call stack frame on the stack. Then $l_1 = l_a$, and by definition of a principal, since $l_1$ has fields, it is a principal.

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}} Since $l_1$ is a principal, $l = l_1 = l_a$.\\
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_b, \mu) \cup auth_{stack}(l, l_b, \mu) \setminus pointsto(l.f, \mu) \cup auth_{stack}(l, l.f, \mu)\\
&= pointsto(l_b, \mu) \setminus pointsto(l.f, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \setminus auth_{store}(l, \mu) \cup pointsto(l.f, \mu)
\end{align*}
By inversion on \textsc{E-Field}, $\keyw{var} f : \tau = l_b \in \overline{d}$. Then by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu) \supseteq pointsto(l_b, \mu)$, and
\begin{align*}
auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) &= auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) \cup pointsto(l.f, \mu) = \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}} $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_b, \mu) \setminus auth_{stack}(l, l_a.f, \mu)\\ 
&= \varnothing & (\textsc{auth-stack-nocall} \times 2)
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Assign}:}}{Subcase \textsc{E-Assign}:}}
$e = (l_a.f = l_b)$, $e' = l_b$, and by inversion on \textsc{E-Assign}, $l_a \mapsto \{ x \Rightarrow \overline{d_a} \}_{s} \in \mu$, \mbox{$\keyw{var} f : \tau = l_c \in \overline{d_a}$}, $\overline{d_a}' = [\keyw{var} f : \tau = l_b/\keyw{var} f : \tau = l_c]\overline{d_a}$, and $\mu' = [l_a \mapsto \{ x \Rightarrow \overline{d_a}' \}_{s}/l_a \mapsto \{ x \Rightarrow \overline{d_a} \}_{s}]\mu$.

By Property~\ref{prop:fields-private}, the object field that is being accessed must belong to the caller of the last method call stack frame on the stack. Then $l_1 = l_a$, and by definition of a principal, since $l_1$ has fields, it is a principal.

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}} Since $l_1$ is a principal, in this case, $l = l_1 = l_a$.

Since in this step of evaluation, the only change to the store is the substitution of $l_c$ with $l_b$ in one of $l$'s fields, by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu') \setminus auth_{store}(l, \mu) \subseteq pointsto(l_b, \mu')$. [1]

By \textsc{pointsto-principal}, \textsc{pointsto-data}, and \textsc{pointsto-empty}, $pointsto(l_b, \mu') = pointsto(l_b, \mu)$. \hspace{12pt} [2]

\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup pointsto(l_b, \mu') \cup auth_{stack}(l, l_b, \mu')\\
&\setminus~auth_{store}(l, \mu) \cup pointsto(l.f = l_b, \mu) \cup auth_{stack}(l, l.f = l_b, \mu)\\
&= auth_{store}(l, \mu') \cup pointsto(l_b, \mu') \setminus auth_{store}(l, \mu) \cup pointsto(l.f = l_b, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= auth_{store}(l, \mu') \cup pointsto(l_b, \mu') \setminus auth_{store}(l, \mu) \cup pointsto(l, \mu) \cup pointsto(l_b, \mu) & (\textsc{subexps-e-assign2})\\
&\subseteq pointsto(l_b, \mu') \setminus pointsto(l, \mu) \cup pointsto(l_b, \mu) & (by~[1])\\
&= \varnothing & (by~[2])
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}} Since $l_1$ is a principal and $l_1 = l_a$, in this case, $l \neq l_a$ and $r_2 = r_1 \neq 0$.

Since $l \neq l_a$ and, in this step of evaluation, the only change to the store is the substitution of $l_c$ with $l_b$ in one of $l_1$'s fields, by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu') = auth_{store}(l, \mu)$. [3]

\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup auth_{stack}(l, l_b, \mu') \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, l_a.f = l_b, \mu)\\
&= auth_{store}(l, \mu') \setminus auth_{store}(l, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= \varnothing & (by~[3])
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Bind}:}}{Subcase \textsc{E-Bind}:}}
$e = \keyw{bind} x = l_a~\keyw{in} e_a$, $e' = [l_a/x]e_a$, $\mu' = \mu$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$. Since $e_a$ is a method definition, by Property~\ref{prop:mcsf-def-bind}, $e_a$ has no method call stack frames.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto([l_a/x]e_a, \mu) \cup auth_{stack}(l, [l_a/x]e_a, \mu)\\
&\setminus pointsto(\keyw{bind} x = l_a~\keyw{in} e_a, \mu) \cup auth_{stack}(l, \keyw{bind} x = l_a~\keyw{in} e_a, \mu)\\
&= pointsto([l_a/x]e_a, \mu) \setminus pointsto(\keyw{bind} x = l_a~\keyw{in} e_a, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= pointsto([l_a/x]e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & (\textsc{subexps-e-bind})\\
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & \text{if } x \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a
\end{cases} & (Lemma~\textit{\ref{l:sub-in-pt}})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, [l_a/x]e_a, \mu) \setminus auth_{stack}(l, \keyw{bind} x = l_a~\keyw{in} e_a, \mu)\\
&= \varnothing & (\textsc{auth-stack-nocall} \times 2)
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-StackFrame}:}}{Subcase \textsc{E-Stackframe}:}}
$e = l_a.m(l_b) \rhd l_c$, $e' = l_c$, $\mu' = \mu$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu) \cup auth_{stack}(l, l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
There are three possibilities depending on whether $l_a = l$ and whether it is a principal or not.

\noindent\underline{\textit{Case $l_a = l$:}} Since $l$ is a principal, $l_a$ is a principal too.\\
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup pointsto(l_c, \mu) \cup auth_{stack}(l, l_c, \mu) & (\textsc{auth-stack})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is a principal:}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu)\\
& \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus \{ l_a \} \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{pointsto-call-principal}, \textsc{pointsto-empty})\\
&= pointsto(l_c, \mu) \setminus \{ l_a \} & (\textsc{auth-stack-nocall})\\
&=
\begin{cases}
    \{ l_c \} \setminus \{ l_a \} & \text{if } l_c \text{ is a principal}~~~(\textsc{pointsto-principal})\\
    \varnothing & \text{if } l_c \text{ is pure}~~~~~~~~~~~(\textsc{auth-stack-nocall})
\end{cases}
\end{align*}
Thus if $l_a \neq l$, $l_a$ is a principal, and $l_c$ is a principal, then the authority of $l$ increases, which is in accordance with the \textbf{\textit{method return}} case, and the theorem holds. If $l_a \neq l$, $l_a$ is a principal, and $l_c$ is pure, then the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is pure:}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus pointsto(l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{pointsto-call-data}, \textsc{pointsto-empty})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_c, \mu) \setminus auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= \varnothing \setminus auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{auth-stack-nocall})\\
&= \varnothing
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\\
\qed
\end{proof}


\newpage
\section{Previous}

\begin{mdframed}
\begin{lemma}
\label{l:four}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l.m(l') \rhd E \not\in E_i$
\item for $1 \leq i \leq k$, $l_i \mapsto \{ x \Rightarrow \overline{d_i} \}_{\keywadj{pure}} \in \mu$ and $l \neq l_i$
\end{enumerate}
then
\noindent$auth_{stack}(l, l.m(l') \rhd E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup^k_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $E_0[e]$ on the stack.

\noindent\underline{\textit{Base case:}} $k = 1$\\
\noindent$auth_{stack}(l, l.m(l') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) \cup auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{auth-stack}) \\
&= pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}}) \\
&= \bigcup^1_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:pt-all-pure}})
\end{align*}

\noindent\underline{\textit{Inductive case:}} $k > 1$\\
\noindent$auth_{stack}(l, l.m(l') \rhd E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (\textsc{auth-stack})\\
& \cup auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, e, \mu) \\
&= \bigcup^k_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:pt-all-pure}})
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:five}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E \not\in E_i$
\item for $2 \leq i \leq k - 1$, $l_i \neq l$ and $l_1 = l_k = l$
\item $\exists j$, such that $1 \leq j \leq k - 1$, $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$
\end{enumerate}
then
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup^{k-1}_{i = p} pointsto(subexps(E_i), \mu) \cup \{ l_p \} \cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu)
\end{align*}
where $1 \leq p \leq k - 1$ and $p$ is the largest index, such that $l_p \mapsto \{ x \Rightarrow \overline{d_p} \}_{\keywadj{stateful}} \in \mu$.
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $E_0[e]$ on the stack.

\noindent\underline{\textit{Base case:}} $k = 3$ and $l_1 = l_3 = l$\\
\noindent$auth_{stack}(l, E_3[l_3.m_3(l_3') \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]]]], \mu)$
\vspace{-7pt}
\begin{align*}
&=  pointsto(E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]]], \mu) & (\textsc{auth-stack})\\
&\cup auth_{stack}(l, E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]]], \mu)\\
&=  pointsto(E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]]], \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu)
\end{align*}
At least one of $l_2$ and $l_1$ must be a principal, and therefore, there are the following two cases.

\noindent\underline{\textit{Subcase $l_2 \mapsto \{ x \Rightarrow \overline{d_2} \}_{\keywadj{stateful}} \in \mu$:}} $p = 2$\\
\noindent$auth_{stack}(l, E_3[l_3.m_3(l_3') \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]]]], \mu)$
\vspace{-7pt}
\begin{align*}
&=  pointsto(subexps(E_2), \mu) \cup \{ l_2 \} \cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu) & (\textsc{pointsto-call-principal})
\end{align*}

\noindent\underline{\textit{Subcase $l_2 \mapsto \{ x \Rightarrow \overline{d_2} \}_{\keywadj{pure}} \in \mu$ and $l_1 \mapsto \{ x \Rightarrow \overline{d_a} \}_{\keywadj{stateful}} \in \mu$:}} $p = 1$\\
\noindent$auth_{stack}(l, E_3[l_3.m_3(l_3') \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]]]], \mu)$
\vspace{-7pt}
\begin{align*}
&=  pointsto(subexps(E_2), \mu) \cup pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{pointsto-call-data})\\
&\cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu)\\
&=  pointsto(subexps(E_2), \mu) \cup pointsto(subexps(E_1), \mu) \cup \{ l_1 \} & (\textsc{pointsto-call-principal})\\
&\cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu)
\end{align*}
In both cases, we get\\
\noindent$auth_{stack}(l, E_3[l_3.m_3(l_3') \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]]]], \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup^{k-1}_{i = p} pointsto(subexps(E_i), \mu) \{ l_p \} \cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu)
\end{align*}

\noindent\underline{\textit{Inductive case:}} $k > 1$\\
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  pointsto(E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (\textsc{auth-stack})\\
&\cup auth_{stack}(l, E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  pointsto(E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu)\\
&= \bigcup^{k-1}_{i = p} pointsto(subexps(E_i), \mu) \cup \{ l_p \} \cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu) & (Lemma~\textit{\ref{l:pt-has-stateful}})
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:six}
If
\begin{enumerate}
\item for $1 \leq i \leq k$, $l'.m(l'') \rhd E \not\in E_i$
\item for $i \in \{ q_1, q_2, \dots, q_r, 1 \}$, $1 \leq r \leq \frac{k+1}{2}$, $l_i = l$
\item for $i \in \{ p_1, p_2, \dots, p_r\}$, $1 \leq r \leq \frac{k+1}{2}$, $l_{p_i} \mapsto \{ x \Rightarrow \overline{d_{p_i}} \}_{\keywadj{stateful}} \in \mu$ and $p_i$ is the largest index, such that $p_i < q_i$
\end{enumerate}
then
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_r, p_r) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_r \}} \{ l_j \} \cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu)
\end{align*}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $E_0[e]$ on the stack.

\noindent\underline{\textit{Base case:}} $k = 2$, $l_2 = l_1 = l$, and $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$\\
\noindent$auth_{stack}(l, E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) \cup auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{auth-stack}) \\
&= pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) \cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}}) \\
&= pointsto(subexps(E_1), \mu) \cup \{ l_1 \} \cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu) & (\textsc{pointsto-call-principal})\\
&= \bigcup_{(q, p) \in \{ (2, 1) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ 1 \}} \{ l_j \} \cup auth_{stack}(l, l_1.m_1(l_1') \rhd E_0[e], \mu)
\end{align*}

\noindent\underline{\textit{Inductive case:}} $k > 1$\\
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
& =\bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (Lemma~\textit{\ref{l:five}})\\
&\cup auth_{stack}(l, l.m_{p_2}(l_{p_2}') \rhd E_{p_2-1}[l_{p_2-1}.m_{p_2-1}(l_{p_2-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
& =\bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} \bigcup^{q_2-1}_{i = p_2} pointsto(subexps(E_i), \mu) \cup \{ l_{p_2} \} & (Lemma~\textit{\ref{l:five}})\\
&\cup auth_{stack}(l, l.m_{p_2}(l_{p_2}') \rhd E_{p_2-1}[l_{p_2-1}.m_{p_2-1}(l_{p_2-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_r, p_r) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) & (Lemma~\textit{\ref{l:five}} \times (r - 2))\\
&\bigcup_{j \in \{ p_1, p_2, \dots, p_r \}} \{ l_j \} \cup auth_{stack}(l, l.m_1(l_1') \rhd E_0[e], \mu)
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma} If
\begin{enumerate}
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$
\item $E[l.m(l') \rhd E'[e]]~|~\mu \longrightarrow E[l.m(l') \rhd E'[e']]~|~\mu'$
\item $\forall l_0.m_0(l_0') \rhd E'' \in E'$, $l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{pure}} \in \mu$,
\end{enumerate}
then $auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth(l, E[l.m(l') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&=  auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu') \cup pointsto(e', \mu') \setminus auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu) \cup pointsto(e, \mu)
\end{align*}
\end{lemma}
\end{mdframed}

\begin{proof}
\[
E[l.m(l') \rhd E'[e]] = E_{k_1}[l_{k_1}.m_{k_1}(l_{k_1}') \rhd E_{k_1-1}[l_{k_1-1}.m_{k_1-1}(l_{k_1-1}') \rhd \dots \rhd E_1[l.m(l') \rhd E'[e]] \dots ]
\]
where
\begin{enumerate}
\item for $1 \leq i \leq k_1$, $l''.m'(l''') \rhd E'' \not\in E_i$
\item for $i \in \{ q_1, q_2, \dots, q_r\}$, $0 \leq r \leq \frac{k_1}{2}$, $l_i = l$
\item for $i \in \{ p_1, p_2, \dots, p_r\}$, $0 \leq r \leq \frac{k_1}{2}$, \mbox{$l_{p_i} \mapsto \{ x \Rightarrow \overline{d_{p_i}} \}_{\keywadj{stateful}} \in \mu$} and $p_i$ is the largest index $p_i < q_i$
\end{enumerate}

\noindent By \textsc{auth-config},
\noindent$auth(l, E[l.m(l') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&=  auth_{store}(l, \mu) \cup auth_{stack}(l, E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd \dots \rhd E_1[l.m(l') \rhd E'[e]] \dots ], \mu),
\end{align*}

\noindent By Lemma~\ref{l:six},
\noindent$auth_{stack}(l, E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd \dots \rhd E_1[l.m(l') \rhd E'[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup_{(q, p) \in \{ (q_2, p_2), (q_3, p_3), \dots (q_r, p_r) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_2, p_3, \dots, p_r \}} \{ l_j \} \cup auth_{stack}(l, l.m(l') \rhd E'[e], \mu),
\end{align*}
\[
l.m(l') \rhd E'[e] = l.m(l') \rhd E_{k_2}[l_{k_2}.m_{k_2}(l_{k_2}') \rhd E_{k_2-1}[l_{k_2-1}.m_{k_2-1}(l_{k_2-1}') \rhd \dots \rhd E_1[l.m(l') \rhd E'[e]] \dots ]\]
where for $1 \leq i \leq k$, $l''.m'(l''') \rhd E'' \not\in E_i$

\noindent By Lemma~\ref{l:four},
\noindent$auth_{stack}(l, E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd \dots \rhd E_1[l.m(l') \rhd E'[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup_{(q, p) \in \{ (q_2, p_2), (q_3, p_3), \dots (q_r, p_r) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_2, p_3, \dots, p_r \}} \{ l_j \} \\
&\cup auth_{stack}(l, e, \mu) \bigcup^{k_2}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)
\end{align*}
and $auth(l, E[l.m(l') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&=  auth_{store}(l, \mu) \cup \bigcup_{(q, p) \in \{ (q_2, p_2), (q_3, p_3), \dots (q_r, p_r) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_2, p_3, \dots, p_r \}} \{ l_j \} \\
&\cup auth_{stack}(l, e, \mu) \bigcup^{k_2}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)
\end{align*}

\noindent Similarly,
\noindent$auth(l, E[l.m(l') \rhd E'[e']], \mu')$
\vspace{-7pt}
\begin{align*}
&=  auth_{store}(l, \mu') \cup \bigcup_{(q, p) \in \{ (q_2, p_2), (q_3, p_3), \dots (q_r, p_r) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu') \bigcup_{j \in \{ p_2, p_3, \dots, p_r \}} \{ l_j \} \\
&\cup auth_{stack}(l, e', \mu') \bigcup^{k_2}_{i = 0} pointsto(subexps(E_i), \mu') \cup pointsto(e', \mu')
\end{align*}

\noindent Since we are considering small-step semantics, on the given evaluation step, there were no changes to $E$ or $E'$; and therefore,
\noindent$auth(l, E[l.m(l') \rhd E'[e']], \mu')$
\vspace{-7pt}
\begin{align*}
&=  auth_{store}(l, \mu') \cup \bigcup_{(q, p) \in \{ (q_2, p_2), (q_3, p_3), \dots (q_r, p_r) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_2, p_3, \dots, p_r \}} \{ l_j \} \\
&\cup auth_{stack}(l, e', \mu') \bigcup^{k_2}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e', \mu')
\end{align*}
Then $auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth_{stack}(l, E[l.m(l') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&=  auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu') \cup pointsto(e', \mu') \setminus auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu) \cup pointsto(e, \mu)
\end{align*}
\qed
\end{proof}


\begin{lemma} If
\begin{enumerate}
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$,
\item $E[l.m(l') \rhd E'[e]]~|~\mu \longrightarrow E[l.m(l') \rhd E'[e']]~|~\mu'$, and
\item $l.m'(l'') \rhd E'' \not\in E'[e]$,
\end{enumerate}
then $auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth(l, E[l.m(l') \rhd E'[e]], \mu) = pointsto(E[e'], \mu') \setminus pointsto(E[e], \mu)$.
\end{lemma}

\begin{proof} The proof is by induction on the method call stack frames.\\

\noindent\textit{\underline{Base case:}}

\noindent\textit{\underline{Inductive case:}} Let $E$ contain $k$ method call stack call frames where $l$ is the caller:
\[
E[l.m(l') \rhd E'[e]] = E_k ... E_k[l_{k-1}.m_{k-1}(l_{k-1}') \rhd E_{k-1}[l_{k-2}.m_{k-2}(l_{k-2}') \rhd \dots \rhd E_1[e]] \dots ]
\]
\end{proof}

\begin{lemma} If
\begin{enumerate}
\item $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$ and
\item $\forall l.m(l') \rhd E' \not\in E$, $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{pure}} \in \mu$,
\end{enumerate}
then $pointsto(E[e'], \mu') \setminus pointsto(E[e], \mu) = pointsto(e, \mu') \setminus pointsto(e, \mu)$.
\end{lemma}

\begin{proof}
\end{proof}

\begin{lemma} If
\begin{enumerate}
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$,
\item $E[l.m(l') \rhd E'[e]]~|~\mu \longrightarrow E[l.m(l') \rhd E'[e']]~|~\mu'$,
\item $l.m'(l'') \rhd E''' \not\in E'[e]$, and
\item $\forall l_0.m_0(l_0') \rhd E''' \not\in E'$, $l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{pure}} \in \mu$,
\end{enumerate}
then $auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth(l, E[l.m(l') \rhd E'[e]], \mu) = pointsto(e', \mu') \setminus pointsto(e, \mu)$.
\end{lemma}

\begin{proof}
\end{proof}


\newpage

\begin{theorem}[Authority Safety] If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $l_1 \mapsto \{ x \Rightarrow \overline{d_1} \}_{\keywadj{stateful}} \in \mu'$,
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$, and
\item $auth(l, e', \mu') \setminus auth(l, e, \mu) \supseteq \{ l_1 \}$,
\end{enumerate}
then one of the following must be true:
\begin{itemize}
\item \textbf{Object creation:}
\begin{enumerate}
\item $e = E[l.m(l_2) \rhd E'[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d_1})]]$ and
\item $e' = E[l.m(l_2) \rhd E'[l_1]]$, where
\item $\forall l'.m'(l'') \rhd E'' \in E'$, $l' \mapsto \{ x \Rightarrow \overline{d'}\}_{\keywadj{pure}} \in \mu$
%\item $\nexists l'$, such that $l' \mapsto \{ x \Rightarrow \overline{d'}\}_{\keywadj{stateful}} \in \mu$ and $l'.m'(l'') \rhd E'' \in E'$
\end{enumerate}

\item \textbf{Method call:}
\begin{enumerate}
\item $e = E[l.m(l_1)]$ and
\item $e' = E[l.m(l_1) \rhd [l_1/y][l/x]e'']$
\end{enumerate}

\item \textbf{Method return:}
\begin{enumerate}
\item $e = E[l.m(l_2) \rhd E'[l_3.m'(l_4) \rhd l_1]]$ and
\item $e' = E[l.m(l_2) \rhd E'[l_1]]$, where
\item $\forall l'.m''(l''') \rhd E'' \in E'$, $l' \mapsto \{ x \Rightarrow \overline{d'}\}_{\keywadj{pure}} \in \mu$
%\item $\nexists l'$, such that $l' \mapsto \{ x \Rightarrow \overline{d'}\}_{\keywadj{stateful}} \in \mu$ and $l'.m''(l'') \rhd E'' \in E'$
\end{enumerate}
\end{itemize}

\end{theorem}

\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy 

\noindent\fbox{\parbox{\widthof{Case \textsc{E-Congruence}:}}{Case \textsc{E-Congruence}:}} The changes in authority when $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$ depend on what expressions are in $e~|~\mu \longrightarrow e'~|~\mu'$. Let us consider all possible $e$ and $e'$.\\

\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-New}:}}{Subcase \textsc{E-New}:}}
$e = \keywadj{new}_s(x \Rightarrow \overline{d_1})$, $e' = l_1$, and $E[\keywadj{new}_s(x \Rightarrow \overline{d_1})]~|~\mu \longrightarrow E[l_1]~|~\mu'$, where \mbox{$\mu' = \mu, l_1 \mapsto \{ x \Rightarrow \overline{d_1} \}_s$}.

Let $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$, such that $E'[l.m(l') \rhd E''[\keywadj{new}_s(x \Rightarrow \overline{d_1})]]~|~\mu \longrightarrow E'[l.m(l') \rhd E''[l_1]]~|~\mu'$, where $\forall l_0.m_0(l_0') \rhd E''' \in E''$, $l_0 \mapsto \{ x \Rightarrow \overline{d_0}\}_{\keywadj{pure}} \in \mu$.

This implies that $l.m'(l'') \rhd E''' \not\in E''[e]$. Then we get

\noindent$auth(l, E'[l.m(l') \rhd E''[l_1]], \mu') \setminus auth(l, E'[l.m(l') \rhd E''[\keywadj{new}_s(x \Rightarrow \overline{d_1})]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu') \setminus pointsto(\keywadj{new}_s(x \Rightarrow \overline{d_1}), \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu') \setminus pointsto(\overline{d_1}, \mu) & (\textsc{pointsto-new}, \textsc{pointsto-empty})
\end{align*}
There are two possibilities depending on whether $l_1$ is a principal or not.\\

\noindent\underline{\textit{Case $l_1$ is a principal:}}

\noindent$auth(l, E'[l.m(l') \rhd E''[l_1]], \mu') \setminus auth(l, E'[l.m(l') \rhd E''[\keywadj{new}_s(x \Rightarrow \overline{d_1})]], \mu)$
\vspace{-7pt}
\begin{align*}
&= \{ l_1 \} \setminus pointsto(\overline{d_1}, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
&= \{ l_1 \}
\end{align*}
The authority of $l$ increases, but this is in accordance with the \textbf{\textit{object creation}} case, and the theorem holds.\\

\noindent\underline{\textit{Case $l_1$ is pure:}}

\noindent$auth(l, E'[l.m(l') \rhd E''[l_1]], \mu') \setminus auth(l, E'[l.m(l') \rhd E''[\keywadj{new}_s(x \Rightarrow \overline{d_1})]], \mu)$
\vspace{-7pt}
\begin{align*}
&= \varnothing \setminus pointsto(\overline{d_1}, \mu) & (\textsc{pointsto-data}, \textsc{pointsto-empty})\\
&= \varnothing
\end{align*}
The authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Method}:}}{Subcase \textsc{E-Method}:}}
$e = l.m(l_1)$, \mbox{$e' = l.m(l_1) \rhd [l_1 / y][l / x]e''$}, and \mbox{$E[l.m(l_1)]~|~\mu \longrightarrow E[l.m(l_1) \rhd [l_1 / y][l / x]e'']~|~\mu$}.

Let $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$, such that $E'[l.m(l') \rhd E''[\keywadj{new}_s(x \Rightarrow \overline{d_1})]]~|~\mu \longrightarrow E'[l.m(l') \rhd E''[l_1]]~|~\mu'$, where $\forall l_0.m_0(l_0') \rhd E''' \in E''$, $l_0 \mapsto \{ x \Rightarrow \overline{d_0}\}_{\keywadj{pure}} \in \mu$.

This implies that $l.m'(l'') \rhd E''' \not\in E''[e]$. Then we get

\noindent$auth(l, E'[l.m(l') \rhd E''[l_1]], \mu') \setminus auth(l, E'[l.m(l') \rhd E''[\keywadj{new}_s(x \Rightarrow \overline{d_1})]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu') \setminus pointsto(\keywadj{new}_s(x \Rightarrow \overline{d_1}), \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu') \setminus pointsto(\overline{d_1}, \mu) & (\textsc{pointsto-new}, \textsc{pointsto-empty})
\end{align*}
There are two possibilities depending on whether $l_1$ is a principal or not.\\

\noindent\underline{\textit{Case $l_1$ is a principal:}}

\noindent$auth(l, E'[l.m(l') \rhd E''[l_1]], \mu') \setminus auth(l, E'[l.m(l') \rhd E''[\keywadj{new}_s(x \Rightarrow \overline{d_1})]], \mu)$
\vspace{-7pt}
\begin{align*}
&= \{ l_1 \} \setminus pointsto(\overline{d_1}, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
&= \{ l_1 \}
\end{align*}
The authority of $l$ increases, but this is in accordance with the \textbf{\textit{object creation}} case, and the theorem holds.\\

\noindent\underline{\textit{Case $l_1$ is pure:}}

\noindent$auth(l, E'[l.m(l') \rhd E''[l_1]], \mu') \setminus auth(l, E'[l.m(l') \rhd E''[\keywadj{new}_s(x \Rightarrow \overline{d_1})]], \mu)$
\vspace{-7pt}
\begin{align*}
&= \varnothing \setminus pointsto(\overline{d_1}, \mu) & (\textsc{pointsto-data}, \textsc{pointsto-empty})\\
&= \varnothing
\end{align*}
The authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Field}:}}{Subcase \textsc{E-Field}:}}
$e = l.f$, $e' = l_1$, and $E[l.f]~|~\mu \longrightarrow E[l_1]~|~\mu$.

Since object fields are private, only the caller can access its own fields. Thus, let $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$, such that $E'[l.m(l') \rhd E''[l.f]]~|~\mu \longrightarrow E'[l.m(l') \rhd E''[l_1]]~|~\mu$, where $\forall l_0.m_0(l_0') \rhd E''' \in E''$, $l_0 \mapsto \{ x \Rightarrow \overline{d_0}\}_{\keywadj{pure}} \in \mu$.

This implies that $l.m'(l'') \rhd E''' \not\in E''[e]$. Then we get

\noindent$auth(l, E'[l.m(l') \rhd E''[l_1]], \mu) \setminus auth(l, E'[l.m(l') \rhd E''[l.f]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \setminus pointsto(l.f, \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu) \setminus pointsto(E_0[l], \mu)\\
&= pointsto(l_1, \mu) \setminus \{ l \} \cup pointsto(subexps(E_0), \mu) & (\textsc{pointsto-principal})\\
&= auth_{store}(l, \mu) \cup pointsto(l_1, \mu) \setminus auth_{store}(l, \mu) \cup \{ l \} \cup pointsto(subexps(E_0), \mu)
\end{align*}
By \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu) \supseteq pointsto(l_1, \mu)$ and $auth_{store}(l, \mu) \cup pointsto(l_1, \mu) = auth_{store}(l, \mu)$. Therefore,

\noindent$auth(l, E'[l.m(l') \rhd E''[l_1]], \mu) \setminus auth(l, E'[l.m(l') \rhd E''[l.f]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) \cup \{ l \} \cup pointsto(subexps(E_0), \mu)\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.


\end{proof}


\newpage
\begin{lemma}
For an expressions of the form $l.m(l') \rhd E[e]$, such that $E$ contains no method call stack frames,
\[
auth(l, l.m(l') \rhd E[e], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(e, \mu).
\]
\end{lemma}

\begin{proof} $auth(l, l.m(l') \rhd E[e], \mu)$

\vspace{-17pt}

\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, l.m(l') \rhd E[e], \mu) & (\textsc{auth-config})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.m(l') \rhd E[e], \mu) & (\textsc{auth-store})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E[e], \mu) \cup auth_{stack}(l, E[e], \mu) & (\textsc{auth-stack})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E[e], \mu) & (\textsc{auth-stack-nocall})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(e, \mu) & (\textsc{pointsto-context-exp})
\end{align*}\qed

\end{proof}


\begin{lemma}
For any two expressions $e$ and $e'$, such that
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $lookupCaller(e) = l$, and
\item in a broader context, $l.m(l') \rhd E[e]~|~\mu \longrightarrow l.m(l') \rhd E[e']~|~\mu'$,
\end{enumerate}
$auth(l, l.m(l') \rhd E[e], \mu)$ and $auth(l, l.m(l') \rhd E[e'], \mu')$ differ only by the values of $pointsto(e, \mu)$ and $pointsto(e', \mu')$.
\end{lemma}

\begin{proof} By Lemma 4, in the initial state, we have
\[
auth(l, l.m(l') \rhd E[e], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(e, \mu)
\]
and in the final state, we have
\[
auth(l, l.m(l') \rhd E[e'], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup pointsto(e', \mu')
\]

Since we are considering small-step semantics, within this evaluation step, there were no changes to $l$, $\overline{d}$ and $E$, and thus $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$ and $pointsto(E, \mu) = pointsto(E, \mu')$. Therefore, $auth(l, l.m(l') \rhd E[e'], \mu')$ differ only by the values of $pointsto(e, \mu)$ and $pointsto(e', \mu')$. \qed

\end{proof}

\newpage
\begin{lemma}
If 
\mbox{$l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e]]~|~\mu \longrightarrow l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e']]~|~\mu'$}, where there are no method call stack frames in $E$ and $E'$, then $l$'s authority does not change.
%\begin{itemize}
%\item $l_2$'s authority may change
%\item $l$'s authority does not change (regardless of whether $l_2$'s authority changes).
%\end{itemize}
\end{lemma}

\begin{proof} In the initial state, we have:

\noindent$auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup pointsto(E[l_2.m_2(l_3) \rhd E'[e]], \mu) \cup auth_{stack}(l, E[l_2.m_2(l_3) \rhd E'[e]], \mu) & (\textsc{auth-stack})\\
&= auth_{store}(l, \mu) \cup pointsto(E[l_2.m_2(l_3) \rhd E'[e]], \mu) & (\textsc{auth-stack-nocall})
\end{align*}
There are two possibilities depending on whether $l_2$ is a principal or not:

\noindent$auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e']], \mu)$
\vspace{-7pt}
\[
%    auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e'], \mu') 
= 
\begin{cases}
    auth_{store}(l, \mu) \cup \{ l_2 \} \bigcup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-principal})\\
    auth_{store}(l, \mu) \cup pointsto(l_3, \mu) \bigcup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-data})
\end{cases}
\]Similarly, in the final state, we have:

\noindent$auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e']], \mu')$
\vspace{-7pt}
\[
%    auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e'], \mu') 
= 
\begin{cases}
    auth_{store}(l, \mu') \cup \{ l_2 \} \bigcup pointsto(subexps(E), \mu') & (\textsc{pointsto-call-principal})\\
    auth_{store}(l, \mu') \cup pointsto(l_3, \mu') \bigcup pointsto(subexps(E), \mu') & (\textsc{pointsto-call-data})
\end{cases}
\]
Since we are considering small-step semantics, there were no changes to $l$, $l_3$, and $E$, and $pointsto(l, \mu') = pointsto(l, \mu)$, $pointsto(l_3, \mu') = pointsto(l_3, \mu)$, and $\bigcup pointsto(subexps(E), \mu') = \bigcup pointsto(subexps(E), \mu)$. Thus, $l$'s authority does not change, and the lemma holds.\qed

\end{proof}

\begin{lemma} If 
\mbox{$E[l.m(l') \rhd E'[e]]~|~\mu \longrightarrow E[l.m(l') \rhd E'[e']]~|~\mu'$}, where there are no method call stack frames in $E'$, then for any $l''$, such that $l''.m'(l''') \in E$, $l''$'s authority does not change.
\end{lemma}

\begin{proof}
Proof is by inductively applying Lemma 6 to the method call stack frames in $E$ starting from the right most one (closest to $l.m(l') \rhd E'[e]$).\qed
\end{proof}


\newpage

\begin{theorem}[Authority Safety {[Including pure objects]}] If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_{\keywadj{stateful}} \in \mu'$,
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$, and
\item $auth(l, e', \mu') \setminus auth(l, e, \mu) \supseteq \{ l_1 \}$,
\end{enumerate}
then one of the following must be true:
\begin{itemize}
\item \textbf{Object creation:}

$e = E[l.m(l_2) \rhd E'[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d}_1)]]$, $e' = E[l.m(l_2) \rhd E'[l_1]]$, where
\begin{enumerate}
\item $\nexists l_0$, such that $l_0 \mapsto \{ x \Rightarrow \overline{d_0}\}_{\keywadj{stateful}}$ and $l_0.m_0(l_0') \rhd E'' \in E'$, and
\item if $l \mapsto \{ x \Rightarrow \overline{d}\}_{\keywadj{stateful}}$, $\nexists l_0$, such that $l_0.m_0(l_0') \rhd E'' \in E$ and $auth(l_0, e', \mu') \setminus auth(l_0, e, \mu) = \{ l_1 \}$
\end{enumerate}

\item \textbf{Method call:}

$e = E[l.m(l_1)]$, $e' = E[l.m(l_1) \rhd [l_1/y][l/x]e'']$

\item \textbf{Method return:}

$e = E[l.m(l_2) \rhd E'[l_3.m'(l_4) \rhd l_1]]$, $e' = E[l.m(l_2) \rhd E'[l_1]]$, where
\begin{enumerate}
\item $\nexists l_0$, such that $l_0 \mapsto \{ x \Rightarrow \overline{d_0}\}_{\keywadj{stateful}}$ and $l_0.m'(l_0') \rhd E'' \in E'$, and
\item if $l \mapsto \{ x \Rightarrow \overline{d}\}_{\keywadj{stateful}}$, $\nexists l_0$, such that $l_0.m'(l_0') \rhd E'' \in E$ and $auth(l_0, e', \mu') \setminus auth(l_0, e, \mu) = \{ l_1 \}$
\end{enumerate}
\end{itemize}

\end{theorem}


\begin{theorem}[Authority Safety (Alternative)] If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$,
\item $l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_{\keywadj{stateful}} \in \mu'$,
\item $\{ l_1 \} \not\in auth(l, e, \mu)$, and
\item $\{ l_1 \} \in auth(l, e', \mu')$,
\end{enumerate}
then one of the following must be true:
\begin{enumerate}
\item \textbf{Object creation:}

$e = E[l.m(l_2) \rhd E'[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d}_1)]]$, $e' = E[l.m(l_2) \rhd E'[l_1]]$, where $E'$ does not contain any method call stack frames

\item \textbf{Method call:}

$e = E[l.m(l_1)]$, $e' = E[l.m(l_1) \rhd [l_1/y][l/x]e'']$

\item \textbf{Method return:}

$e = E[l.m(l_2) \rhd E'[l_3.m'(l_4) \rhd l_1]]$, $e' = E[l.m(l_2) \rhd E'[l_1]]$, where $E'$ does not contain any method call stack frames
\end{enumerate}

\end{theorem}

\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy 

\noindent\fbox{\parbox{\widthof{Case \textsc{E-Congruence}:}}{Case \textsc{E-Congruence}:}} The changes in authority when $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$ depend on what expressions are in $e~|~\mu \longrightarrow e'~|~\mu'$. Let us consider all possible $e$ and $e'$.\\

\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-New}:}}{Subcase \textsc{E-New}:}}
$e = E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]$; $e' = E[l_1]$; and $\mu' = \mu, l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_s$. There are two possibilities: either the evaluation context is empty, i.e. $E = [~]$, or not, i.e. $E \not= [~]$.\\

\noindent\textit{\mbox{\underline{Case $E = [~]$}}:} If the evaluation context is empty, ...\\
%Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$, and accordingly, there is no principal whose authority can change on this evaluation step. Thus, the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= [~]$}}:} If the evaluation context is not empty, then, by Lemma 7, only the authority of the caller in the closest method call stack frame can change and of no other caller in $E$. Then we need to consider
%
%Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: 
\mbox{$l.m(l_2) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]~|~\mu \longrightarrow l.m(l_2) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority in the two states. In the initial state, we have:

\noindent$auth(l, l.m(l_2) \rhd E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}_1), \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\overline{d}_1, \mu) & (\textsc{pointsto-new})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup pointsto(l_1, \mu') & (Lemma~4)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{\underline{Case $l_1$ is a principal:}}
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup \{ l_1 \} & (\textsc{pointsto-principal})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$. Thus, $\{ l_1 \} \not\in auth(l, e, \mu)$ and $\{ l_1 \} \in auth(l, e', \mu')$, which is in compliance with the \textbf{\textit{object creation}} case, and the theorem holds.\\

\noindent\textit{\underline{Case $l_1$ is pure:}}
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') & (\textsc{pointsto-data})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, $\overline{d}_1$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$. Thus, there is no gain in $l_1$'s authority, and the theorem holds.\\\\
...

\end{proof}

\newpage
\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy 

\noindent\fbox{\parbox{\widthof{Case \textsc{E-New}:}}{Case \textsc{E-New}:}}
$e = E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]$; $e' = E[l_1]$; and $\mu' = \mu, l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_s$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$, and accordingly, there is no principal whose authority can change on this evaluation step. Thus, the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m(l_2) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]~|~\mu \longrightarrow l.m(l_2) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority in the two states. In the initial state, we have:

\noindent$auth(l, l.m(l_2) \rhd E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}_1), \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\overline{d}_1, \mu) & (\textsc{pointsto-new})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup pointsto(l_1, \mu') & (Lemma~4)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{\underline{Case $l_1$ is a principal:}}
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup \{ l_1 \} & (\textsc{pointsto-principal})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$. Thus, $\{ l_1 \} \not\in auth(l, e, \mu)$ and $\{ l_1 \} \in auth(l, e', \mu')$, which is in compliance with the \textbf{\textit{object creation}} case, and the theorem holds.\\

\noindent\textit{\underline{Case $l_1$ is pure:}}
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') & (\textsc{pointsto-data})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, $\overline{d}_1$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$. Thus, there is no gain in $l_1$'s authority, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Method}:}}{Case \textsc{E-Method}:}}
$e = E[l_1.m(l_2)]$, $e' = E[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'']$, and $\mu' = \mu$. From the premise, we get $l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{def} m(y : \tau_1) : \tau_2 = e'' \in \overline{d}$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$. The only principal whose authority can change on this step is $l_1$. Let us consider $l_1$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2), \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2), \mu) & (\textsc{auth-config})\\
%&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.m(l_2), \mu) & (\textsc{auth-store})\\
&= auth_{store}(l_1, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e'', \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e'', \mu) & (\textsc{auth-config})\\
%&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e'', \mu) & (\textsc{auth-store})\\
&= auth_{store}(l_1, \mu) \cup pointsto([l_2/y][l_1/x]e'', \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e'', \mu) & (\textsc{auth-stack})\\
&\subseteq auth_{store}(l_1, \mu) \cup pointsto(l_2, \mu) \cup pointsto(e'', \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e'', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
Since we are considering small-step semantics, there is no method call stack frame in $e''$ and, by \textsc{auth-stack-nocall}, $auth_{stack}(l_1, [l_2/y][l_1/x]e'', \mu) = \varnothing$. By \textsc{auth-store}, \textsc{pointsto-decls} and \textsc{pointsto-def}, $pointsto(e'', \mu) \in auth_{store}(l_1, \mu)$. Therefore, we get:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e'', \mu) \subseteq auth_{store}(l_1, \mu) \cup pointsto(l_2, \mu)
\end{align*}
Here three cases are possible: 1) If $l_2$ is a pure object, $l_1$'s authority does not increase, and the theorem holds. 2) If $l_2$ is a principal, but it is not used in $e''$, $l_1$'s authority does not increase, and the theorem holds. 3) If $l_2$ is a principal, and it is used in $e''$, $l_1$'s authority increases by $\{ l_2 \}$ (\textsc{pointsto-principal}), which is in compliance with the \textbf{\textit{method call}} case, and the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l_1.m(l_2)]~|~\mu \longrightarrow l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'']~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the initial case, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2), \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'', \mu) & (Lemma~4)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.\\

\noindent\textit{\underline{Case $l_1$ is a principal:}}

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup \{ l_1 \} & (\textsc{pointsto-call-principal})
\end{align*}
Thus, $l$'s authority does not change, and the theorem holds.\\

\noindent\textit{\underline{Case $l_1$ is pure:}} 

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto([l_2/y] [l_1/x] e'', \mu) & (\textsc{pointsto-call-data})\\
&\subseteq pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) & (\textsc{pointsto-otherexp}) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu) \cup pointsto(e'', \mu)
\end{align*}
Since $l_1$ is pure, by \textsc{pointsto-data}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, \mbox{$pointsto(l_1, \mu) = \varnothing$}, $pointsto(e'', \mu) = \varnothing$ and
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) \subseteq pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_2, \mu)
\]
Thus, $l$'s authority does not increase, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Field}:}}{Case \textsc{E-Field}:}}
$e = E[l.f]$, $e' = E[l_1]$, and $\mu' = \mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{var} f : \tau = l_1 \in \overline{d}$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$. The only principal whose authority can change on this step is $l$. Let us consider $l$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l, l.f, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l.f, \mu) & (\textsc{auth-config})\\
%&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.f, \mu) & (\textsc{auth-store})\\
&= auth_{store}(l, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l_1, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l_1, \mu) & (\textsc{auth-config})\\
%&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l_1, \mu) & (\textsc{auth-store})\\
&= auth_{store}(l, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
Thus, $l$'s authority does not change, and the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Since object fields are private and thus accessible only within the object, $lookupCaller(E) = l$, i.e. for this step to execute, the caller must be the object whose field is being evaluated. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m(l_0) \rhd E'[l.f]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the initial state, we have:

\noindent$auth(l, l.m(l_0) \rhd E'[l.f], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l.f, \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l.m(l_0) \rhd E'[l_1], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) & (Lemma~4)
\end{align*}
As $\keyw{var} f : \tau = l_1 \in \overline{d}$, by \textsc{pointsto-decls} and \textsc{pointsto-varl}, $pointsto(l_1, \mu) \subset pointsto(\overline{d}, \mu)$ and
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu)
\]
Thus, $l$'s authority does not change, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Assign}:}}{Case \textsc{E-Assign}:}}
$e = E[l.f = l_1]$, $e' = E[l_1]$, and $\mu' = [l \mapsto \{ x \Rightarrow \overline{d}' \}_{s}/l \mapsto \{ x \Rightarrow \overline{d} \}_{s}]\mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$, $\keyw{var} f:\tau = l_2 \in \overline{d}$, and $\overline{d}' = [\keyw{var} f : \tau = l_1/\keyw{var} f:\tau = l_2]\overline{d}$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$. The only principal whose authority can change on this step is $l$. Let us consider $l$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l, l.f = l_1, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l.f = l_1, \mu) & (\textsc{auth-config})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.f = l_1, \mu) & (\textsc{auth-store})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l_1, \mu') &= auth_{store}(l, \mu') \cup auth_{stack}(l, l_1, \mu') & (\textsc{auth-config})\\
&= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup auth_{stack}(l, l_1, \mu') & (\textsc{auth-store})\\
&= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') & (\textsc{auth-stack-nocall})
\end{align*}
By \textsc{pointsto-principal} and \textsc{pointsto-data}, $pointsto(l, \mu') = pointsto(l, \mu)$. \todo{...} Thus, $l$'s authority does not change, and the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Since object fields are private and thus accessible only within the object, $lookupCaller(E) = l$, , i.e. for this step to execute, the caller must be the object whose field is being evaluated. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l.f = l_1]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the initial state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[l.f = l_1], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l.f = l_1, \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}', \mu') \cup pointsto(E', \mu') \cup  pointsto(l_1, \mu') & (Lemma~4)
\end{align*}
Since we are considering small-step semantics, within this evaluation step, no other assignment could have taken place. Therefore, there were no changes to $l$, $l_1$, or $E'$, and $pointsto(l, \mu') = pointsto(l, \mu)$, $pointsto(l_1, \mu') = pointsto(l_1, \mu)$, and$pointsto(E', \mu) = pointsto(E', \mu')$. \todo{...} Thus, $l$'s authority does not change, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Bind}:}}{Case \textsc{E-Bind}:}}
$e = E[\keyw{bind} x = l_1~\keyw{in} e'']$, $e' = E[[l_1/x] e'']$, and $\mu' = \mu$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$, and accordingly, there is no principal whose authority can change on this evaluation step. Thus, the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e'']~|~\mu \longrightarrow l.m'(l_0) \rhd E'[[l_1/x] e'']~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the initial state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\keyw{bind} x = l_1~\keyw{in} e'', \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(e'', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[[l_1/x] e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto([l_1/x] e'', \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(e'', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
Thus, $l$'s authority does not change, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-StackFrame}:}}{Case \textsc{E-StackFrame}:}}
$e = E[l_1.m(l_2) \rhd l_3]$, $e' = E[l_3]$, and $\mu' = \mu$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$. The only principal whose authority can change on this step is $l_1$. Let us consider $l_1$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd l_3, \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd l_3, \mu) & (\textsc{auth-config})\\
%&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.f = l_1, \mu) & (\textsc{auth-store})\\
&= auth_{store}(l_1, \mu) \cup pointsto(l_3, \mu) \cup auth_{stack}(l_1, l_3, \mu) & (\textsc{auth-stack})\\
&= auth_{store}(l_1, \mu) \cup pointsto(l_3, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l_1, l_3, \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_3, \mu) & (\textsc{auth-config})\\
%&= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup auth_{stack}(l, l_1, \mu') & (\textsc{auth-store})\\
&= auth_{store}(l_1, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
Thus, $l_1$'s authority does not increase, and the theorem holds.\\\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3]~|~\mu \longrightarrow l.m'(l_0) \rhd E'[l_3]~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the final state, we have:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_3], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_3, \mu) & (Lemma~4)
\end{align*}
In the initial state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2) \rhd l_3, \mu) & (Lemma~4)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{\underline{Case $l_1$ is a principal:}}

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup \{ l_1 \} & (\textsc{pointsto-call-principal})
\end{align*}
Thus, $l$'s authority increases by $l_3$, which is in compliance with the \textit{\textbf{method return}} case, and the theorem holds.\\

\noindent\textit{\underline{Case $l_1$ is pure:}}

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_3, \mu) & (\textsc{pointsto-call-data})
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\qed

\end{proof}


\newpage

\begin{proof}

The program begins with a creation of an object and an empty stack. When the first object is created, since there are no other objects in the program, no object can gain authority. After the first object is created, authority of objects in the program can change. There are three actions that can be done to an object: field access (E-Field), field assignment (E-Assign), and method call (E-Method). Let us consider how each of them changes the authority of the object. (This can be generalized to any object in the program.)\\

\noindent\underline{\textit{Case \textsc{E-Field}:}}
$l.f~|~\mu \rightarrow l_1~|~\mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{var} f : \tau = l_1 \in \overline{d}$.

\noindent Let us consider $l$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l, l.f, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l.f, \mu) & (\textsc{auth-config})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.f, \mu) & (\textsc{auth-store})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l_1, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l_1, \mu) & (\textsc{auth-config})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l_1, \mu) & (\textsc{auth-store})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
Thus there is no change to $l$'s authority, and the theorem holds.\\

\noindent\underline{\textit{Case \textsc{E-Assign}:}}
$l_1.f = l_2~|~\mu \longrightarrow l_2~|~\mu'$. From the premise, we get $l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$, $\keyw{var} f : \tau = l \in \overline{d}$, $\overline{d}' = [\keyw{var} f : \tau = l_2/\keyw{var} f : \tau = l]\overline{d}$, and $\mu' = [l_1 \mapsto \{ x \Rightarrow \overline{d}' \}_{s}/l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s}]\mu$. 

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_1, l_1.f = l_2, \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.f = l_2, \mu) & (\textsc{auth-config})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.f = l_2, \mu) & (\textsc{auth-store})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l_1, l_2, \mu') &= auth_{store}(l_1, \mu') \cup auth_{stack}(l_1, l_2, \mu') & (\textsc{auth-config})\\
&= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') \cup auth_{stack}(l_1, l_2, \mu') & (\textsc{auth-store})\\
&= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') & (\textsc{auth-stack-nocall})
\end{align*}
By \textsc{pointsto-principal} and \textsc{pointsto-data}, $pointsto(l_1, \mu) = pointsto(l_1, \mu')$. However,\\ $pointsto(\overline{d}, \mu') \setminus pointsto(\overline{d}, \mu) \subseteq pointsto(l_2, \mu')$. Thus if $l_2$ is a pure object, the authority of $l_1$ does not increase; if $l_2$ is a principal, $l_1$ gains authority over $l_2$, which is in accordance with case 1 of the theorem. In both cases, the theorem holds.\\

\noindent\underline{\textit{Case \textsc{E-Method}:}}
$l_1.m(l_2)~|~\mu \rightarrow l_1.m(l_2) \rhd [l_2/y][l_1/x]e~|~\mu$. From the premise, we get $l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{def} m(y : \tau_1) : \tau_2 = e \in \overline{d}$.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2), \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2), \mu) & (\textsc{auth-config})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.m(l_2), \mu) & (\textsc{auth-store})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e, \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e, \mu) & (\textsc{auth-config})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e, \mu) & (\textsc{auth-store})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack})\\
&\cup pointsto([l_2/y][l_1/x]e, \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e, \mu)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{pointsto-otherexp})\\
&\cup pointsto(l_2, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e, \mu)
\end{align*}
Here the authority of the object increases by $pointsto(l_2, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e, \mu)$, which depends on the concrete values of $l_2$ and $e$. If $l_2$ is a principal, the authority of $l_1$ increases (at least) by $\{ l_2 \}$, which is in accordance with case 2 of the theorem. The rest of the authority increase depends on $e$. Let us now consider what expressions $e$ can contain and how those expressions change the authority of $l_1$.\\

\noindent\underline{\textit{Subcase \textsc{E-New}:}}
$l_1.m(l_2) \rhd E[\keywadj{new}_s(x \Rightarrow \overline{d}_3)]~|~\mu \longrightarrow l_1.m(l_2) \rhd E[l_3]~|~\mu'$, where $E$ does not contain any method call stack frames.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[\keywadj{new}_s(x \Rightarrow \overline{d}_3)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}_3), \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(\overline{d}_3, \mu) & (\textsc{pointsto-new})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_3], \mu') &= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup pointsto(l_3, \mu') & (Lemma~4)
\end{align*}
Depending on whether $l_3$ is a principal, there are two possibilities.

\noindent\textit{Case $l_3$ is a principal:}
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_3], \mu') &= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup \{ l_3 \} & (\textsc{pointsto-principal})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l_1$, $\overline{d}$, or $E$, and $pointsto(l_1, \mu) = pointsto(l_1, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, and $pointsto(E, \mu) = pointsto(E, \mu')$. Thus the caller object $l_1$ gained authority over the newly created principal in accordance with case 3 of the theorem.

\noindent\textit{Case $l_3$ is pure:}
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_3], \mu') &= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') & (\textsc{pointsto-data})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l_1$, $\overline{d}$, or $E$, and $pointsto(l_1, \mu) = pointsto(l_1, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, and $pointsto(E, \mu) = pointsto(E, \mu')$. Thus there was no gain in $l_1$'s authority, and the theorem holds.\\

\noindent\underline{\textit{Subcase \textsc{E-Method}:}}
$l_1.m(l_2) \rhd E[l_3.m'(l_4)]~|~\mu \longrightarrow l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e']~|~\mu$, where $E$ does not contain any method call stack frames. From the premise, we get $l_3 \mapsto \{ x \Rightarrow \overline{d}_3 \}_{s} \in \mu$ and $\keyw{def} m'(y : \tau_1) : \tau_2 = e' \in \overline{d}_3$.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3.m'(l_4), \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3, \mu) \cup pointsto(l_4, \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e', \mu) & (Lemma~4)
\end{align*}
Depending on whether $l_3$ is a principal, there are two possibilities.

\noindent\underline{\textit{Case $l_3$ is a principal:}} In the initial state:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_3 \} \cup pointsto(l_4, \mu) & (\textsc{pointsto-principal})
\end{align*}
In the final state,

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_3 \} & (\textsc{pointsto-call-principal})
\end{align*}
Thus $l_1$ does not gain authority, and the theorem holds.

\noindent\underline{\textit{Case $l_3$ is pure:}} In the initial state:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_4, \mu) & (\textsc{pointsto-data})
\end{align*}
In the final state,

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto([l_4/y] [l_3/x] e', \mu) & (\textsc{pointsto-call-data})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) & (\textsc{pointsto-otherexp})\\
&\cup pointsto(l_4, \mu) \cup pointsto(l_3, \mu) \cup pointsto(e', \mu)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_4, \mu) \cup pointsto(e', \mu) & (\textsc{pointsto-data})
\end{align*}
By definition of a pure object, $pointsto(e', \mu) = \varnothing$ and

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_4, \mu)
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.\\

\noindent\underline{\textit{Subcase \textsc{E-Field}:}}
Since fields are private, it must be $l_1$ accessing the field, and this subcase is equivalent to Case E-Field above.\\

\noindent\underline{\textit{Subcase \textsc{E-Assign}:}}
Since fields are private, it must be $l_1$ accessing the field, and this subcase is equivalent to Case E-Assign above.\\

\noindent\underline{\textit{Subcase \textsc{E-Bind}:}}
$l_1.m(l_2) \rhd E[\keyw{bind} x = l_3~\keyw{in} e']~|~\mu \longrightarrow l_1.m(l_2) \rhd E[[l_3/x] e']~|~\mu$, where $E$ does not contain any method call stack frames.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[\keyw{bind} x = l_3~\keyw{in} e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(\keyw{bind} x = l_3~\keyw{in} e', \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3, \mu) \cup pointsto(e', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[[l_3/x] e'], \mu')$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto([l_3/x] e', \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3, \mu) \cup pointsto(e', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.\\

\noindent\underline{\textit{Subcase \textsc{E-StackFrame}:}}
$l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5]~|~\mu \longrightarrow l_1.m(l_2) \rhd E[l_5]~|~\mu$, where $E$ does not contain any method call stack frames.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3.m'(l_4) \rhd l_5, \mu) & (Lemma~4)
\end{align*}
In the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_5, \mu) & (Lemma~4)
\end{align*}
Depending on whether $l_3$ and $l_5$ are principals, there are four possibilities.

\noindent\underline{\textit{Case $l_3$ and $l_5$ are principals:}}
In the initial state, we have:\\
\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_3 \} & (\textsc{pointsto-call-principal})
\end{align*}
and in the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_5 \} & (\textsc{pointsto-principal})
\end{align*}
Thus $l_1$ gains authority over $l_5$, which is in accordance with case 4 of the theorem, and the theorem holds.

\noindent\underline{\textit{Case $l_3$ is a principal and $l_5$ is pure:}}
In the initial state, we have:\\
\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_3 \} & (\textsc{pointsto-call-principal})
\end{align*}
and in the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) & (\textsc{pointsto-data})
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_3$ is pure and $l_5$ is a principal:}}
In the initial state, we have:\\
\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_5, \mu) & (\textsc{pointsto-call-data})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_5 \} & (\textsc{pointsto-principal})
\end{align*}
and in the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_5 \} & (\textsc{pointsto-principal})
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_3$ and $l_5$ are pure:}}
In the initial state, we have:\\
\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_5, \mu) & (\textsc{pointsto-call-data})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) & (\textsc{pointsto-data})
\end{align*}
and in the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) & (\textsc{pointsto-data})
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.\\

\noindent Therefore, the theorem holds for all cases.\qed

\end{proof}

\newpage

\begin{theorem}[Authority Safety] If
\begin{enumerate}
\item $\mu : \Sigma$,
\item $\varnothing~|~\Sigma \vdash e : \tau$, {\emph{~~~~~~~~~~~~[The program $e$ is well-formed]}}
\item $e~|~\mu \longrightarrow e'~|~\mu'$, and
\item for some principal $l$, $auth(l, e', \mu') \supset auth(l, e, \mu)$,
\end{enumerate}
then one of the following must hold:
\begin{itemize}
  \item \textbf{Object creation:}
  \begin{enumerate}
  \item $e = E[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d}_1)]$, $e' = E[l_1]$,
  \item $lookupCaller(E) = l$, {\emph{~~~~~~~~~~~~~~~~~~~~~~~[The creator was $l$]}}
  \item $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_1 \}$.\\
  \end{enumerate}
  \item \textbf{Method call:}
  \begin{enumerate}
  \item $e = E[l.m(l_1)]$, $e' = E[l.m(l_1) \rhd [l_1/y][l/x]e'']$,
  \item $pointsto(l_1,\mu) = \{ l_1 \} \cup pointsto(\overline{d}_1, \mu)$, {\emph{~~~~~~~~~~[The argument $l_1$ is a principal]}}
  \item $\{ l_1 \} \not\in auth(l, e, \mu)$,
  \item $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_1 \}$.\\
  \end{enumerate}
  \item \textbf{Method return:}
  \begin{enumerate}
  \item $e = E[l_1.m(l_2) \rhd l_3]$, $e' = E[l_3]$,
  \item $pointsto(l_3,\mu) = \{ l_3 \} \cup pointsto(\overline{d}_3, \mu)$, {\emph{~~~~~~~~[The returned $l_3$ is a principal]}}
  \item $lookupCaller(E) = l$, {\emph{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[The caller was $l$]}}
  \item $\{ l_3 \} \not\in auth(l, e, \mu)$,
  \item $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_3 \}$.\\
  \end{enumerate}
\end{itemize}

\end{theorem}

(The Authority Safety theorem follows the definition in Maffeis et al.~\cite{Maffeis:2010}.)

\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy 

\noindent\fbox{\parbox{\widthof{Case \textsc{E-New}:}}{Case \textsc{E-New}:}}
$e = E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]$; $e' = E[l_1]$; and $\mu' = \mu, l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_s$. Since a program starts with a $\keywadj{new}_s$ expression, there are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{Case $E = \varnothing$}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$, and accordingly, there is no principal whose authority can change on this evaluation step. Thus, the theorem holds.\\

\noindent\textit{\mbox{Case $E \not= \varnothing$}:} Without loss of generality, let $lookupCaller(E) = l$, such that $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m(l_0) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\[
auth(l, l.m(l_0) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}_1), \mu)\]
and by \textsc{pointsto-new},
\[
auth(l, l.m(l_0) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\overline{d}_1, \mu)
\]
By Lemma 4, in the final state, we have:
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup pointsto(l_1, \mu').
\]
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{Case $l_1$ is a principal:} By \textsc{pointsto-principal}, we get:
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup \{ l_1 \} \cup pointsto(\overline{d}_1, \mu')
\]
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}_1$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$.\\

\noindent Thus, $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_1 \}$ in compliance with the \textbf{\textit{object creation}} case of the theorem.\\

\noindent\textit{Case $l_1$ is pure:} By \textsc{pointsto-data}, we get:
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup pointsto(\overline{d}_1, \mu')
\]
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, $\overline{d}_1$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$.\\

\noindent Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Method}:}}{Case \textsc{E-Method}:}}
$e = E[l_1.m(l_2)]$, $e' = E[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'']$, and $\mu' = \mu$. From the premise, we get $l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_{s} \in \mu$ and $\keyw{def} m(y : \tau_1) : \tau_2 = e'' \in \overline{d}_1$. Without loss of generality, let $lookupCaller(E) = l$, such that $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l_1.m(l_2)]~|~\mu \longrightarrow l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'']~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2)], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2), \mu)\]
and by \textsc{pointsto-otherexp},
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2)], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu)
\]
By Lemma 4, in the final state, we have:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'', \mu)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.\\

\noindent\textit{Case $l_1$ is a principal:} By \textsc{pointsto-call-principal}, we get:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto([l_2/y] [l_1/x] e'', \mu)
\end{align*}
and by \textsc{pointsto-otherexp},
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu) \cup pointsto(e'', \mu)
\end{align*}
Here $e''$ is the body of $l_1$'s method, then by \textsc{pointsto-principal}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $pointsto(e'', \mu) \subset pointsto(l_1, \mu)$ and
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu)
\end{align*}
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\

\noindent\textit{Case $l_1$ is pure:} By \textsc{pointsto-call-data}, we get:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto([l_2/y] [l_1/x] e'', \mu)
\end{align*}
and by \textsc{pointsto-otherexp},
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu) \cup pointsto(e'', \mu)
\end{align*}
Here $e''$ is the body of $l_1$'s method, then by \textsc{pointsto-principal}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $pointsto(e'', \mu) \subseteq pointsto(l_1, \mu)$ and
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu)
\end{align*}
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Field}:}}{Case \textsc{E-Field}:}}
$e = E[l.f]$, $e' = E[l_1]$, and $\mu' = \mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{var} f : \tau = l_1 \in \overline{d}$. Since object fields are private and thus accessible only within the object, $lookupCaller(E) = l$, i.e. for this step to execute, the caller must be the object whose field is being evaluated. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m(l_0) \rhd E'[l.f]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\[
auth(l, l.m(l_0) \rhd E'[l.f], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l.f, \mu)
\]
and by \textsc{pointsto-otherexp},
\[
auth(l, l.m(l_0) \rhd E'[l.f], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu)
\]
By Lemma 4, in the final state, we have:
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu)
\]
As $\keyw{var} f : \tau = l_1 \in \overline{d}$, by \textsc{pointsto-decls} and \textsc{pointsto-varl}, $pointsto(l_1, \mu) \subset pointsto(\overline{d}, \mu)$ and
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu)
\]
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Assign}:}}{Case \textsc{E-Assign}:}}
$e = E[l.f = l_1]$, $e' = E[l_1]$, and $\mu' = [l \mapsto \{ x \Rightarrow \overline{d}' \}_{s}/l \mapsto \{ x \Rightarrow \overline{d} \}_{s}]\mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$, $\keyw{var} f:\tau = l_2 \in \overline{d}$, and $\overline{d}' = [\keyw{var} f : \tau = l_1/\keyw{var} f:\tau = l_2]\overline{d}$. Since object fields are private and thus accessible only within the object, $lookupCaller(E) = l$, , i.e. for this step to execute, the caller must be the object whose field is being evaluated. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l.f = l_1]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l.f = l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l.f = l_1, \mu)\]
and by \textsc{pointsto-otherexp},
\[
auth(l, l.m'(l_0) \rhd E'[l.f = l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu)
\]
By Lemma 4, in the final state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l_1], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup  pointsto(l_1, \mu')
\]
The memory changed due to the value change of $l$'s field $f$ from $l_2$ to $l_1$. By \textsc{pointsto-principal}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $l$ already had authority over $l_1$ via the body of method $m()$. In addition, since we are considering small-step semantics, within this evaluation step, no other assignment could have taken place. Therefore, $pointsto(l, \mu') \subseteq pointsto(l, \mu)$. Furthermore, due to the latter reason, there were no changes to $\overline{d}_1$ or $E'$, and $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$ and $pointsto(E', \mu) = pointsto(E', \mu')$.\\

\noindent Thus, $auth(l, e', \mu') \subseteq auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Bind}:}}{Case \textsc{E-Bind}:}}
$e = E[\keyw{bind} x = l_1~\keyw{in} e'']$, $e' = E[[l_1/x] e'']$, and $\mu' = \mu$. Without loss of generality, let $lookupCaller(E) = l$, such that $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e'']~|~\mu \longrightarrow l.m'(l_0) \rhd E'[[l_1/x] e'']~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(\keyw{bind} x = l_1~\keyw{in} e'', \mu)
\end{align*}
and by \textsc{pointsto-otherexp},
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(e'', \mu)
\end{align*}
By Lemma 4, in the final state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[[l_1/x] e''], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto([l_1/x] e'', \mu)
\]
and by \textsc{pointsto-otherexp},
\[
auth(l, l.m'(l_0) \rhd E'[[l_1/x] e''], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(e'', \mu)
\]
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-StackFrame}:}}{Case \textsc{E-StackFrame}:}}
$e = E[l_1.m(l_2) \rhd l_3]$, $e' = E[l_3]$, and $\mu' = \mu$. Without loss of generality, let $lookupCaller(E) = l$, such that $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3]~|~\mu \longrightarrow l.m'(l_0) \rhd E'[l_3]~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the final state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l_3], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_3, \mu)
\]
By Lemma 4, in the initial state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2) \rhd l_3, \mu).
\]
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{Case $l_1$ is a principal:} By \textsc{pointsto-call-principal}, we get:
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(l_3, \mu)
\]
Thus, $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_3 \}$ in compliance with the theorem.\\

\noindent\textit{Case $l_1$ is pure:} By \textsc{pointsto-call-data}, we get:
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_3, \mu).
\]
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\

\end{proof}


\newpage

\begin{theorem}[Auxiliary]
For all $l$, such that
$E[l.m(l') \rhd E'[e]]~|~\mu \longrightarrow E[l.m(l') \rhd E'[e']]~|~\mu'$,
if
\begin{enumerate}
\item $\exists l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{stateful}} \in \mu'$, such that $pointsto(e', \mu') \setminus pointsto(e, \mu) = \{ l_0 \}$
\item $\forall l_1.m_1(l_1') \rhd E'' \in E'$, $l_1 \mapsto \{ x \Rightarrow \overline{d_1} \}_{\keywadj{pure}} \in \mu$
\end{enumerate}
then
$auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth(l, E[l.m(l') \rhd E'[e]], \mu) = \{ l_0 \}$.
\end{theorem}

\begin{proof}
The proof is by induction on the method call stack frames.\\

\noindent\textit{\underline{Base case:}} $l'.m'(l'') \rhd E_1 \not\in E$ and $l'.m'(l'') \rhd E_1 \not\in E'$. 

Let $auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth(l, E[l.m(l') \rhd E'[e]], \mu) \not= \{ l_0 \}$.

Consider $l$'s authority in the two states. In the initial state, we have:

\noindent$auth(l, E[l.m(l') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, E[l.m(l') \rhd E'[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup pointsto(E'[e], \mu) \cup auth_{stack}(l, E'[e], \mu) & (\textsc{auth-stack})\\
&= auth_{store}(l, \mu) \cup pointsto(E'[e], \mu) & (\textsc{auth-stack-nocall})\\
&= auth_{store}(l, \mu) \cup pointsto(e, \mu) \bigcup pointsto(subexps(E'), \mu) & (Lemma~8)
\end{align*}
Similarly, in the final state, we have:
\[
auth(l, E[l.m(l') \rhd E'[e']], \mu') = auth_{store}(l, \mu') \cup pointsto(e', \mu') \bigcup pointsto(subexps(E'), \mu')
\]
Since we are considering small-step semantics, there was no change to $l$ and $E'$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$ and $\bigcup pointsto(subexps(E'), \mu') = \bigcup pointsto(subexps(E'), \mu)$. Therefore,
\[
auth(l, E[l.m(l') \rhd E'[e']], \mu') = auth_{store}(l, \mu) \cup pointsto(e', \mu') \bigcup pointsto(subexps(E'), \mu)
\]
Then, we get
\[
auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth(l, E[l.m(l') \rhd E'[e]], \mu) = pointsto(e', \mu') \setminus pointsto(e, \mu) = \{ l_0 \}
\]
This contradicts our assumption, and thus the assumption is wrong and the theorem holds.\\

\noindent\textit{\underline{Inductive case:}} Let us enumerate all method callers preceding $e$ and $e'$ on the stack starting from the method caller closest to $e$ and $e'$ on the stack:
$E[l_i.m(l_i') \rhd E'[e]]~|~\mu \longrightarrow E[l_i.m(l_i') \rhd E'[e']]~|~\mu'$,
where $1 \leq i \leq n$.

Now consider $l_k$, such that
\[
E[l_k.m(l_k') \rhd E'[e]]~|~\mu \longrightarrow E[l_k.m(l_k') \rhd E'[e']]~|~\mu'
\]
where $1 \leq k \leq n$; for $i = 1 \dots k - 1$, $l_i.m_i(l_i') \rhd E'' \in E'$; and for $i = k + 1 \dots n$, $l_i.m_i(l_i') \rhd E'' \in E$. Then from the premise of the theorem, we have:

\begin{enumerate}
\item $\exists l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{stateful}}$, such that $pointsto(e', \mu') \setminus pointsto(e, \mu) = \{ l_0 \}$
\item for $i = 1 \dots k - 1$, $ l_i.m_i(l_i') \rhd E'' \in E'$, $l_i \mapsto \{ x \Rightarrow \overline{d_i} \}_{\keyw{pure}}$
\end{enumerate}

Let $auth(l_k, E[l_k.m(l_k') \rhd E'[e']], \mu') \setminus auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) \not= \{ l_0 \}$.

Consider $l_k$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) &= auth_{store}(l_k, \mu) \cup auth_{stack}(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) & (\textsc{auth-config})
\end{align*}
Without loss of generality, let $l_k.m(l_k') \rhd E'''$ be the leftmost method call stack frame where $l_k$'s method is called, i.e. let $l_k.m(l_k') \rhd E''' \not\in E$. Then we get:
\begin{align*}
auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) &= auth_{store}(l_k, \mu) \cup pointsto(E'[e], \mu) \cup auth_{stack}(l_k, E'[e], \mu) & (\textsc{auth-stack})
\end{align*}
If $l_k.m(l_k') \rhd E''' \in E'$, then if $pointsto(e, \mu) \in pointsto(E'[e], \mu)$, by Lemma 10, $pointsto(e, \mu) \in auth_{stack}(l_k, E'[e], \mu)$. Then, without loss of generality, assume $l_k.m(l_k') \rhd E''' \not\in E'$, and we get:
\begin{align*}
auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) &= auth_{store}(l_k, \mu) \cup pointsto(E'[e], \mu) & (\textsc{auth-stack-nocall})
\end{align*}
Unwinding $E'$, we have:

\noindent$auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l_k, \mu) \cup pointsto(E_k[l_{k-1}.m_{k-1}(l_{k-1}') \rhd E_{k-1}[l_{k-2}.m_{k-2}(l_{k-2}') \rhd \dots \rhd E_1[e]] \dots ], \mu) & (\textsc{auth-stack-nocall})
\end{align*}
where for $i = 1 \dots k$, $l'.m(l'') \rhd E'' \not\in E_i$.

Since for $i = 1 \dots k - 1$, $ l_i.m_i(l_i') \rhd E'' \in E'$, $l_i \mapsto \{ x \Rightarrow \overline{d_i} \}_{\keywadj{pure}}$,

\noindent$auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l_k, \mu) \bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) & (\textsc{pointsto-call-data}~\times~k)
\end{align*}
Similarly, in the final state, we have:
\begin{align*}
auth(l_k, E[l_k.m(l_k') \rhd E'[e']], \mu') &= auth_{store}(l_k, \mu') \bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu') \cup pointsto(e', \mu')
\end{align*}
Since we are considering small-step semantics, there was no change to $l$ and $E_i$s, and $auth_{store}(l_k, \mu') = auth_{store}(l_k, \mu)$ and $\bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu') = \bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu)$. Therefore,
\[
auth(l_k, E[l_k.m(l_k') \rhd E'[e']], \mu') = auth_{store}(l_k, \mu) \bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu) \cup pointsto(e', \mu')
\]
Then, we get
\[
auth(l_k, E[l_k.m(l_k') \rhd E'[e']], \mu') \setminus auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) = pointsto(e', \mu') \setminus pointsto(e, \mu) = \{ l_0 \}
\]
This contradicts our assumption, and thus the assumption is wrong and the theorem holds.\qed
\end{proof}

\begin{lemma}
If $l.m(l') \rhd E' \not\in E$, then $pointsto(E[e], \mu) = pointsto(e, \mu) \bigcup pointsto(subexps(E), \mu)$.
\end{lemma}

\begin{proof}
Proof is by induction on $e$: we consider all possible types of $e$ and apply the $pointsto(e, \mu)$ rules.
\end{proof}

\begin{lemma}
If for all $l.m(l') \rhd E' \in E$, $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{pure}}$, then $pointsto(e, \mu) \in pointsto(E[e], \mu)$.
\end{lemma}

\begin{proof}
Consider $pointsto(E[e], \mu)$, and because all method callers are pure, \textsc{pointsto-call-data} will be applied ending with $pointsto(e, \mu)$.
\end{proof}

\begin{lemma}
If $l.m(l') \rhd E' \in E$; for all method callers $l''$ preceding $l.m(l') \rhd E'$ on the stack, $l'' \mapsto \{ x \Rightarrow \overline{d''} \}_{\keywadj{pure}}$; and $pointsto(e, \mu) \in pointsto(E[e], \mu)$, then $pointsto(e, \mu) \in auth_{stack}(l, E[e], \mu)$.
\end{lemma}

\begin{proof}
Consider $auth_{stack}(l, E[e], \mu)$, apply \textsc{auth-stack}, then use Lemma 9.
\end{proof}



\bibliographystyle{plain}
\bibliography{bibtex}

\end{document}