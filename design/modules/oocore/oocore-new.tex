\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
 
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\textit{Case}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{
  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~#1}
  \fi
  \item
}

\begin{document}


\begin{lemma}
For an expressions of the form $l.m(l') \rhd E[e]$, such that $E$ contains no method call stack frames,
\[
auth(l, l.m(l') \rhd E[e], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(e, \mu).
\]
\end{lemma}

\begin{proof} $auth(l, l.m(l') \rhd E[e], \mu)$

\vspace{-17pt}

\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, l.m(l') \rhd E[e], \mu) & (\textsc{auth-config})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.m(l') \rhd E[e], \mu) & (\textsc{auth-store})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E[e], \mu) \cup auth_{stack}(l, E[e], \mu) & (\textsc{auth-stack})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E[e], \mu) & (\textsc{auth-stack-nocall})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(e, \mu) & (\textsc{pointsto-context-exp})
\end{align*}\qed

\end{proof}


\begin{lemma}
For any two expressions $e$ and $e'$, such that
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $lookupCaller(e) = l$, and
\item in a broader context, $l.m(l') \rhd E[e]~|~\mu \longrightarrow l.m(l') \rhd E[e']~|~\mu'$,
\end{enumerate}
$auth(l, l.m(l') \rhd E[e], \mu)$ and $auth(l, l.m(l') \rhd E[e'], \mu')$ differ only by the values of $pointsto(e, \mu)$ and $pointsto(e', \mu')$.
\end{lemma}

\begin{proof} By Lemma 4, in the initial state, we have
\[
auth(l, l.m(l') \rhd E[e], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(e, \mu)
\]
and in the final state, we have
\[
auth(l, l.m(l') \rhd E[e'], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup pointsto(e', \mu')
\]

Since we are considering small-step semantics, within this evaluation step, there were no changes to $l$, $\overline{d}$ and $E$, and thus $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$ and $pointsto(E, \mu) = pointsto(E, \mu')$. Therefore, $auth(l, l.m(l') \rhd E[e'], \mu')$ differ only by the values of $pointsto(e, \mu)$ and $pointsto(e', \mu')$. \qed

\end{proof}

\newpage
\begin{lemma}
If 
\mbox{$l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e]]~|~\mu \longrightarrow l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e']]~|~\mu'$}, where there are no method call stack frames in $E$ and $E'$, then $l$'s authority does not change.
%\begin{itemize}
%\item $l_2$'s authority may change
%\item $l$'s authority does not change (regardless of whether $l_2$'s authority changes).
%\end{itemize}
\end{lemma}

\begin{proof} In the initial state, we have:

\noindent$auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup pointsto(E[l_2.m_2(l_3) \rhd E'[e]], \mu) \cup auth_{stack}(l, E[l_2.m_2(l_3) \rhd E'[e]], \mu) & (\textsc{auth-stack})\\
&= auth_{store}(l, \mu) \cup pointsto(E[l_2.m_2(l_3) \rhd E'[e]], \mu) & (\textsc{auth-stack-nocall})
\end{align*}
There are two possibilities depending on whether $l_2$ is a principal or not:

\noindent$auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e']], \mu)$
\vspace{-7pt}
\[
%    auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e'], \mu') 
= 
\begin{cases}
    auth_{store}(l, \mu) \cup \{ l_2 \} \bigcup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-principal})\\
    auth_{store}(l, \mu) \cup pointsto(l_3, \mu) \bigcup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-data})
\end{cases}
\]Similarly, in the final state, we have:

\noindent$auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e']], \mu')$
\vspace{-7pt}
\[
%    auth(l, l.m(l_1) \rhd E[l_2.m_2(l_3) \rhd E'[e'], \mu') 
= 
\begin{cases}
    auth_{store}(l, \mu') \cup \{ l_2 \} \bigcup pointsto(subexps(E), \mu') & (\textsc{pointsto-call-principal})\\
    auth_{store}(l, \mu') \cup pointsto(l_3, \mu') \bigcup pointsto(subexps(E), \mu') & (\textsc{pointsto-call-data})
\end{cases}
\]
Since we are considering small-step semantics, there were no changes to $l$, $l_3$, and $E$, and $pointsto(l, \mu') = pointsto(l, \mu)$, $pointsto(l_3, \mu') = pointsto(l_3, \mu)$, and $\bigcup pointsto(subexps(E), \mu') = \bigcup pointsto(subexps(E), \mu)$. Thus, $l$'s authority does not change, and the lemma holds.\qed

\end{proof}

\begin{lemma} If 
\mbox{$E[l.m(l') \rhd E'[e]]~|~\mu \longrightarrow E[l.m(l') \rhd E'[e']]~|~\mu'$}, where there are no method call stack frames in $E'$, then for any $l''$, such that $l''.m'(l''') \in E$, $l''$'s authority does not change.
\end{lemma}

\begin{proof}
Proof is by inductively applying Lemma 6 to the method call stack frames in $E$ starting from the right most one (closest to $l.m(l') \rhd E'[e]$).\qed
\end{proof}

\newpage

\begin{theorem}[Authority Safety {[New]}] If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_{\keywadj{stateful}} \in \mu'$,
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$, and
\item $auth(l, e', \mu') \setminus auth(l, e, \mu) \supseteq \{ l_1 \}$,
\end{enumerate}
then one of the following must be true:
\begin{itemize}
\item \textbf{Object creation:}
\begin{enumerate}
\item $e = E[l.m(l_2) \rhd E'[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d}_1)]]$ and
\item $e' = E[l.m(l_2) \rhd E'[l_1]]$, where
\item $\nexists l'$, such that $l' \mapsto \{ x \Rightarrow \overline{d'}\}_{\keywadj{stateful}} \in \mu$ and $l'.m'(l'') \rhd E'' \in E'$
\end{enumerate}

\item \textbf{Method call:}
\begin{enumerate}
\item $e = E[l.m(l_1)]$ and
\item $e' = E[l.m(l_1) \rhd [l_1/y][l/x]e'']$
\end{enumerate}

\item \textbf{Method return:}
\begin{enumerate}
\item $e = E[l.m(l_2) \rhd E'[l_3.m'(l_4) \rhd l_1]]$ and
\item $e' = E[l.m(l_2) \rhd E'[l_1]]$, where
\item $\nexists l'$, such that $l' \mapsto \{ x \Rightarrow \overline{d'}\}_{\keywadj{stateful}} \in \mu$ and $l'.m''(l'') \rhd E'' \in E'$
\end{enumerate}
\end{itemize}

\end{theorem}

\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy 

\noindent\fbox{\parbox{\widthof{Case \textsc{E-Congruence}:}}{Case \textsc{E-Congruence}:}} The changes in authority when $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$ depend on what expressions are in $e~|~\mu \longrightarrow e'~|~\mu'$. Let us consider all possible $e$ and $e'$.\\

\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-New}:}}{Subcase \textsc{E-New}:}}
$e = \keywadj{new}_s(x \Rightarrow \overline{d}_1)$; $e' = l_1$; and $\mu' = \mu, l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_s$.
...
\end{proof}


\newpage

\begin{theorem}[Authority Safety {[Including pure objects]}] If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_{\keywadj{stateful}} \in \mu'$,
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$, and
\item $auth(l, e', \mu') \setminus auth(l, e, \mu) \supseteq \{ l_1 \}$,
\end{enumerate}
then one of the following must be true:
\begin{itemize}
\item \textbf{Object creation:}

$e = E[l.m(l_2) \rhd E'[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d}_1)]]$, $e' = E[l.m(l_2) \rhd E'[l_1]]$, where
\begin{enumerate}
\item $\nexists l_0$, such that $l_0 \mapsto \{ x \Rightarrow \overline{d_0}\}_{\keywadj{stateful}}$ and $l_0.m_0(l_0') \rhd E'' \in E'$, and
\item if $l \mapsto \{ x \Rightarrow \overline{d}\}_{\keywadj{stateful}}$, $\nexists l_0$, such that $l_0.m_0(l_0') \rhd E'' \in E$ and $auth(l_0, e', \mu') \setminus auth(l_0, e, \mu) = \{ l_1 \}$
\end{enumerate}

\item \textbf{Method call:}

$e = E[l.m(l_1)]$, $e' = E[l.m(l_1) \rhd [l_1/y][l/x]e'']$

\item \textbf{Method return:}

$e = E[l.m(l_2) \rhd E'[l_3.m'(l_4) \rhd l_1]]$, $e' = E[l.m(l_2) \rhd E'[l_1]]$, where
\begin{enumerate}
\item $\nexists l_0$, such that $l_0 \mapsto \{ x \Rightarrow \overline{d_0}\}_{\keywadj{stateful}}$ and $l_0.m'(l_0') \rhd E'' \in E'$, and
\item if $l \mapsto \{ x \Rightarrow \overline{d}\}_{\keywadj{stateful}}$, $\nexists l_0$, such that $l_0.m'(l_0') \rhd E'' \in E$ and $auth(l_0, e', \mu') \setminus auth(l_0, e, \mu) = \{ l_1 \}$
\end{enumerate}
\end{itemize}

\end{theorem}


\begin{theorem}[Authority Safety (Alternative)] If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$,
\item $l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_{\keywadj{stateful}} \in \mu'$,
\item $\{ l_1 \} \not\in auth(l, e, \mu)$, and
\item $\{ l_1 \} \in auth(l, e', \mu')$,
\end{enumerate}
then one of the following must be true:
\begin{enumerate}
\item \textbf{Object creation:}

$e = E[l.m(l_2) \rhd E'[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d}_1)]]$, $e' = E[l.m(l_2) \rhd E'[l_1]]$, where $E'$ does not contain any method call stack frames

\item \textbf{Method call:}

$e = E[l.m(l_1)]$, $e' = E[l.m(l_1) \rhd [l_1/y][l/x]e'']$

\item \textbf{Method return:}

$e = E[l.m(l_2) \rhd E'[l_3.m'(l_4) \rhd l_1]]$, $e' = E[l.m(l_2) \rhd E'[l_1]]$, where $E'$ does not contain any method call stack frames
\end{enumerate}

\end{theorem}

\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy 

\noindent\fbox{\parbox{\widthof{Case \textsc{E-Congruence}:}}{Case \textsc{E-Congruence}:}} The changes in authority when $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$ depend on what expressions are in $e~|~\mu \longrightarrow e'~|~\mu'$. Let us consider all possible $e$ and $e'$.\\

\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-New}:}}{Subcase \textsc{E-New}:}}
$e = E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]$; $e' = E[l_1]$; and $\mu' = \mu, l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_s$. There are two possibilities: either the evaluation context is empty, i.e. $E = [~]$, or not, i.e. $E \not= [~]$.\\

\noindent\textit{\mbox{\underline{Case $E = [~]$}}:} If the evaluation context is empty, ...\\
%Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$, and accordingly, there is no principal whose authority can change on this evaluation step. Thus, the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= [~]$}}:} If the evaluation context is not empty, then, by Lemma 7, only the authority of the caller in the closest method call stack frame can change and of no other caller in $E$. Then we need to consider
%
%Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: 
\mbox{$l.m(l_2) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]~|~\mu \longrightarrow l.m(l_2) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority in the two states. In the initial state, we have:

\noindent$auth(l, l.m(l_2) \rhd E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}_1), \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\overline{d}_1, \mu) & (\textsc{pointsto-new})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup pointsto(l_1, \mu') & (Lemma~4)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{\underline{Case $l_1$ is a principal:}}
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup \{ l_1 \} & (\textsc{pointsto-principal})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$. Thus, $\{ l_1 \} \not\in auth(l, e, \mu)$ and $\{ l_1 \} \in auth(l, e', \mu')$, which is in compliance with the \textbf{\textit{object creation}} case, and the theorem holds.\\

\noindent\textit{\underline{Case $l_1$ is pure:}}
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') & (\textsc{pointsto-data})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, $\overline{d}_1$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$. Thus, there is no gain in $l_1$'s authority, and the theorem holds.\\\\
...

\end{proof}

\newpage
\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy 

\noindent\fbox{\parbox{\widthof{Case \textsc{E-New}:}}{Case \textsc{E-New}:}}
$e = E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]$; $e' = E[l_1]$; and $\mu' = \mu, l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_s$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$, and accordingly, there is no principal whose authority can change on this evaluation step. Thus, the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m(l_2) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]~|~\mu \longrightarrow l.m(l_2) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority in the two states. In the initial state, we have:

\noindent$auth(l, l.m(l_2) \rhd E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}_1), \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\overline{d}_1, \mu) & (\textsc{pointsto-new})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup pointsto(l_1, \mu') & (Lemma~4)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{\underline{Case $l_1$ is a principal:}}
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup \{ l_1 \} & (\textsc{pointsto-principal})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$. Thus, $\{ l_1 \} \not\in auth(l, e, \mu)$ and $\{ l_1 \} \in auth(l, e', \mu')$, which is in compliance with the \textbf{\textit{object creation}} case, and the theorem holds.\\

\noindent\textit{\underline{Case $l_1$ is pure:}}
\begin{align*}
auth(l, l.m(l_2) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') & (\textsc{pointsto-data})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, $\overline{d}_1$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$. Thus, there is no gain in $l_1$'s authority, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Meth}:}}{Case \textsc{E-Meth}:}}
$e = E[l_1.m(l_2)]$, $e' = E[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'']$, and $\mu' = \mu$. From the premise, we get $l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{def} m(y : \tau_1) : \tau_2 = e'' \in \overline{d}$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$. The only principal whose authority can change on this step is $l_1$. Let us consider $l_1$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2), \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2), \mu) & (\textsc{auth-config})\\
%&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.m(l_2), \mu) & (\textsc{auth-store})\\
&= auth_{store}(l_1, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e'', \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e'', \mu) & (\textsc{auth-config})\\
%&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e'', \mu) & (\textsc{auth-store})\\
&= auth_{store}(l_1, \mu) \cup pointsto([l_2/y][l_1/x]e'', \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e'', \mu) & (\textsc{auth-stack})\\
&\subseteq auth_{store}(l_1, \mu) \cup pointsto(l_2, \mu) \cup pointsto(e'', \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e'', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
Since we are considering small-step semantics, there is no method call stack frame in $e''$ and, by \textsc{auth-stack-nocall}, $auth_{stack}(l_1, [l_2/y][l_1/x]e'', \mu) = \varnothing$. By \textsc{auth-store}, \textsc{pointsto-decls} and \textsc{pointsto-def}, $pointsto(e'', \mu) \in auth_{store}(l_1, \mu)$. Therefore, we get:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e'', \mu) \subseteq auth_{store}(l_1, \mu) \cup pointsto(l_2, \mu)
\end{align*}
Here three cases are possible: 1) If $l_2$ is a pure object, $l_1$'s authority does not increase, and the theorem holds. 2) If $l_2$ is a principal, but it is not used in $e''$, $l_1$'s authority does not increase, and the theorem holds. 3) If $l_2$ is a principal, and it is used in $e''$, $l_1$'s authority increases by $\{ l_2 \}$ (\textsc{pointsto-principal}), which is in compliance with the \textbf{\textit{method call}} case, and the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l_1.m(l_2)]~|~\mu \longrightarrow l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'']~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the initial case, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2), \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'', \mu) & (Lemma~4)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.\\

\noindent\textit{\underline{Case $l_1$ is a principal:}}

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup \{ l_1 \} & (\textsc{pointsto-call-principal})
\end{align*}
Thus, $l$'s authority does not change, and the theorem holds.\\

\noindent\textit{\underline{Case $l_1$ is pure:}} 

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto([l_2/y] [l_1/x] e'', \mu) & (\textsc{pointsto-call-data})\\
&\subseteq pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) & (\textsc{pointsto-otherexp}) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu) \cup pointsto(e'', \mu)
\end{align*}
Since $l_1$ is pure, by \textsc{pointsto-data}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, \mbox{$pointsto(l_1, \mu) = \varnothing$}, $pointsto(e'', \mu) = \varnothing$ and
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) \subseteq pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_2, \mu)
\]
Thus, $l$'s authority does not increase, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Field}:}}{Case \textsc{E-Field}:}}
$e = E[l.f]$, $e' = E[l_1]$, and $\mu' = \mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{var} f : \tau = l_1 \in \overline{d}$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$. The only principal whose authority can change on this step is $l$. Let us consider $l$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l, l.f, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l.f, \mu) & (\textsc{auth-config})\\
%&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.f, \mu) & (\textsc{auth-store})\\
&= auth_{store}(l, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l_1, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l_1, \mu) & (\textsc{auth-config})\\
%&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l_1, \mu) & (\textsc{auth-store})\\
&= auth_{store}(l, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
Thus, $l$'s authority does not change, and the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Since object fields are private and thus accessible only within the object, $lookupCaller(E) = l$, i.e. for this step to execute, the caller must be the object whose field is being evaluated. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m(l_0) \rhd E'[l.f]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the initial state, we have:

\noindent$auth(l, l.m(l_0) \rhd E'[l.f], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l.f, \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l.m(l_0) \rhd E'[l_1], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) & (Lemma~4)
\end{align*}
As $\keyw{var} f : \tau = l_1 \in \overline{d}$, by \textsc{pointsto-decls} and \textsc{pointsto-varl}, $pointsto(l_1, \mu) \subset pointsto(\overline{d}, \mu)$ and
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu)
\]
Thus, $l$'s authority does not change, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Assign}:}}{Case \textsc{E-Assign}:}}
$e = E[l.f = l_1]$, $e' = E[l_1]$, and $\mu' = [l \mapsto \{ x \Rightarrow \overline{d}' \}_{s}/l \mapsto \{ x \Rightarrow \overline{d} \}_{s}]\mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$, $\keyw{var} f:\tau = l_2 \in \overline{d}$, and $\overline{d}' = [\keyw{var} f : \tau = l_1/\keyw{var} f:\tau = l_2]\overline{d}$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$. The only principal whose authority can change on this step is $l$. Let us consider $l$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l, l.f = l_1, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l.f = l_1, \mu) & (\textsc{auth-config})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.f = l_1, \mu) & (\textsc{auth-store})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l_1, \mu') &= auth_{store}(l, \mu') \cup auth_{stack}(l, l_1, \mu') & (\textsc{auth-config})\\
&= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup auth_{stack}(l, l_1, \mu') & (\textsc{auth-store})\\
&= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') & (\textsc{auth-stack-nocall})
\end{align*}
By \textsc{pointsto-principal} and \textsc{pointsto-data}, $pointsto(l, \mu') = pointsto(l, \mu)$. \todo{...} Thus, $l$'s authority does not change, and the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Since object fields are private and thus accessible only within the object, $lookupCaller(E) = l$, , i.e. for this step to execute, the caller must be the object whose field is being evaluated. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l.f = l_1]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the initial state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[l.f = l_1], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l.f = l_1, \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1], \mu') &= pointsto(l, \mu') \cup pointsto(\overline{d}', \mu') \cup pointsto(E', \mu') \cup  pointsto(l_1, \mu') & (Lemma~4)
\end{align*}
Since we are considering small-step semantics, within this evaluation step, no other assignment could have taken place. Therefore, there were no changes to $l$, $l_1$, or $E'$, and $pointsto(l, \mu') = pointsto(l, \mu)$, $pointsto(l_1, \mu') = pointsto(l_1, \mu)$, and$pointsto(E', \mu) = pointsto(E', \mu')$. \todo{...} Thus, $l$'s authority does not change, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Bind}:}}{Case \textsc{E-Bind}:}}
$e = E[\keyw{bind} x = l_1~\keyw{in} e'']$, $e' = E[[l_1/x] e'']$, and $\mu' = \mu$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$, and accordingly, there is no principal whose authority can change on this evaluation step. Thus, the theorem holds.\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e'']~|~\mu \longrightarrow l.m'(l_0) \rhd E'[[l_1/x] e'']~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the initial state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\keyw{bind} x = l_1~\keyw{in} e'', \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(e'', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[[l_1/x] e''], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto([l_1/x] e'', \mu) & (Lemma~4)\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(e'', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
Thus, $l$'s authority does not change, and the theorem holds.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-StackFrame}:}}{Case \textsc{E-StackFrame}:}}
$e = E[l_1.m(l_2) \rhd l_3]$, $e' = E[l_3]$, and $\mu' = \mu$. There are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{\underline{Case $E = \varnothing$}}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$. The only principal whose authority can change on this step is $l_1$. Let us consider $l_1$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd l_3, \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd l_3, \mu) & (\textsc{auth-config})\\
%&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.f = l_1, \mu) & (\textsc{auth-store})\\
&= auth_{store}(l_1, \mu) \cup pointsto(l_3, \mu) \cup auth_{stack}(l_1, l_3, \mu) & (\textsc{auth-stack})\\
&= auth_{store}(l_1, \mu) \cup pointsto(l_3, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l_1, l_3, \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_3, \mu) & (\textsc{auth-config})\\
%&= pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup auth_{stack}(l, l_1, \mu') & (\textsc{auth-store})\\
&= auth_{store}(l_1, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
Thus, $l_1$'s authority does not increase, and the theorem holds.\\\\

\noindent\textit{\mbox{\underline{Case $E \not= \varnothing$}}:} Without loss of generality, let \mbox{$lookupCaller(E) = l$}, such that \mbox{$l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$}. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3]~|~\mu \longrightarrow l.m'(l_0) \rhd E'[l_3]~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. In the final state, we have:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_3], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_3, \mu) & (Lemma~4)
\end{align*}
In the initial state, we have:

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2) \rhd l_3, \mu) & (Lemma~4)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{\underline{Case $l_1$ is a principal:}}

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup \{ l_1 \} & (\textsc{pointsto-call-principal})
\end{align*}
Thus, $l$'s authority increases by $l_3$, which is in compliance with the \textit{\textbf{method return}} case, and the theorem holds.\\

\noindent\textit{\underline{Case $l_1$ is pure:}}

\noindent$auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_3, \mu) & (\textsc{pointsto-call-data})
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\qed

\end{proof}


\newpage

\begin{proof}

The program begins with a creation of an object and an empty stack. When the first object is created, since there are no other objects in the program, no object can gain authority. After the first object is created, authority of objects in the program can change. There are three actions that can be done to an object: field access (E-Field), field assignment (E-Assign), and method call (E-Meth). Let us consider how each of them changes the authority of the object. (This can be generalized to any object in the program.)\\

\noindent\underline{\textit{Case \textsc{E-Field}:}}
$l.f~|~\mu \rightarrow l_1~|~\mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{var} f : \tau = l_1 \in \overline{d}$.

\noindent Let us consider $l$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l, l.f, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l.f, \mu) & (\textsc{auth-config})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l.f, \mu) & (\textsc{auth-store})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l, l_1, \mu) &= auth_{store}(l, \mu) \cup auth_{stack}(l, l_1, \mu) & (\textsc{auth-config})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l, l_1, \mu) & (\textsc{auth-store})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
Thus there is no change to $l$'s authority, and the theorem holds.\\

\noindent\underline{\textit{Case \textsc{E-Assign}:}}
$l_1.f = l_2~|~\mu \longrightarrow l_2~|~\mu'$. From the premise, we get $l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$, $\keyw{var} f : \tau = l \in \overline{d}$, $\overline{d}' = [\keyw{var} f : \tau = l_2/\keyw{var} f : \tau = l]\overline{d}$, and $\mu' = [l_1 \mapsto \{ x \Rightarrow \overline{d}' \}_{s}/l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s}]\mu$. 

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_1, l_1.f = l_2, \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.f = l_2, \mu) & (\textsc{auth-config})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.f = l_2, \mu) & (\textsc{auth-store})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l_1, l_2, \mu') &= auth_{store}(l_1, \mu') \cup auth_{stack}(l_1, l_2, \mu') & (\textsc{auth-config})\\
&= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') \cup auth_{stack}(l_1, l_2, \mu') & (\textsc{auth-store})\\
&= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') & (\textsc{auth-stack-nocall})
\end{align*}
By \textsc{pointsto-principal} and \textsc{pointsto-data}, $pointsto(l_1, \mu) = pointsto(l_1, \mu')$. However,\\ $pointsto(\overline{d}, \mu') \setminus pointsto(\overline{d}, \mu) \subseteq pointsto(l_2, \mu')$. Thus if $l_2$ is a pure object, the authority of $l_1$ does not increase; if $l_2$ is a principal, $l_1$ gains authority over $l_2$, which is in accordance with case 1 of the theorem. In both cases, the theorem holds.\\

\noindent\underline{\textit{Case \textsc{E-Meth}:}}
$l_1.m(l_2)~|~\mu \rightarrow l_1.m(l_2) \rhd [l_2/y][l_1/x]e~|~\mu$. From the premise, we get $l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{def} m(y : \tau_1) : \tau_2 = e \in \overline{d}$.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2), \mu) &= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2), \mu) & (\textsc{auth-config})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.m(l_2), \mu) & (\textsc{auth-store})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
In the final state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e, \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l_1, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e, \mu) & (\textsc{auth-config})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup auth_{stack}(l_1, l_1.m(l_2) \rhd [l_2/y][l_1/x]e, \mu) & (\textsc{auth-store})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{auth-stack})\\
&\cup pointsto([l_2/y][l_1/x]e, \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e, \mu)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{pointsto-otherexp})\\
&\cup pointsto(l_2, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e, \mu)
\end{align*}
Here the authority of the object increases by $pointsto(l_2, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l_1, [l_2/y][l_1/x]e, \mu)$, which depends on the concrete values of $l_2$ and $e$. If $l_2$ is a principal, the authority of $l_1$ increases (at least) by $\{ l_2 \}$, which is in accordance with case 2 of the theorem. The rest of the authority increase depends on $e$. Let us now consider what expressions $e$ can contain and how those expressions change the authority of $l_1$.\\

\noindent\underline{\textit{Subcase \textsc{E-New}:}}
$l_1.m(l_2) \rhd E[\keywadj{new}_s(x \Rightarrow \overline{d}_3)]~|~\mu \longrightarrow l_1.m(l_2) \rhd E[l_3]~|~\mu'$, where $E$ does not contain any method call stack frames.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[\keywadj{new}_s(x \Rightarrow \overline{d}_3)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}_3), \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(\overline{d}_3, \mu) & (\textsc{pointsto-new})
\end{align*}
In the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_3], \mu') &= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup pointsto(l_3, \mu') & (Lemma~4)
\end{align*}
Depending on whether $l_3$ is a principal, there are two possibilities.

\noindent\textit{Case $l_3$ is a principal:}
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_3], \mu') &= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') \cup \{ l_3 \} & (\textsc{pointsto-principal})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l_1$, $\overline{d}$, or $E$, and $pointsto(l_1, \mu) = pointsto(l_1, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, and $pointsto(E, \mu) = pointsto(E, \mu')$. Thus the caller object $l_1$ gained authority over the newly created principal in accordance with case 3 of the theorem.

\noindent\textit{Case $l_3$ is pure:}
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_3], \mu') &= pointsto(l_1, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E, \mu') & (\textsc{pointsto-data})
\end{align*}
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l_1$, $\overline{d}$, or $E$, and $pointsto(l_1, \mu) = pointsto(l_1, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, and $pointsto(E, \mu) = pointsto(E, \mu')$. Thus there was no gain in $l_1$'s authority, and the theorem holds.\\

\noindent\underline{\textit{Subcase \textsc{E-Meth}:}}
$l_1.m(l_2) \rhd E[l_3.m'(l_4)]~|~\mu \longrightarrow l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e']~|~\mu$, where $E$ does not contain any method call stack frames. From the premise, we get $l_3 \mapsto \{ x \Rightarrow \overline{d}_3 \}_{s} \in \mu$ and $\keyw{def} m'(y : \tau_1) : \tau_2 = e' \in \overline{d}_3$.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3.m'(l_4), \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3, \mu) \cup pointsto(l_4, \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e', \mu) & (Lemma~4)
\end{align*}
Depending on whether $l_3$ is a principal, there are two possibilities.

\noindent\underline{\textit{Case $l_3$ is a principal:}} In the initial state:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_3 \} \cup pointsto(l_4, \mu) & (\textsc{pointsto-principal})
\end{align*}
In the final state,

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_3 \} & (\textsc{pointsto-call-principal})
\end{align*}
Thus $l_1$ does not gain authority, and the theorem holds.

\noindent\underline{\textit{Case $l_3$ is pure:}} In the initial state:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4)], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_4, \mu) & (\textsc{pointsto-data})
\end{align*}
In the final state,

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto([l_4/y] [l_3/x] e', \mu) & (\textsc{pointsto-call-data})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) & (\textsc{pointsto-otherexp})\\
&\cup pointsto(l_4, \mu) \cup pointsto(l_3, \mu) \cup pointsto(e', \mu)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_4, \mu) \cup pointsto(e', \mu) & (\textsc{pointsto-data})
\end{align*}
By definition of a pure object, $pointsto(e', \mu) = \varnothing$ and

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd [l_4/y] [l_3/x] e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_4, \mu)
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.\\

\noindent\underline{\textit{Subcase \textsc{E-Field}:}}
Since fields are private, it must be $l_1$ accessing the field, and this subcase is equivalent to Case E-Field above.\\

\noindent\underline{\textit{Subcase \textsc{E-Assign}:}}
Since fields are private, it must be $l_1$ accessing the field, and this subcase is equivalent to Case E-Assign above.\\

\noindent\underline{\textit{Subcase \textsc{E-Bind}:}}
$l_1.m(l_2) \rhd E[\keyw{bind} x = l_3~\keyw{in} e']~|~\mu \longrightarrow l_1.m(l_2) \rhd E[[l_3/x] e']~|~\mu$, where $E$ does not contain any method call stack frames.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[\keyw{bind} x = l_3~\keyw{in} e'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(\keyw{bind} x = l_3~\keyw{in} e', \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3, \mu) \cup pointsto(e', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
In the final state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[[l_3/x] e'], \mu')$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto([l_3/x] e', \mu) & (Lemma~4)\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3, \mu) \cup pointsto(e', \mu) & (\textsc{pointsto-otherexp})
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.\\

\noindent\underline{\textit{Subcase \textsc{E-StackFrame}:}}
$l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5]~|~\mu \longrightarrow l_1.m(l_2) \rhd E[l_5]~|~\mu$, where $E$ does not contain any method call stack frames.

\noindent Let us consider $l_1$'s authority in the two states. In the initial state, we have:

\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_3.m'(l_4) \rhd l_5, \mu) & (Lemma~4)
\end{align*}
In the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_5, \mu) & (Lemma~4)
\end{align*}
Depending on whether $l_3$ and $l_5$ are principals, there are four possibilities.

\noindent\underline{\textit{Case $l_3$ and $l_5$ are principals:}}
In the initial state, we have:\\
\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_3 \} & (\textsc{pointsto-call-principal})
\end{align*}
and in the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_5 \} & (\textsc{pointsto-principal})
\end{align*}
Thus $l_1$ gains authority over $l_5$, which is in accordance with case 4 of the theorem, and the theorem holds.

\noindent\underline{\textit{Case $l_3$ is a principal and $l_5$ is pure:}}
In the initial state, we have:\\
\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_3 \} & (\textsc{pointsto-call-principal})
\end{align*}
and in the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) & (\textsc{pointsto-data})
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_3$ is pure and $l_5$ is a principal:}}
In the initial state, we have:\\
\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_5, \mu) & (\textsc{pointsto-call-data})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_5 \} & (\textsc{pointsto-principal})
\end{align*}
and in the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup \{ l_5 \} & (\textsc{pointsto-principal})
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_3$ and $l_5$ are pure:}}
In the initial state, we have:\\
\noindent$auth(l_1, l_1.m(l_2) \rhd E[l_3.m'(l_4) \rhd l_5], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) \cup pointsto(l_5, \mu) & (\textsc{pointsto-call-data})\\
&= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) & (\textsc{pointsto-data})
\end{align*}
and in the final state, we have:
\begin{align*}
auth(l_1, l_1.m(l_2) \rhd E[l_5], \mu) &= pointsto(l_1, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E, \mu) & (\textsc{pointsto-data})
\end{align*}
Thus $l_1$'s authority does not increase, and the theorem holds.\\

\noindent Therefore, the theorem holds for all cases.\qed

\end{proof}

\newpage

\begin{theorem}[Authority Safety] If
\begin{enumerate}
\item $\mu : \Sigma$,
\item $\varnothing~|~\Sigma \vdash e : \tau$, {\emph{~~~~~~~~~~~~[The program $e$ is well-formed]}}
\item $e~|~\mu \longrightarrow e'~|~\mu'$, and
\item for some principal $l$, $auth(l, e', \mu') \supset auth(l, e, \mu)$,
\end{enumerate}
then one of the following must hold:
\begin{itemize}
  \item \textbf{Object creation:}
  \begin{enumerate}
  \item $e = E[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d}_1)]$, $e' = E[l_1]$,
  \item $lookupCaller(E) = l$, {\emph{~~~~~~~~~~~~~~~~~~~~~~~[The creator was $l$]}}
  \item $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_1 \}$.\\
  \end{enumerate}
  \item \textbf{Method call:}
  \begin{enumerate}
  \item $e = E[l.m(l_1)]$, $e' = E[l.m(l_1) \rhd [l_1/y][l/x]e'']$,
  \item $pointsto(l_1,\mu) = \{ l_1 \} \cup pointsto(\overline{d}_1, \mu)$, {\emph{~~~~~~~~~~[The argument $l_1$ is a principal]}}
  \item $\{ l_1 \} \not\in auth(l, e, \mu)$,
  \item $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_1 \}$.\\
  \end{enumerate}
  \item \textbf{Method return:}
  \begin{enumerate}
  \item $e = E[l_1.m(l_2) \rhd l_3]$, $e' = E[l_3]$,
  \item $pointsto(l_3,\mu) = \{ l_3 \} \cup pointsto(\overline{d}_3, \mu)$, {\emph{~~~~~~~~[The returned $l_3$ is a principal]}}
  \item $lookupCaller(E) = l$, {\emph{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[The caller was $l$]}}
  \item $\{ l_3 \} \not\in auth(l, e, \mu)$,
  \item $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_3 \}$.\\
  \end{enumerate}
\end{itemize}

\end{theorem}

(The Authority Safety theorem follows the definition in Maffeis et al.~\cite{Maffeis:2010}.)

\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy 

\noindent\fbox{\parbox{\widthof{Case \textsc{E-New}:}}{Case \textsc{E-New}:}}
$e = E[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]$; $e' = E[l_1]$; and $\mu' = \mu, l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_s$. Since a program starts with a $\keywadj{new}_s$ expression, there are two possibilities: either the evaluation context is empty, i.e. $E = \varnothing$, or not, i.e. $E \not= \varnothing$.\\

\noindent\textit{\mbox{Case $E = \varnothing$}:} Since the evaluation context is empty, there is no caller, i.e. $lookupCaller = \varnothing$, and accordingly, there is no principal whose authority can change on this evaluation step. Thus, the theorem holds.\\

\noindent\textit{\mbox{Case $E \not= \varnothing$}:} Without loss of generality, let $lookupCaller(E) = l$, such that $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m(l_0) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\[
auth(l, l.m(l_0) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}_1), \mu)\]
and by \textsc{pointsto-new},
\[
auth(l, l.m(l_0) \rhd E'[\keywadj{new}_s(x \Rightarrow \overline{d}_1)], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(\overline{d}_1, \mu)
\]
By Lemma 4, in the final state, we have:
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup pointsto(l_1, \mu').
\]
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{Case $l_1$ is a principal:} By \textsc{pointsto-principal}, we get:
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup \{ l_1 \} \cup pointsto(\overline{d}_1, \mu')
\]
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}_1$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$.\\

\noindent Thus, $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_1 \}$ in compliance with the \textbf{\textit{object creation}} case of the theorem.\\

\noindent\textit{Case $l_1$ is pure:} By \textsc{pointsto-data}, we get:
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup pointsto(\overline{d}_1, \mu')
\]
Although the memory was extended with the new object, since we are considering small-step semantics, within this evaluation step, no assignment could have taken place. Therefore, there were no changes to $l$, $\overline{d}$, $\overline{d}_1$, or $E'$, and $pointsto(l, \mu) = pointsto(l, \mu')$, $pointsto(\overline{d}, \mu) = pointsto(\overline{d}, \mu')$, $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$, and $pointsto(E', \mu) = pointsto(E', \mu')$.\\

\noindent Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Meth}:}}{Case \textsc{E-Meth}:}}
$e = E[l_1.m(l_2)]$, $e' = E[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'']$, and $\mu' = \mu$. From the premise, we get $l_1 \mapsto \{ x \Rightarrow \overline{d}_1 \}_{s} \in \mu$ and $\keyw{def} m(y : \tau_1) : \tau_2 = e'' \in \overline{d}_1$. Without loss of generality, let $lookupCaller(E) = l$, such that $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l_1.m(l_2)]~|~\mu \longrightarrow l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'']~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2)], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2), \mu)\]
and by \textsc{pointsto-otherexp},
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2)], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu)
\]
By Lemma 4, in the final state, we have:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1.m(l_2) \rhd [l_2/y] [l_1/x] e'', \mu)
\end{align*}
Depending on whether $l_1$ is a principal, there are two possibilities.\\

\noindent\textit{Case $l_1$ is a principal:} By \textsc{pointsto-call-principal}, we get:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto([l_2/y] [l_1/x] e'', \mu)
\end{align*}
and by \textsc{pointsto-otherexp},
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu) \cup pointsto(e'', \mu)
\end{align*}
Here $e''$ is the body of $l_1$'s method, then by \textsc{pointsto-principal}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $pointsto(e'', \mu) \subset pointsto(l_1, \mu)$ and
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu)
\end{align*}
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\

\noindent\textit{Case $l_1$ is pure:} By \textsc{pointsto-call-data}, we get:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto([l_2/y] [l_1/x] e'', \mu)
\end{align*}
and by \textsc{pointsto-otherexp},
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu) \cup pointsto(e'', \mu)
\end{align*}
Here $e''$ is the body of $l_1$'s method, then by \textsc{pointsto-principal}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $pointsto(e'', \mu) \subseteq pointsto(l_1, \mu)$ and
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd [l_2/y] [l_1/x] e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(l_2, \mu)
\end{align*}
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Field}:}}{Case \textsc{E-Field}:}}
$e = E[l.f]$, $e' = E[l_1]$, and $\mu' = \mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ and $\keyw{var} f : \tau = l_1 \in \overline{d}$. Since object fields are private and thus accessible only within the object, $lookupCaller(E) = l$, i.e. for this step to execute, the caller must be the object whose field is being evaluated. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m(l_0) \rhd E'[l.f]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\[
auth(l, l.m(l_0) \rhd E'[l.f], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l.f, \mu)
\]
and by \textsc{pointsto-otherexp},
\[
auth(l, l.m(l_0) \rhd E'[l.f], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu)
\]
By Lemma 4, in the final state, we have:
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu)
\]
As $\keyw{var} f : \tau = l_1 \in \overline{d}$, by \textsc{pointsto-decls} and \textsc{pointsto-varl}, $pointsto(l_1, \mu) \subset pointsto(\overline{d}, \mu)$ and
\[
auth(l, l.m(l_0) \rhd E'[l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu)
\]
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Assign}:}}{Case \textsc{E-Assign}:}}
$e = E[l.f = l_1]$, $e' = E[l_1]$, and $\mu' = [l \mapsto \{ x \Rightarrow \overline{d}' \}_{s}/l \mapsto \{ x \Rightarrow \overline{d} \}_{s}]\mu$. From the premise, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$, $\keyw{var} f:\tau = l_2 \in \overline{d}$, and $\overline{d}' = [\keyw{var} f : \tau = l_1/\keyw{var} f:\tau = l_2]\overline{d}$. Since object fields are private and thus accessible only within the object, $lookupCaller(E) = l$, , i.e. for this step to execute, the caller must be the object whose field is being evaluated. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l.f = l_1]~|~\mu \longrightarrow l.m(l_0) \rhd E'[l_1]~|~\mu'$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l.f = l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l.f = l_1, \mu)\]
and by \textsc{pointsto-otherexp},
\[
auth(l, l.m'(l_0) \rhd E'[l.f = l_1], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu)
\]
By Lemma 4, in the final state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l_1], \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu') \cup pointsto(E', \mu') \cup  pointsto(l_1, \mu')
\]
The memory changed due to the value change of $l$'s field $f$ from $l_2$ to $l_1$. By \textsc{pointsto-principal}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $l$ already had authority over $l_1$ via the body of method $m()$. In addition, since we are considering small-step semantics, within this evaluation step, no other assignment could have taken place. Therefore, $pointsto(l, \mu') \subseteq pointsto(l, \mu)$. Furthermore, due to the latter reason, there were no changes to $\overline{d}_1$ or $E'$, and $pointsto(\overline{d}_1, \mu) = pointsto(\overline{d}_1, \mu')$ and $pointsto(E', \mu) = pointsto(E', \mu')$.\\

\noindent Thus, $auth(l, e', \mu') \subseteq auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-Bind}:}}{Case \textsc{E-Bind}:}}
$e = E[\keyw{bind} x = l_1~\keyw{in} e'']$, $e' = E[[l_1/x] e'']$, and $\mu' = \mu$. Without loss of generality, let $lookupCaller(E) = l$, such that $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e'']~|~\mu \longrightarrow l.m'(l_0) \rhd E'[[l_1/x] e'']~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the initial state, we have:
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(\keyw{bind} x = l_1~\keyw{in} e'', \mu)
\end{align*}
and by \textsc{pointsto-otherexp},
\begin{align*}
auth(l, l.m'(l_0) \rhd E'[\keyw{bind} x = l_1~\keyw{in} e''], \mu) &= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \\
&\cup pointsto(l_1, \mu) \cup pointsto(e'', \mu)
\end{align*}
By Lemma 4, in the final state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[[l_1/x] e''], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto([l_1/x] e'', \mu)
\]
and by \textsc{pointsto-otherexp},
\[
auth(l, l.m'(l_0) \rhd E'[[l_1/x] e''], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(e'', \mu)
\]
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\\\


\noindent\fbox{\parbox{\widthof{Case \textsc{E-StackFrame}:}}{Case \textsc{E-StackFrame}:}}
$e = E[l_1.m(l_2) \rhd l_3]$, $e' = E[l_3]$, and $\mu' = \mu$. Without loss of generality, let $lookupCaller(E) = l$, such that $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$. By \textsc{lookupCaller}, in a broader context, the following evaluation step is being made: \mbox{$l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3]~|~\mu \longrightarrow l.m'(l_0) \rhd E'[l_3]~|~\mu$}, where there are no method call stack frames in $E'$.\\

\noindent Let us consider $l$'s authority for the two states. By Lemma 4, in the final state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l_3], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_3, \mu)
\]
By Lemma 4, in the initial state, we have:
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1.m(l_2) \rhd l_3, \mu).
\]
Depending on whether $l_1$ is a principal, there are two possibilities.

\noindent\textit{Case $l_1$ is a principal:} By \textsc{pointsto-call-principal}, we get:
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_1, \mu) \cup pointsto(l_3, \mu)
\]
Thus, $auth(l, e', \mu') = auth(l, e, \mu) \cup \{ l_3 \}$ in compliance with the theorem.\\

\noindent\textit{Case $l_1$ is pure:} By \textsc{pointsto-call-data}, we get:
\[
auth(l, l.m'(l_0) \rhd E'[l_1.m(l_2) \rhd l_3], \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(E', \mu) \cup pointsto(l_3, \mu).
\]
Thus, $auth(l, e', \mu') = auth(l, e, \mu)$ in compliance with the theorem.\\

\end{proof}


\newpage

\begin{theorem}[Auxiliary]
For all $l$, such that
$E[l.m(l') \rhd E'[e]]~|~\mu \longrightarrow E[l.m(l') \rhd E'[e']]~|~\mu'$,
if
\begin{enumerate}
\item $\exists l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{stateful}} \in \mu'$, such that $pointsto(e', \mu') \setminus pointsto(e, \mu) = \{ l_0 \}$
\item $\forall l_1.m_1(l_1') \rhd E'' \in E'$, $l_1 \mapsto \{ x \Rightarrow \overline{d_1} \}_{\keywadj{pure}} \in \mu$
\end{enumerate}
then
$auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth(l, E[l.m(l') \rhd E'[e]], \mu) = \{ l_0 \}$.
\end{theorem}

\begin{proof}
The proof is by induction on the method call stack frames.\\

\noindent\textit{\underline{Base case:}} $l'.m'(l'') \rhd E_1 \not\in E$ and $l'.m'(l'') \rhd E_1 \not\in E'$. 

Let $auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth(l, E[l.m(l') \rhd E'[e]], \mu) \not= \{ l_0 \}$.

Consider $l$'s authority in the two states. In the initial state, we have:

\noindent$auth(l, E[l.m(l') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, E[l.m(l') \rhd E'[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup pointsto(E'[e], \mu) \cup auth_{stack}(l, E'[e], \mu) & (\textsc{auth-stack})\\
&= auth_{store}(l, \mu) \cup pointsto(E'[e], \mu) & (\textsc{auth-stack-nocall})\\
&= auth_{store}(l, \mu) \cup pointsto(e, \mu) \bigcup pointsto(subexps(E'), \mu) & (Lemma~8)
\end{align*}
Similarly, in the final state, we have:
\[
auth(l, E[l.m(l') \rhd E'[e']], \mu') = auth_{store}(l, \mu') \cup pointsto(e', \mu') \bigcup pointsto(subexps(E'), \mu')
\]
Since we are considering small-step semantics, there was no change to $l$ and $E'$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$ and $\bigcup pointsto(subexps(E'), \mu') = \bigcup pointsto(subexps(E'), \mu)$. Therefore,
\[
auth(l, E[l.m(l') \rhd E'[e']], \mu') = auth_{store}(l, \mu) \cup pointsto(e', \mu') \bigcup pointsto(subexps(E'), \mu)
\]
Then, we get
\[
auth(l, E[l.m(l') \rhd E'[e']], \mu') \setminus auth(l, E[l.m(l') \rhd E'[e]], \mu) = pointsto(e', \mu') \setminus pointsto(e, \mu) = \{ l_0 \}
\]
This contradicts our assumption, and thus the assumption is wrong and the theorem holds.\\

\noindent\textit{\underline{Inductive case:}} Let us enumerate all method callers preceding $e$ and $e'$ on the stack starting from the method caller closest to $e$ and $e'$ on the stack:
$E[l_i.m(l_i') \rhd E'[e]]~|~\mu \longrightarrow E[l_i.m(l_i') \rhd E'[e']]~|~\mu'$,
where $1 \leq i \leq n$.

Now consider $l_k$, such that
\[
E[l_k.m(l_k') \rhd E'[e]]~|~\mu \longrightarrow E[l_k.m(l_k') \rhd E'[e']]~|~\mu'
\]
where $1 \leq k \leq n$; for $i = 1 \dots k - 1$, $l_i.m_i(l_i') \rhd E'' \in E'$; and for $i = k + 1 \dots n$, $l_i.m_i(l_i') \rhd E'' \in E$. Then from the premise of the theorem, we have:

\begin{enumerate}
\item $\exists l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{stateful}}$, such that $pointsto(e', \mu') \setminus pointsto(e, \mu) = \{ l_0 \}$
\item for $i = 1 \dots k - 1$, $ l_i.m_i(l_i') \rhd E'' \in E'$, $l_i \mapsto \{ x \Rightarrow \overline{d_i} \}_{\keyw{pure}}$
\end{enumerate}

Let $auth(l_k, E[l_k.m(l_k') \rhd E'[e']], \mu') \setminus auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) \not= \{ l_0 \}$.

Consider $l_k$'s authority in the two states. In the initial state, we have:
\begin{align*}
auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) &= auth_{store}(l_k, \mu) \cup auth_{stack}(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) & (\textsc{auth-config})
\end{align*}
Without loss of generality, let $l_k.m(l_k') \rhd E'''$ be the leftmost method call stack frame where $l_k$'s method is called, i.e. let $l_k.m(l_k') \rhd E''' \not\in E$. Then we get:
\begin{align*}
auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) &= auth_{store}(l_k, \mu) \cup pointsto(E'[e], \mu) \cup auth_{stack}(l_k, E'[e], \mu) & (\textsc{auth-stack})
\end{align*}
If $l_k.m(l_k') \rhd E''' \in E'$, then if $pointsto(e, \mu) \in pointsto(E'[e], \mu)$, by Lemma 10, $pointsto(e, \mu) \in auth_{stack}(l_k, E'[e], \mu)$. Then, without loss of generality, assume $l_k.m(l_k') \rhd E''' \not\in E'$, and we get:
\begin{align*}
auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) &= auth_{store}(l_k, \mu) \cup pointsto(E'[e], \mu) & (\textsc{auth-stack-nocall})
\end{align*}
Unwinding $E'$, we have:

\noindent$auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l_k, \mu) \cup pointsto(E_k[l_{k-1}.m_{k-1}(l_{k-1}') \rhd E_{k-1}[l_{k-2}.m_{k-2}(l_{k-2}') \rhd \dots \rhd E_1[e]] \dots ], \mu) & (\textsc{auth-stack-nocall})
\end{align*}
where for $i = 1 \dots k$, $l'.m(l'') \rhd E'' \not\in E_i$.

Since for $i = 1 \dots k - 1$, $ l_i.m_i(l_i') \rhd E'' \in E'$, $l_i \mapsto \{ x \Rightarrow \overline{d_i} \}_{\keywadj{pure}}$,

\noindent$auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l_k, \mu) \bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) & (\textsc{pointsto-call-data}~\times~k)
\end{align*}
Similarly, in the final state, we have:
\begin{align*}
auth(l_k, E[l_k.m(l_k') \rhd E'[e']], \mu') &= auth_{store}(l_k, \mu') \bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu') \cup pointsto(e', \mu')
\end{align*}
Since we are considering small-step semantics, there was no change to $l$ and $E_i$s, and $auth_{store}(l_k, \mu') = auth_{store}(l_k, \mu)$ and $\bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu') = \bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu)$. Therefore,
\[
auth(l_k, E[l_k.m(l_k') \rhd E'[e']], \mu') = auth_{store}(l_k, \mu) \bigcup^{k}_{i = 1} \bigcup pointsto(subexps(E_i), \mu) \cup pointsto(e', \mu')
\]
Then, we get
\[
auth(l_k, E[l_k.m(l_k') \rhd E'[e']], \mu') \setminus auth(l_k, E[l_k.m(l_k') \rhd E'[e]], \mu) = pointsto(e', \mu') \setminus pointsto(e, \mu) = \{ l_0 \}
\]
This contradicts our assumption, and thus the assumption is wrong and the theorem holds.\qed
\end{proof}

\begin{lemma}
If $l.m(l') \rhd E' \not\in E$, then $pointsto(E[e], \mu) = pointsto(e, \mu) \bigcup pointsto(subexps(E), \mu)$.
\end{lemma}

\begin{proof}
Proof is by induction on $e$: we consider all possible types of $e$ and apply the $pointsto(e, \mu)$ rules.
\end{proof}

\begin{lemma}
If for all $l.m(l') \rhd E' \in E$, $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{pure}}$, then $pointsto(e, \mu) \in pointsto(E[e], \mu)$.
\end{lemma}

\begin{proof}
Consider $pointsto(E[e], \mu)$, and because all method callers are pure, \textsc{pointsto-call-data} will be applied ending with $pointsto(e, \mu)$.
\end{proof}

\begin{lemma}
If $l.m(l') \rhd E' \in E$; for all method callers $l''$ preceding $l.m(l') \rhd E'$ on the stack, $l'' \mapsto \{ x \Rightarrow \overline{d''} \}_{\keywadj{pure}}$; and $pointsto(e, \mu) \in pointsto(E[e], \mu)$, then $pointsto(e, \mu) \in auth_{stack}(l, E[e], \mu)$.
\end{lemma}

\begin{proof}
Consider $auth_{stack}(l, E[e], \mu)$, apply \textsc{auth-stack}, then use Lemma 9.
\end{proof}



\bibliographystyle{plain}
\bibliography{bibtex}

\end{document}