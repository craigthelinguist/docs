\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
 
%\pagestyle{headings}
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=15pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\textit{Case}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{%
  \if\relax\detokenize{#1}\relax
    \def\thiscase{}%
  \else
    \def\thiscase{~#1}%
  \fi
  \item
}

\begin{document}


\section{Modules}

\subsection{Syntax}

\[
\begin{array}{lll}
\begin{array}{lllr}
v & ::= & x & values \\
   & | & l & (run\mbox{-}time~form)\\
e & ::= & v & expressions \\
& | & \keywadj{new}_{s}(x \Rightarrow d) \\
& | & e.m(e)\\
& | & e.f \\
& | & e.f = e \\
& | & l.m(l) \rhd e & (run\mbox{-}time~form)\\
&&\\
s & ::= & \keyw{stateful} | ~\keyw{pure} \\
&&\\
\tau & ::= & \{ \sigma \}_{s} & types \\
&&\\
d & ::= & \epsilon & declarations \\
  & |   & \keyw{def} m(x:\tau):\tau = e; d \\
  & |   & \keyw{var} f:\tau = v; d \\
&&\\
\sigma & ::= & \epsilon & decl.~ types \\
       & |   & \keyw{def} m:\tau \rightarrow \tau; \sigma \\
       & |   & \keyw{var} f:\tau; \sigma \\
&&\\
\end{array}
& ~~~~~~
&
\begin{array}{lllr}
\Gamma & :: = & \varnothing & contexts\\
& | & \Gamma,~x : \tau\\
&&\\
\mu & :: = & \varnothing & store\\
& | & \mu,~l \mapsto \{ x \Rightarrow d \}_{s}\\
&&\\
\Sigma & :: = & \varnothing & store~type\\
& | & \Sigma,~l : \tau\\
&&\\
E & ::= & [~] & eval.~ contexts\\
  & |   & \keywadj{new}_{s}(x \Rightarrow D) \\
  & |   & E.m(e)\\
  & |   & l.m(E)\\
  & |   & E.f \\
  & |   & E.f = e \\
  & |   & l.f = E \\
  & |   & l.m(l) \rhd E \\
&&\\
D & ::= & [~] & decl.~eval.~ contexts\\
  & |   & \keyw{def} m(x:\tau):\tau = e; D \\
%  & |   & \keyw{var} f:\tau = E; d \\
  & |   & \keyw{var} f:\tau = l; D \\
&&\\
\end{array}
\end{array}
\]

Notes:

\begin{itemize}
\item The $s$ tag indicates whether an object is stateful (i.e. captures mutable state) or pure (i.e. captures no mutable state)
\item Example of how to initialize and use object declarations (and potentially encode modules):
\[
\keywadj{new}_{s}(x \Rightarrow \keyw{def} m(y : \tau) : \tau' = \keywadj{new}_{s}(x \Rightarrow \keyw{var} f_1 : \tau = y;~\keyw{var} f_2 : \tau = y;~\keyw{var} f_3 : \tau = y)).m(\keywadj{new}_{s} (x \Rightarrow \epsilon))
\]
which in memory looks like 
\[
l_2 \mapsto \{l_1,l_1,l_1\},~l_1 \mapsto \varnothing
\]
\end{itemize}


\newpage

\subsection{Semantics}

$\fbox{$\Gamma~|~\Sigma \vdash e : \tau$}$
\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
  {\Gamma~|~\Sigma \vdash x : \tau}
  {x : \tau \in \Gamma}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Loc)}]
  {\Gamma~|~\Sigma \vdash l : \tau}
  {l : \tau \in \Sigma}\\[5ex]

\infer[\textsc{(T-New)}]
	{\Gamma~|~\Sigma \vdash \keywadj{new}_{s}(x \Rightarrow d) : \{ \sigma \}_{s}}
	{\Gamma,~x : \{ \sigma \}_{s}~|~\Sigma \vdash d : \sigma} \\[5ex]

\infer[\textsc{(T-Meth)}]
	{\Gamma~|~\Sigma \vdash e.m(e_1) : \tau_2} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s  & \keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma & \Gamma~|~\Sigma \vdash e_1 : \tau_1}\\[5ex]

\infer[\textsc{(T-Field)}]
	{\Gamma~|~\Sigma \vdash  e.f : \tau} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s & \keyw{var}~ f : \tau \in \sigma}\\[5ex]
	
\infer[\textsc{(T-Assign)}]
	{\Gamma~|~\Sigma \vdash  e.f=e_1 : \tau_1} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s & \keyw{var}~ f:\tau_1 \in \sigma & \Gamma~|~\Sigma \vdash e_1 : \tau_1 }\\[5ex]

\infer[\textsc{(T-StackFrames)}]
	{\Gamma~|~\Sigma \vdash l.m(l_1) \rhd e : \tau_2}
	{\Gamma~|~\Sigma \vdash l : \{\sigma\}_s & \keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma & \Gamma~|~\Sigma \vdash l_1 : \tau_1 & \Gamma~|~\Sigma \vdash e : \tau_2} \\[5ex]

\infer[\textsc{(T-Sub)}]
  {\Gamma~|~\Sigma \vdash e : \tau_2}
  {\Gamma~|~\Sigma \vdash e : \tau_1 & \tau_1 <: \tau_2}\\[5ex]

\end{array}
\]

$\fbox{$\Gamma~|~\Sigma \vdash_s d : \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(DT-DefPure)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{pure}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\def\arraystretch{1.6}
  \begin{array}{c}
\Gamma_{stateful} = \{x : \{ \sigma \}_{\keyw{stateful}} ~|~ x : \{ \sigma \}_{\keyw{stateful}} \in \Gamma\} \\
\Gamma_{pure} = \Gamma \setminus \Gamma_{stateful}~~~~~~~~~~\Gamma_{pure}, x : \tau_1~|~\Sigma \vdash e : \tau_2~~~~~~~~~~\Gamma_{pure}~|~\Sigma \vdash_s d : \sigma
  \end{array}}\\[5ex]

\infer[\textsc{(DT-DefStateful)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\Gamma, x : \tau_1~|~\Sigma \vdash e : \tau_2 & \Gamma~|~\Sigma \vdash_s d : \sigma}\\[5ex]

\infer[\textsc{(DT-Var)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{var} f : \tau = v; d~:~\keyw{var} f : \tau; \sigma}
  {\Gamma~|~\Sigma \vdash v : \tau & \Gamma~|~\Sigma \vdash_s d : \sigma}\\[5ex]

\end{array}
\]

$\fbox{$\tau <: \tau'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl)}]
  {\tau <: \tau}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans)}]
  {\tau_1 <: \tau_3}
  {\tau_1 <: \tau_2 & \tau_2 <: \tau_3}\\[5ex]

\infer[\textsc{(S-State)}]
  {\{ \sigma \}_{\keyw{pure}} <: \{ \sigma' \}_{\keyw{stateful}}}
  {\sigma <: \sigma'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(S-Obj)}]
  {\{ \sigma \}_{s} <: \{ \sigma' \}_{s}}
  {\sigma <: \sigma'}\\[5ex]  

\end{array}
\]

$\fbox{$\sigma <: \sigma'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl)}]
  {\sigma <: \sigma}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans)}]
  {\sigma_1 <: \sigma_3}
  {\sigma_1 <: \sigma_2 & \sigma_2 <: \sigma_3}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Eps)}]
  {\sigma <: \epsilon}
  {}\\[5ex]

\infer[\textsc{(S-Def)}]
  {\keyw{def} m:\tau_1 \rightarrow \tau_2; \sigma <: \keyw{def} m:\tau_1' \rightarrow \tau_2'; \sigma'}
  {\tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \sigma <: \sigma'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(S-Var)}]
  {\keyw{var} f:\tau; \sigma <: \keyw{var} f:\tau; \sigma'}
  {\sigma <: \sigma'}\\[5ex]  

\end{array}
\]

$\fbox{$\mu : \Sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(T-StoreEmpty)}]
  {\varnothing : \varnothing}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Store)}]
  {\mu, l \mapsto \{ x \Rightarrow d \}~:~\Sigma,~l : \{ \sigma \}_s}
  {\mu : \Sigma & x : \{ \sigma \}_s~|~\Sigma \vdash d : \sigma}\\[5ex]

\end{array}
\]

$\fbox{$E[e]~|~\mu \longrightarrow E[e']~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Congruence)}]
  {E[e]~|~\mu \longrightarrow E[e']~|~\mu'}
  {e~|~\mu \longrightarrow e'~|~\mu'}\\[5ex]  
\end{array}
\]


$\fbox{$e~|~\mu \longrightarrow e'~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-New)}]
  {\keywadj{new}_{s}(x \Rightarrow d)~|~\mu \longrightarrow l~|~\mu, l \mapsto \{ x \Rightarrow d \}_{s}}
  {l \not\in dom(\mu)}\\[5ex]
  
\infer[\textsc{(E-Meth)}]
  {l.m(l_1)~|~\mu \longrightarrow l.m(l_1) \rhd [l_1/y][l/x]e~|~\mu}
  {l \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{def} m(y : \tau_1) : \tau = e \in d}\\[5ex]

\infer[\textsc{(E-Field)}]
  {l.f~|~\mu \longrightarrow l_1~|~\mu}
  {l \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{var} f:\tau = l_1 \in d}\\[5ex]

\infer[\textsc{(E-Assign)}]
  {l.f = l_1~|~\mu \longrightarrow l_1~|~\mu}
  {l \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{var} f:\tau = l_1 \in d}\\[5ex]

\infer[\textsc{(E-StackFrame)}]
  {l.m(l_1) \rhd l_2~|~\mu \longrightarrow l_2~|~\mu'}
  {}\\[5ex]
  
\end{array}
\]

\newpage

\subsection{Type Safety}


\begin{theorem}[Preservation]
If
\begin{enumerate}
\item $\Gamma~|~\Sigma \vdash e : \tau$,
\item $\Gamma~|~\varnothing \vdash \mu : \Sigma$, and
\item $e~|~\mu \rightarrow e'~|~\mu'$,
\end{enumerate}
then
\begin{enumerate}
\item $\exists \Sigma' \supseteq \Sigma$,
\item $\Gamma~|~\varnothing \vdash \mu' : \Sigma'$,
\item $\tau'<:\tau$, and
\item $\Gamma~|~\Sigma' \vdash e' : \tau'$.
\end{enumerate}

\end{theorem}

Before proving the preservation theorem, we define the lemma on preservation of types under substitution. Such a lemma enables us to show that substituting terms in a well-typed expression preserves the typing:


\begin{lemma}[Preservation of types under substitution]
If $\Gamma,~y : \tau'~|~\Sigma \vdash e : \tau$ and $\Gamma~|~\varnothing \vdash z : \tau'$, then $\Gamma~|~\Sigma \vdash [z/y]e : \tau$.
\end{lemma}

\begin{proof} The proof is by induction on a derivation of the statement $\Gamma,~y : \tau' \vdash e : \tau$. For a given derivation, we proceed by cases on the final typing rule used in the proof:

\begin{pcases}
\pcase[\textsc{T-Var}]
$e = x$ and $x : \tau \in (\Gamma,~y : \tau')$

There are two sub-cases to consider, depending on whether $x$ is $y$ or another variable. If $x = y$, then $[z/y]x = z$. The required result is then $\Gamma~|~\varnothing \vdash z : \tau'$, which is among the assumptions of the lemma. Otherwise, $[z/y]x = x$, and the desired result is immediate.
\\
\pcase[\textsc{T-Loc}] For the purposes of the lemma, this case is invalid since we cannot make substitutions in a location.
\\
\pcase[\textsc{T-New}]
$e = \keywadj{new}_{s}(x \Rightarrow d)$ and $\Gamma,~x : \{ \sigma \}_{s},~y : \tau'~|~\Sigma \vdash d : \sigma$
\\
\pcase[\textsc{T-Meth}]
$e = e_1.m(e_2)$ and $\Gamma,~y : \tau_3~|~\Sigma \vdash e_1 : \{\sigma\}_s$, $\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \sigma$, $\Gamma,~y : \tau_3~|~\Sigma \vdash e_2 : \tau_2$

By the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e_1 : \{\sigma\}_s$, $\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \sigma$, and $\Gamma~|~\Sigma \vdash [z/y]e_2 : \tau_2$. Then, by \textsc{T-Meth}, $\Gamma~|~\Sigma \vdash [z/y]e_1.m([z/y]e_2) : \tau_1$, i.e., $\Gamma~|~\Sigma \vdash [z/y](e_1.m(e_2)) : \tau_1$.
\\
\pcase[\textsc{T-Field}]
$e = e_1.f$ and $\Gamma,~y : \tau'~|~\Sigma \vdash e_1 : \{\sigma\}_s$, $\keyw{var}~ f : \tau \in \sigma$

By the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e_1 : \{\sigma\}_s$ and $\keyw{var}~ f : \tau \in \sigma$. Then, by \textsc{T-Field}, $\Gamma~|~\Sigma \vdash ([z/y]e_1).f : \tau_2$, i.e., $\Gamma~|~\Sigma \vdash [z/y](e_1.f) : \tau_2$.
\\
\pcase[\textsc{T-Assign}]
$e = e_1.f=e_2$ and $\Gamma,~y : \tau_3~|~\Sigma \vdash e_1 : \{\sigma\}_s$, $\keyw{var}~ f:\tau_2 \in \sigma$, $\Gamma,~y : \tau_3~|~\Sigma \vdash e_2 : \tau_2$

By the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e_1 : \{\sigma\}_s$, $\keyw{var}~ f:\tau_2 \in \sigma$, and $\Gamma~|~\Sigma \vdash [z/y]e_2 : \tau_2$. Then, by \textsc{T-Assign}, $\Gamma~|~\Sigma \vdash  [z/y]e_1.f = [z/y]e_2 : \tau_2$, i.e., $\Gamma~|~\Sigma \vdash [z/y](e_1.f=e_2) : \tau_2$.
\\
\pcase[\textsc{T-StackFrame}]
$e = l.m(l_1) \rhd e_2$ and $\Gamma,~y : \tau_3~|~\Sigma \vdash l : \{\sigma\}_s$, $\keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma$, $\Gamma,~y : \tau_3~|~\Sigma \vdash l_1 : \tau_1$, $\Gamma,~y : \tau_3~|~\Sigma \vdash e_2 : \tau_2$

Locations are not affected by the substitution, and by the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e_2 : \tau_2$. Then, by \textsc{T-StackFrame}, $\Gamma~|~\Sigma \vdash l.m(l_1) \rhd [z/y]e : \tau_2$, i.e., $\Gamma~|~\Sigma \vdash [z/y](l.m(l_1) \rhd e) : \tau_2$.
\\
\pcase[\textsc{T-Sub}]
$e = e'$ and $\Gamma,~y | \tau_3~|~\Sigma \vdash e' : \tau_1$, $\tau_1 <: \tau_2$

By the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e' : \tau_1$, $\tau_1 <: \tau_2$. Then, by \textsc{T-Sub}, $\Gamma~|~\Sigma \vdash [y/z]e' : \tau_2$.
\end{pcases}


\end{proof}



\begin{theorem}[Progress]
If $\Gamma~|~\Sigma \vdash e : \tau$, then either
\begin{enumerate}
\item $e$ is a value or
\item $\forall \mu$ such that $\Gamma~|~\varnothing \vdash \mu : \Sigma$,
   $\exists e', \mu'$ such that $e~|~\mu \rightarrow e'~|~\mu'$.
\end{enumerate}
\end{theorem}
\begin{proof} The proof is by induction on the derivation of $\Gamma~|~\Sigma \vdash e : \tau$, with a case analysis on the last typing rule used. The cases when $e$ is a variable (\textsc{T-Var}) or a location (\textsc{T-Loc}) are immediate, since in that case $e$ is a value. For the other cases, we argue as follows:

\begin{pcases}
\pcase[\textsc{T-New}]
$e = \keywadj{new}_{s}(x \Rightarrow d)$ and $\Gamma,~x : \{ \sigma \}_{s}~|~\Sigma \vdash d : \sigma$

By the induction hypothesis, either $d$ is a value or else it can make a step of evaluation. If $d$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If $d$ is a value, then the rule \textsc{E-New} applies to $e$, and $e$ is a value (a location).
\\
\pcase[\textsc{T-Meth}]
$e = e_1.m(e_2)$ and $\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s$, $\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \sigma$, $\Gamma~|~\Sigma \vdash e_2 : \tau_2$

By the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation, and likewise $e_2$. If $e_1$ can take a step or if $e_1$ is a value and $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If both $e_1$ and $e_2$ are values, then the rule \textsc{E-Meth} applies to $e$, and $e$ can take a step.
\\
\pcase[\textsc{T-Field}]
$e = e_1.f$ and $\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s$, $\keyw{var}~ f : \tau \in \sigma$

By the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation. If $e_1$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If $e_1$ is a value, then the rule \textsc{E-Field} applies to $e$, and $e$ is a value (a location).
\\
\pcase[\textsc{T-Assign}]
$e = e_1.f=e_2$ and $\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s$, $\keyw{var}~ f:\tau_2 \in \sigma$, $\Gamma~|~\Sigma \vdash e_2 : \tau_2$

By the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation, and likewise $e_2$. If $e_1$ can take a step or if $e_1$ is a value and $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If both $e_1$ and $e_2$ are values, then the rule \textsc{E-Assign} applies to $e$, and $e$ is a value.
\\
\pcase[\textsc{T-StackFrame}]
$e = l.m(l_1) \rhd e_2$ and $\Gamma~|~\Sigma \vdash l : \{\sigma\}_s$, $\keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma$, $\Gamma~|~\Sigma \vdash l_1 : \tau_1$, $\Gamma~|~\Sigma \vdash e_2 : \tau_2$

By the induction hypothesis, either $e_2$ is a value or else it can make a step of evaluation. If $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If $e_2$ is a value, then the rule \textsc{E-StackFrame} applies to $e$, and $e$ is a value (a location).
\\
\pcase[\textsc{T-Sub}]
The rule does not change the expression: the expression stays the same and only the type of it changes. Then, whether $e$ in the conclusion (and the premise) is a value or can take a step has to be inferred from the preceding derivation, all possibilities of which we have already considered above.

\end{pcases}

\end{proof}

\newpage

\subsection{Authority}

\[
\begin{array}{c}
\infer[\textsc{(auth-config)}]
  {auth(l,\mu \circ e) = auth_{store}(l,\mu) \cup auth_{stack}(l,e,\mu)}
  {}\\[5ex]

\infer[\textsc{(auth-store)}]
  {auth_{store}(l,\mu) = pointsto(d,\mu)}
  {\mu(l) = \{ x \Rightarrow d \}_{s}}\\[5ex]
  
\infer[\textsc{(auth-stack)}]
  {auth_{stack}(l,E[l.m(l') \rhd e'],\mu) = pointsto(e',\mu) \cup auth_{stack}(l,e',\mu)}
  {l.m(l'') \rhd E' \not\in E}\\[5ex]
  
\infer[\textsc{(auth-stack-nocall)}]
  {auth_{stack}(l,e,\mu) = \varnothing}
  {l.m(l') \rhd e' \not\in e}\\[5ex]
  
\infer[\textsc{(pointsto-def)}]
  {pointsto(\keyw{def} m(x:\tau):\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-var)}]
  {pointsto(\keyw{var} f:\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-principal)}]
  {pointsto(l,\mu) = \{ l \}}
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-data)}]
  {pointsto(l,\mu) = \varnothing }
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{pure}}\\[5ex]

\infer[\textsc{(pointsto-call-principal)}]
  {pointsto(l.m(l') \rhd e,\mu) = \{l\} }
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-call-data)}]
  {pointsto(l.m(l') \rhd e,\mu) = pointsto(e,\mu)}
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{pure}}\\[5ex]
  
\infer[\textsc{(pointsto-new)}]
  {pointsto(\keywadj{new}_{s}(x \Rightarrow d),\mu) = pointsto(d,\mu) }
  {}\\[5ex]
  
\infer[\textsc{(pointsto-otherexp)}]
  {pointsto(e,\mu) = pointsto(subexprs(e),\mu) }
  {\textit{when $e$ is not one of the expression forms defined above}}\\[5ex]

\end{array}
\]

note: the last rule is a shorthand; the rest of the \textit{pointsto} rules for expressions are just congruence - look inside the e's

To Do:

\begin{itemize}
\item add a textual description to give intuition
\item write some examples (all but Darya will do)
\end{itemize}

\newpage

\subsection{Theory}

\textbf{Theorem [Authority Safety].}  If $\Sigma \vdash \mu$, $\bullet, \Sigma \vdash e : \tau$, and $\mu \circ e \stepsto \mu' \circ e'$ then $\forall l \in domain(\mu)$ if $auth(l,\mu' \circ e') \supset auth(l,\mu \circ e)$ then one of the following holds:

\begin{itemize}
  \item \textbf{Creation.} $e = E[\keywadj{new}_p(x \Rightarrow d)]$, $e' = E[l']$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ l' \}$.  \textit{check that the creator was $l$}
  \item \textbf{Call.} $e = E[l.m(l')]$, $e' = E[l.m(l') \rhd e]$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ pointsto(l',\mu) \}$  \textit{check that the caller previously had the authority that $l$ gained}
  \item \textbf{Return.}
\end{itemize}

Here, the Authority Safety theorem follows the definition in Maffeis et al. 2010.


\end{document}