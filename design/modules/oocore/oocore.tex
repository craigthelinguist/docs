\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
 
%\pagestyle{headings}
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=15pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}

\begin{document}


\section{Modules}

\subsection{Syntax}

\[
\begin{array}{lll}
\begin{array}{lllr}
v & ::= & x & value \\
   & | & l \\
e & ::= & v & expressions \\
& | & \keywadj{new}_{s}(x \Rightarrow d) \\
& | & e.m(e)\\
& | & e.f \\
& | & e.f = e \\
& | & l.m(l) \rhd e & run\mbox{-}time~forms\\
&&\\
s & ::= & \keyw{stateful} | ~\keyw{pure} \\
&&\\
\tau & ::= & \{ \sigma \}_{s} & types \\
&&\\
\sigma & ::= & \epsilon & decl.~ types \\
       & |   & \keyw{def} m:\tau \rightarrow \tau; \sigma \\
       & |   & \keyw{var} f:\tau; \sigma \\
&&\\
\Gamma & :: = & \varnothing & contexts\\
& | & \Gamma,~x : \tau\\
\end{array}
& ~~~~~~
&
\begin{array}{lllr}
\mu & :: = & \varnothing & store\\
& | & \mu,~l \mapsto \{ x \Rightarrow d \}_{s}\\
&&\\
d & ::= & \epsilon & declarations \\
  & |   & \keyw{def} m(x:\tau):\tau = e; d \\
  & |   & \keyw{var} f:\tau = v; d \\
&&\\
\Sigma & :: = & \varnothing & store~type\\
& | & \Sigma,~l : \tau\\
&&\\
E & ::= & \Diamond & eval.~ contexts\\
  & |   & \keywadj{new}_{s}(x \Rightarrow D) \\
  & |   & E.m(e)\\
  & |   & l.m(E)\\
  & |   & E.f \\
  & |   & E.f = e \\
  & |   & l.f = E \\
  & |   & l.m(l) \rhd E \\
&&\\
D & ::= & \keyw{def} m(x:\tau):\tau = e; D & decl.~ contexts\\
  & |   & \keyw{var} f:\tau = E; d \\
  & |   & \keyw{var} f:\tau = l; D \\
&&\\
\end{array}
\end{array}
\]

Notes:

\begin{itemize}
\item The $s$ tag indicates whether an object is stateful (i.e. captures mutable state) or pure (i.e. captures no mutable state)
\end{itemize}


\newpage

\subsection{Semantics}

$\fbox{$\Gamma~|~\Sigma \vdash e : \tau$}$
\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
  {\Gamma~|~\Sigma \vdash x : \tau}
  {x : \tau \in \Gamma}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-New)}]
	{\Gamma~|~\Sigma \vdash\keywadj{new}_{s}(x \Rightarrow d) : \{ \sigma \}_{s}}
	{\Gamma,~x : \{ \sigma \}_{s}~|~\Sigma \vdash d : \sigma} \\[5ex]

\infer[\textsc{(T-Meth)}]
	{\Gamma~|~\Sigma \vdash  e.m(e_2) : \tau_1} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s  & \keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \sigma & \Gamma~|~\Sigma \vdash e_2 : \tau_2}\\[5ex]

\infer[\textsc{(T-Field)}]
	{\Gamma~|~\Sigma \vdash  e.f : \tau} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s & \keyw{var}~ f : \tau \in \sigma }\\[5ex]
	
\infer[\textsc{(T-Assign)}]
	{\Gamma~|~\Sigma \vdash  e.f=e_1 : \tau_1} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s & \keyw{var}~ f:\tau_1 \in \sigma & \Gamma~|~\Sigma \vdash e_1 : \tau_1 }%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Loc)}]
  {\Gamma~|~\Sigma \vdash l : \tau}
  {l : \tau \in \Sigma}\\[5ex]

\infer[\textsc{(T-StackFrames)}]
	{\Gamma~|~\Sigma \vdash l.m(l_1) \rhd e : \tau_2}
	{\Gamma~|~\Sigma \vdash l_1 : \tau_1 & \Gamma~|~\Sigma \vdash l : \{\sigma\}_s & \keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma & \Gamma~|~\Sigma \vdash e : \tau_2} \\[5ex]

\infer[\textsc{(T-Sub)}]
  {\Gamma~|~\Sigma \vdash e : \tau_2}
  {\Gamma~|~\Sigma \vdash e : \tau_1 & \tau_1 <: \tau_2}\\[5ex]

\end{array}
\]

$\fbox{$\mu : \Sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(T-StoreEmpty)}]
  {\varnothing : \varnothing}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Store)}]
  {\mu, l \mapsto \{ x \Rightarrow d \} : \Sigma, l : \{ \sigma \}_s}
  {\mu : \Sigma & x : \{ \sigma \}_s~|~\Sigma \vdash d : \sigma}\\[5ex]

\end{array}
\]

$\fbox{$\Gamma~|~\Sigma \vdash_s d : \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(DT-DefPure)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{pure}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\def\arraystretch{1.6}
  \begin{array}{c}
\Gamma_{stateful} = \{x : \{ \sigma \}_{\keyw{stateful}} ~|~ x : \{ \sigma \}_{\keyw{stateful}} \in \Gamma\} \\
\Gamma' = \Gamma \setminus \Gamma_{stateful}~~~~~~~~~~\Gamma', x : \tau_1~|~\Sigma \vdash e : \tau_2~~~~~~~~~~\Gamma'~|~\Sigma \vdash_s d : \sigma
  \end{array}}\\[5ex]

\infer[\textsc{(DT-DefStateful)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\Gamma, x : \tau_1~|~\Sigma \vdash e : \tau_2 & \Gamma~|~\Sigma \vdash_s d : \sigma}\\[5ex]

\infer[\textsc{(DT-Var)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{var} f : \tau = e; d~:~\keyw{var} f : \tau; \sigma}
  {\Gamma~|~\Sigma \vdash e : \tau & \Gamma~|~\Sigma \vdash_s d : \sigma}\\[5ex]

\end{array}
\]

$\fbox{$\tau <: \tau'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl)}]
  {\tau <: \tau}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans)}]
  {\tau_1 <: \tau_3}
  {\tau_1 <: \tau_2 & \tau_2 <: \tau_3}\\[5ex]

\infer[\textsc{(S-State)}]
  {\{ \sigma \}_{\keyw{pure}} <: \{ \sigma' \}_{\keyw{stateful}}}
  {\sigma <: \sigma'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(S-Obj)}]
  {\{ \sigma \}_{s} <: \{ \sigma' \}_{s}}
  {\sigma <: \sigma'}\\[5ex]  

\end{array}
\]

$\fbox{$\sigma <: \sigma'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl)}]
  {\sigma <: \sigma}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans)}]
  {\sigma_1 <: \sigma_3}
  {\sigma_1 <: \sigma_2 & \sigma_2 <: \sigma_3}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Eps)}]
  {\sigma <: \epsilon}
  {}\\[5ex]

\infer[\textsc{(S-Def)}]
  {\keyw{def} m:\tau_1 \rightarrow \tau_2; \sigma <: \keyw{def} m:\tau_1' \rightarrow \tau_2'; \sigma'}
  {\tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \sigma <: \sigma'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(S-Var)}]
  {\keyw{var} f:\tau; \sigma <: \keyw{var} f:\tau; \sigma'}
  {\sigma <: \sigma'}\\[5ex]  

\end{array}
\]

$\fbox{$E[e]~|~\mu \longrightarrow E[e']~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Congruence)}]
  {E[e]~|~\mu \longrightarrow E[e']~|~\mu'}
  {e~|~\mu \longrightarrow e'~|~\mu'}\\[5ex]  
\end{array}
\]


$\fbox{$e~|~\mu \longrightarrow e'~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-New)}]
  {\keywadj{new}_{s}(x \Rightarrow d)~|~\mu \longrightarrow l~|~\mu, l \mapsto \{ x \Rightarrow d \}_{s}}
  {l \not\in \mu}\\[5ex]
  
\infer[\textsc{(E-Meth)}]
  {l_1.m(l_2)~|~\mu \longrightarrow l_1.m(l_2) \rhd [l_2/x][l_1/x]e~|~\mu}
  {l_1 \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{def} m(x : \tau) : \tau = e \in d}\\[5ex]

\infer[\textsc{(E-Field)}]
  {l_1.f~|~\mu \longrightarrow l_2~|~\mu}
  {l_1 \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{var} f:\tau = l_2 \in d}\\[5ex]

\infer[\textsc{(E-Assign)}]
  {l_1.f = v~|~\mu \longrightarrow l_1.f = [l_1/x]v~|~\mu'}
  {l_1 \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{var} f:\tau = v \in d}\\[5ex]

\infer[\textsc{(E-StackFrame)}]
  {l_1.m(l_2) \rhd l_3~|~\mu \longrightarrow l_3~|~\mu'}
  {}\\[5ex]
  
\end{array}
\]

\newpage

$\fbox{$e~|~\mu \longrightarrow e'~|~\mu'$ \textbf{(without evaluation context)}}$
\[
\begin{array}{c}
\infer[\textsc{(E-New1)}]
  {\keywadj{new}_{s}(x \Rightarrow d)~|~\mu \longrightarrow \keywadj{new}_{s}(x \Rightarrow d')~|~\mu'}
  {d~|~\mu \longrightarrow d'~|~\mu'}\\[5ex]

\infer[\textsc{(E-New2)}]
  {\keywadj{new}_{s}(l)~|~\mu \longrightarrow [l/x]d~|~\mu'}
  {l \mapsto \{ x \Rightarrow d \}_{s} \in \mu}\\[5ex]

\infer[\textsc{(E-Meth1)}]
  {e_1.m(e_2)~|~\mu \longrightarrow e_1'.m(e_2)~|~\mu'}
  {e_1~|~\mu \longrightarrow e_1'~|~\mu'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(E-Meth2)}]
  {l_1.m(e_2)~|~\mu \longrightarrow l_1.m(e_2')~|~\mu'}
  {e_2~|~\mu \longrightarrow e_2'~|~\mu'}\\[5ex]
  
\infer[\textsc{(E-Meth3)}]
  {l_1.m(l_2)~|~\mu \longrightarrow l_1.m(l_2) \rhd [l_2/x][l_1/x]e~|~\mu'}
  {l_1 \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{def} m(x : \tau) : \tau = e \in d}\\[5ex]

\infer[\textsc{(E-Field1)}]
  {e.f~|~\mu \longrightarrow e'.f~|~\mu'}
  {e~|~\mu \longrightarrow e'~|~\mu'}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(E-Field2)}]
  {l_1.f~|~\mu \longrightarrow l_2~|~\mu'}
  {l_1 \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{var} f:\tau = l_2 \in d}\\[5ex]

\infer[\textsc{(E-Assign1)}]
  {e_1.f = e_2~|~\mu \longrightarrow e_1'.f = e_2~|~\mu'}
  {e_1~|~\mu \longrightarrow e_1'~|~\mu'}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(E-Assign2)}]
  {l_1.f = e_2~|~\mu \longrightarrow l_1.f = e_2'~|~\mu'}
  {e_2~|~\mu \longrightarrow e_2'~|~\mu'}\\[5ex]

\infer[\textsc{(E-Assign3)}]
  {l_1.f = e~|~\mu \longrightarrow l_1.f = [l_1/x]e~|~\mu'}
  {l_1 \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{var} f:\tau = e \in d}\\[5ex]

\infer[\textsc{(E-StackFrame1)}]
  {l_1.m(l_2) \rhd e~|~\mu \longrightarrow l_1.m(l_2) \rhd e'~|~\mu'}
  {e~|~\mu \longrightarrow e'~|~\mu}\\[5ex]

\infer[\textsc{(E-StackFrame2)}]
  {l_1.m(l_2) \rhd l_3~|~\mu \longrightarrow l_3~|~\mu'}
  {}\\[5ex]
  
\end{array}
\]

$\fbox{$d~|~\mu \longrightarrow d'~|~\mu'$ \textbf{(without evaluation context)}}$
\[
\begin{array}{c}
\infer[\textsc{(E-Def)}]
  {\keyw{def} m(x:\tau):\tau = e; d~|~\mu \longrightarrow \keyw{def} m(x:\tau):\tau = e; d'~|~\mu'}
  {d~|~\mu \longrightarrow d'~|~\mu'}\\[5ex] 

\infer[\textsc{(E-Var1)}]
  {\keyw{var} f:\tau = e; d~|~\mu \longrightarrow \keyw{var} f:\tau = e'; d~|~\mu'}
  {e~|~\mu \longrightarrow e'~|~\mu'}\\[5ex] 

\infer[\textsc{(E-Var2)}]
  {\keyw{var} f:\tau = e; d~|~\mu \longrightarrow \keyw{var} f:\tau = e; d'~|~\mu'}
  {d~|~\mu \longrightarrow d'~|~\mu'}\\[5ex] 
\end{array}
\]


\newpage

\subsection{Authority}

\[
\begin{array}{c}
\infer[\textsc{(auth-config)}]
  {auth(l,\mu \circ e) = auth_{store}(l,\mu) \cup auth_{stack}(l,e,\mu)}
  {}\\[5ex]

\infer[\textsc{(auth-store)}]
  {auth_{store}(l,\mu) = pointsto(d,\mu)}
  {\mu(l) = \{ x \Rightarrow d \}_{s}}\\[5ex]
  
\infer[\textsc{(auth-stack)}]
  {auth_{stack}(l,E[l.m(l') \rhd e'],\mu) = pointsto(e',\mu) \cup auth_{stack}(l,e',\mu)}
  {l.m(l'') \rhd E' \not\in E}\\[5ex]
  
\infer[\textsc{(auth-stack-nocall)}]
  {auth_{stack}(l,e,\mu) = \varnothing}
  {l.m(l') \rhd e' \not\in e}\\[5ex]
  
\infer[\textsc{(pointsto-def)}]
  {pointsto(\keyw{def} m(x:\tau):\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-var)}]
  {pointsto(\keyw{var} f:\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-principal)}]
  {pointsto(l,\mu) = \{ l \}}
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-data)}]
  {pointsto(l,\mu) = \varnothing }
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{pure}}\\[5ex]

\infer[\textsc{(pointsto-call-principal)}]
  {pointsto(l.m(l') \rhd e,\mu) = \{l\} }
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-call-data)}]
  {pointsto(l.m(l') \rhd e,\mu) = pointsto(e,\mu)}
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{pure}}\\[5ex]
  
\infer[\textsc{(pointsto-new)}]
  {pointsto(\keywadj{new}_{s}(x \Rightarrow d),\mu) = pointsto(d,\mu) }
  {}\\[5ex]
  
\infer[\textsc{(pointsto-otherexp)}]
  {pointsto(e,\mu) = pointsto(subexprs(e),\mu) }
  {\textit{when $e$ is not one of the expression forms defined above}}\\[5ex]

\end{array}
\]

note: the last rule is a shorthand; the rest of the \textit{pointsto} rules for expressions are just congruence - look inside the e's

To Do:

\begin{itemize}
\item add a textual description to give intuition
\item write some examples (all but Darya will do)
\end{itemize}

\newpage

\subsection{Theory}

\textbf{Theorem [Authority Safety].}  If $\Sigma \vdash \mu$, $\bullet, \Sigma \vdash e : \tau$, and $\mu \circ e \stepsto \mu' \circ e'$ then $\forall l \in domain(\mu)$ if $auth(l,\mu' \circ e') \supset auth(l,\mu \circ e)$ then one of the following holds:

\begin{itemize}
  \item \textbf{Creation.} $e = E[\keywadj{new}_p(x \Rightarrow d)]$, $e' = E[l']$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ l' \}$.  \textit{check that the creator was $l$}
  \item \textbf{Call.} $e = E[l.m(l')]$, $e' = E[l.m(l') \rhd e]$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ pointsto(l',\mu) \}$  \textit{check that the caller previously had the authority that $l$ gained}
  \item \textbf{Return.}
\end{itemize}

Here, the Authority Safety theorem follows the definition in Maffeis et al. 2010.


\end{document}