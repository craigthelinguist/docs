\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=15pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}

\begin{document}


\section{Modules}

\subsection{Syntax}

\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expressions \\
& | & \keywadj{new}_{s}(x \Rightarrow d) \\
& | & e.m(e)\\
& | & e.f \\
& | & e.f = e \\
& | & l & run\mbox{-}time~forms\\
& | & l.m(l) \rhd e \\
&&\\
s & ::= & \keyw{stateful} | ~\keyw{pure} \\
&&\\
d & ::= & \epsilon & declarations \\
  & |   & \keyw{def} m(x:\tau):\tau = e; d \\
  & |   & \keyw{var} f:\tau = e; d \\
&&\\
\tau & ::= & \{ x \Rightarrow \sigma \}_{s} & types \\
&&\\
\sigma & ::= & \epsilon & decl.~ types \\
       & |   & \keyw{def} m:\tau \rightarrow \tau; \sigma \\
       & |   & \keyw{var} f:\tau; \sigma \\
&&\\
\Gamma & :: = & \varnothing & contexts\\
& | & \Gamma,~x : \tau\\
\end{array}
& ~~~~~~
&
\begin{array}{lllr}
\mu & :: = & \varnothing & store\\
& | & \mu,~l \mapsto \{ x \Rightarrow d_v \}_{s}\\
&&\\
d_v & ::= & \epsilon & decl.~ values \\
  & |   & \keyw{def} m(x:\tau):\tau = e; d_v \\
  & |   & \keyw{var} f:\tau = l; d_v \\
&&\\
\Sigma & :: = & \varnothing & store~type\\
& | & \Sigma,~l : \tau\\
&&\\
E & ::= & \Diamond & eval.~ contexts\\
  & |   & \keywadj{new}_{s}(x \Rightarrow D) \\
  & |   & E.m(e)\\
  & |   & l.m(E)\\
  & |   & E.f \\
  & |   & E.f = e \\
  & |   & l.f = E \\
  & |   & l.m(l) \rhd E \\
&&\\
D & ::= & \keyw{def} m(x:\tau):\tau = e; D & decl.~ contexts\\
  & |   & \keyw{var} f:\tau = E; d \\
  & |   & \keyw{var} f:\tau = l; D \\
&&\\
\end{array}
\end{array}
\]

Notes:

\begin{itemize}
\item The $s$ tag indicates whether an object is stateful (i.e. captures mutable state) or pure (i.e. captures no mutable state)
\end{itemize}

To Do:

\begin{itemize}
\item either take out $x \Rightarrow$ or add type members
\end{itemize}

\newpage

\subsection{Semantics}

$\fbox{$\Gamma~|~\Sigma \vdash e : \tau$}$
\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
  {\Gamma~|~\Sigma \vdash x : \tau}
  {x : \tau \in \Gamma}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-New)}]
	{\Gamma, x : \tau~|~\Sigma \vdash\keywadj{new}_{s}(x \Rightarrow d) : \{ x \Rightarrow \sigma \}_{s}}
	{\Gamma~|~\Sigma \vdash d : \sigma} \\[5ex]

\infer[\textsc{(T-MethApp)}]
	{\Gamma~|~\Sigma \vdash  e.m(e_2) : \tau_1} 
	{\Gamma~|~\Sigma \vdash e : \tau & \Gamma~|~\Sigma \vdash e_2 : \tau_2 & \tau=\{..., \keyw{def}~ m : \tau_2 \rightarrow \tau_1, ... \} }\\[5ex]

\infer[\textsc{(T-Field)}]
	{\Gamma~|~\Sigma \vdash  e.f : \tau_1} 
	{\Gamma~|~\Sigma \vdash e : \tau & \tau= \{\keyw{var}~ f : \tau_1,... \} }%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Loc)}]
  {\Gamma~|~\Sigma \vdash l : \tau_1}
  {\Sigma(l) = \tau_1}\\[5ex]

\infer[\textsc{(T-Assign)}]
	{\Gamma~|~\Sigma \vdash  e.f=e_1 : \tau_1} 
	{\Gamma~|~\Sigma \vdash e : \tau & \tau = \{\keyw{var}~ f:\tau_1,... \} & \Gamma~|~\Sigma \vdash e_1 : \tau_1 }\\[5ex]

\infer[\textsc{(T-StackFrames)}]
	{\Gamma~|~\Sigma \vdash l.m(l_1) \rhd e : \tau_2}
	{\Gamma~|~\Sigma \vdash l_1 : \tau_1 & \Gamma~|~\Sigma \vdash l : \tau & \tau = \{..., \keyw{def}~ m : \tau_1 \rightarrow \tau_2, ... \}} \\[5ex]

\infer[\textsc{(DT-Def)}]
  {\Gamma~|~\Sigma \vdash \keyw{def} m(x : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\Gamma~|~\Sigma \vdash e_2 : \tau_1 & \Gamma~|~\Sigma \vdash  e_1.m(e_2) : \tau_2}\\[5ex]

\infer[\textsc{(DT-Var)}]
  {\Gamma~|~\Sigma \vdash \keyw{var} f : \tau = e; d~:~\keyw{var} f : \tau; \sigma}
  {\Gamma~|~\Sigma \vdash e : \tau}\\[5ex]

\infer[\textsc{(T-Sub)}]
  {\Gamma~|~\Sigma \vdash e : \tau_2}
  {\Gamma~|~\Sigma \vdash e : \tau_1 & \tau_1 :> \tau_2}\\[5ex]

\end{array}
\]

$\fbox{$S <: T$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl)}]
  {S <: S}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans)}]
  {S <: T}
  {S <: U & U <: T}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Top)}]
  {S <: \keyw{Top}}
  {}\\[5ex]  

\end{array}
\]


$\fbox{$e~|~\mu \longrightarrow e'~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Def1)}]
  {e_1.m(e_2)~|~\mu \longrightarrow e_1'.m(e_2)~|~\mu'}
  {e_1~|~\mu \longrightarrow e_1'~|~\mu'}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(E-Def2)}]
  {e_1.m(e_2)~|~\mu \longrightarrow e_1.m(e_2')~|~\mu'}
  {e_2~|~\mu \longrightarrow e_2'~|~\mu'}\\[5ex]

\infer[\textsc{(E-Field)}]
  {e.f~|~\mu \longrightarrow e'.f~|~\mu'}
  {e~|~\mu \longrightarrow e'~|~\mu'}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(E-Assign)}]
  {e.f = e_1~|~\mu \longrightarrow e.f = e_1'~|~\mu'}
  {e_1~|~\mu \longrightarrow e_1'~|~\mu'}\\[5ex]

\end{array}
\]

\newpage

\subsection{Authority}

\[
\begin{array}{c}
\infer[\textsc{(auth-config)}]
  {auth(l,\mu \circ e) = auth_{store}(l,\mu) \cup auth_{stack}(l,e,\mu)}
  {}\\[5ex]

\infer[\textsc{(auth-store)}]
  {auth_{store}(l,\mu) = pointsto(d_v,\mu)}
  {\mu(l) = \{ x \Rightarrow d_v \}_{s}}\\[5ex]
  
\infer[\textsc{(auth-stack)}]
  {auth_{stack}(l,E[l.m(l') \rhd e'],\mu) = pointsto(e',\mu) \cup auth_{stack}(l,e',\mu)}
  {l.m(l'') \rhd E' \not\in E}\\[5ex]
  
\infer[\textsc{(auth-stack-nocall)}]
  {auth_{stack}(l,e,\mu) = \varnothing}
  {l.m(l') \rhd e' \not\in e}\\[5ex]
  
\infer[\textsc{(pointsto-def)}]
  {pointsto(\keyw{def} m(x:\tau):\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-var)}]
  {pointsto(\keyw{var} f:\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-principal)}]
  {pointsto(l,\mu) = \{ l \}}
  {\mu(l) = \{ x \Rightarrow d_v \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-data)}]
  {pointsto(l,\mu) = \varnothing }
  {\mu(l) = \{ x \Rightarrow d_v \}_\keywadj{pure}}\\[5ex]

\infer[\textsc{(pointsto-call-principal)}]
  {pointsto(l.m(l') \rhd e,\mu) = \{l\} }
  {\mu(l) = \{ x \Rightarrow d_v \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-call-data)}]
  {pointsto(l.m(l') \rhd e,\mu) = pointsto(e,\mu)}
  {\mu(l) = \{ x \Rightarrow d_v \}_\keywadj{pure}}\\[5ex]
  
\infer[\textsc{(pointsto-new)}]
  {pointsto(\keywadj{new}_{s}(x \Rightarrow d),\mu) = pointsto(d,\mu) }
  {}\\[5ex]
  
\infer[\textsc{(pointsto-otherexp)}]
  {pointsto(e,\mu) = pointsto(subexprs(e),\mu) }
  {\textit{when $e$ is not one of the expression forms defined above}}\\[5ex]

\end{array}
\]

note: the last rule is a shorthand; the rest of the \textit{pointsto} rules for expressions are just congruence - look inside the e's

To Do:

\begin{itemize}
\item add a textual description to give intuition
\item write some examples (all but Darya will do)
\end{itemize}

\newpage

\subsection{Theory}

\textbf{Theorem [Authority Safety].}  If $\Sigma \vdash \mu$, $\bullet, \Sigma \vdash e : \tau$, and $\mu \circ e \stepsto \mu' \circ e'$ then $\forall l \in domain(\mu)$ if $auth(l,\mu' \circ e') \supset auth(l,\mu \circ e)$ then one of the following holds:

\begin{itemize}
  \item \textbf{Creation.} $e = E[\keywadj{new}_p(x \Rightarrow d_v)]$, $e' = E[l']$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ l' \}$.  \textit{check that the creator was $l$}
  \item \textbf{Call.} $e = E[l.m(l')]$, $e' = E[l.m(l') \rhd e]$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ pointsto(l',\mu) \}$  \textit{check that the caller previously had the authority that $l$ gained}
  \item \textbf{Return.}
\end{itemize}

Here, the Authority Safety theorem follows the definition in Maffeis et al. 2010.


\end{document}