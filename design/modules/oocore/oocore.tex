\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
 
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=15pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\textit{Case}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{
  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~#1}
  \fi
  \item
}

\begin{document}

\section{Syntax}

\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expressions \\
& | & \keywadj{new}_{s}(x \Rightarrow d) \\
& | & e.m(e)\\
& | & e.f \\
& | & e.f = e \\
& | & l & (run\mbox{-}time~forms)\\
& | & \keywadj{new}_{s}(x \Rightarrow d_v)\\
& | & l.m(l) \rhd e \\
&&\\
s & ::= & \keyw{stateful} | ~\keyw{pure} \\
&&\\
d & ::= & \epsilon & declarations \\
  & |   & \keyw{def} m(x:\tau):\tau = e; d \\
  & |   & \keyw{var} f:\tau = x; d \\
&&\\
d_v & ::= & \epsilon & decl.~values \\
  & |   & \keyw{def} m(x:\tau):\tau = e; d_v \\
  & |   & \keyw{var} f:\tau = l; d_v \\
&&\\
\tau & ::= & \{ \sigma \}_{s} & types \\
&&\\
\sigma & ::= & \epsilon & decl.~ types \\
       & |   & \keyw{def} m:\tau \rightarrow \tau; \sigma \\
       & |   & \keyw{var} f:\tau; \sigma \\
&&\\
\end{array}
& ~~~~~~
&
\begin{array}{lllr}
\Gamma & :: = & \varnothing & contexts\\
& | & \Gamma,~x : \tau\\
&&\\
\mu & :: = & \varnothing & store\\
& | & \mu,~l \mapsto \{ x \Rightarrow d_v \}_{s}\\
&&\\
\Sigma & :: = & \varnothing & store~type\\
& | & \Sigma,~l : \tau\\
&&\\
E & ::= & [~] & eval.~ contexts\\
  & |   & \keywadj{new}_{s}(x \Rightarrow D) \\
  & |   & E.m(e)\\
  & |   & l.m(E)\\
  & |   & E.f \\
  & |   & E.f = e \\
  & |   & l.f = E \\
  & |   & l.m(l) \rhd E \\
&&\\
D & ::= & [~] & decl.~eval.~ contexts\\
  & |   & \keyw{def} m(x:\tau):\tau = e; D \\
  & |   & \keyw{var} f:\tau = E; d \\
  & |   & \keyw{var} f:\tau = l; D \\
&&\\
\end{array}
\end{array}
\]

\noindent Notes:

\begin{itemize}
\item The $s$ tag indicates whether an object is stateful (i.e. captures mutable state) or pure (i.e. captures no mutable state).
\item Example of how to initialize and use object declarations (and potentially encode modules):
\[
\keywadj{new}_{s}(x \Rightarrow \keyw{def} m(y : \tau) : \tau' = \keywadj{new}_{s}(x \Rightarrow \keyw{var} f_1 : \tau = y;~\keyw{var} f_2 : \tau = y;~\keyw{var} f_3 : \tau = y)).m(\keywadj{new}_{s} (x \Rightarrow \epsilon))
\]
which in memory looks like 
\[
l_2 \mapsto \{l_1,l_1,l_1\},~l_1 \mapsto \varnothing
\]
\item In the \textsc{DT-DefPure} rule, the argument $x$ may be stateful, but because all other variables in $\Gamma$ are pure, $x$ cannot be used (e.g. be assigned to a variable) inside $e$.
\item In the preservation of types under substitution lemma, $y$ and $z$ have to be values because we don't have $\keyw{var} f:\tau = e; d$ and instead have a more restrictive $\keyw{var} f:\tau = l;d$.
\end{itemize}


\newpage

\section{Semantics}

$\fbox{$\Gamma~|~\Sigma \vdash e : \tau$}$
\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
  {\Gamma~|~\Sigma \vdash x : \tau}
  {x : \tau \in \Gamma}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-New-1)}]
	{\Gamma~|~\Sigma \vdash \keywadj{new}_{s}(x \Rightarrow d) : \{ \sigma \}_{s}}
	{\Gamma,~x : \{ \sigma \}_{s}~|~\Sigma \vdash d : \sigma} \\[5ex]

\infer[\textsc{(T-Meth)}]
	{\Gamma~|~\Sigma \vdash e.m(e_1) : \tau_2} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s  & \keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma & \Gamma~|~\Sigma \vdash e_1 : \tau_1}\\[5ex]

\infer[\textsc{(T-Field)}]
	{\Gamma~|~\Sigma \vdash  e.f : \tau} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s & \keyw{var}~ f : \tau \in \sigma}\\[5ex]
	
\infer[\textsc{(T-Assign)}]
	{\Gamma~|~\Sigma \vdash  e.f=e_1 : \tau_1} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s & \keyw{var}~ f:\tau_1 \in \sigma & \Gamma~|~\Sigma \vdash e_1 : \tau_1 }\\[5ex]

\infer[\textsc{(T-Loc)}]
  {\Gamma~|~\Sigma \vdash l : \tau}
  {l : \tau \in \Sigma}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-New-2)}]
	{\Gamma~|~\Sigma \vdash \keywadj{new}_{s}(x \Rightarrow d_v) : \{ \sigma \}_{s}}
	{\Gamma,~x : \{ \sigma \}_{s}~|~\Sigma \vdash d_v : \sigma} \\[5ex]

\infer[\textsc{(T-StackFrames)}]
	{\Gamma~|~\Sigma \vdash l.m(l_1) \rhd e : \tau_2}
	{\Gamma~|~\Sigma \vdash l : \{\sigma\}_s & \keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma & \Gamma~|~\Sigma \vdash l_1 : \tau_1 & \Gamma~|~\Sigma \vdash e : \tau_2} \\[5ex]

\infer[\textsc{(T-Sub)}]
  {\Gamma~|~\Sigma \vdash e : \tau_2}
  {\Gamma~|~\Sigma \vdash e : \tau_1 & \tau_1 <: \tau_2}\\[5ex]

\end{array}
\]

$\fbox{$\Gamma~|~\Sigma \vdash_s d : \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(DT-DefPure)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{pure}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\def\arraystretch{1.6}
  \begin{array}{c}
\Gamma_{stateful} = \{x : \{ \sigma \}_{\keyw{stateful}} ~|~ x : \{ \sigma \}_{\keyw{stateful}} \in \Gamma\} \\
\Gamma_{pure} = \Gamma \setminus \Gamma_{stateful}~~~~~~~~~~\Gamma_{pure},~x : \tau_1~|~\Sigma \vdash e : \tau_2~~~~~~~~~~\Gamma_{pure}~|~\Sigma \vdash_s d : \sigma
  \end{array}}\\[5ex]

\infer[\textsc{(DT-DefStateful)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\Gamma, x : \tau_1~|~\Sigma \vdash e : \tau_2 & \Gamma~|~\Sigma \vdash_s d : \sigma}\\[5ex]

\infer[\textsc{(DT-Var)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{var} f : \tau = x; d~:~\keyw{var} f : \tau; \sigma}
  {\Gamma~|~\Sigma \vdash x : \tau & \Gamma~|~\Sigma \vdash_s d : \sigma}\\[5ex]

\end{array}
\]

$\fbox{$\Gamma~|~\Sigma \vdash_s d_v : \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(DvT-DefPure)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{pure}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d_v~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\def\arraystretch{1.6}
  \begin{array}{c}
\Gamma_{stateful} = \{x : \{ \sigma \}_{\keyw{stateful}} ~|~ x : \{ \sigma \}_{\keyw{stateful}} \in \Gamma\} \\
\Gamma_{pure} = \Gamma \setminus \Gamma_{stateful}~~~~~~~~~~\Gamma_{pure},~x : \tau_1~|~\Sigma \vdash e : \tau_2~~~~~~~~~~\Gamma_{pure}~|~\Sigma \vdash_s d_v : \sigma
  \end{array}}\\[5ex]

\infer[\textsc{(DvT-DefStateful)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d_v~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\Gamma, x : \tau_1~|~\Sigma \vdash e : \tau_2 & \Gamma~|~\Sigma \vdash_s d_v : \sigma}\\[5ex]

\infer[\textsc{(DvT-Var)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{var} f : \tau = l; d_v~:~\keyw{var} f : \tau; \sigma}
  {\Gamma~|~\Sigma \vdash l : \tau & \Gamma~|~\Sigma \vdash_s d_v : \sigma}\\[5ex]

\end{array}
\]


$\fbox{$\tau <: \tau'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl)}]
  {\tau <: \tau}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans)}]
  {\tau_1 <: \tau_3}
  {\tau_1 <: \tau_2 & \tau_2 <: \tau_3}\\[5ex]

\infer[\textsc{(S-State)}]
  {\{ \sigma \}_{\keyw{pure}} <: \{ \sigma' \}_{\keyw{stateful}}}
  {\sigma <: \sigma'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(S-Obj)}]
  {\{ \sigma \}_{s} <: \{ \sigma' \}_{s}}
  {\sigma <: \sigma'}\\[5ex]  

\end{array}
\]

$\fbox{$\sigma <: \sigma'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl)}]
  {\sigma <: \sigma}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans)}]
  {\sigma_1 <: \sigma_3}
  {\sigma_1 <: \sigma_2 & \sigma_2 <: \sigma_3}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Eps)}]
  {\sigma <: \epsilon}
  {}\\[5ex]

\infer[\textsc{(S-Def)}]
  {\keyw{def} m:\tau_1 \rightarrow \tau_2; \sigma <: \keyw{def} m:\tau_1' \rightarrow \tau_2'; \sigma'}
  {\tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \sigma <: \sigma'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(S-Var)}]
  {\keyw{var} f:\tau; \sigma <: \keyw{var} f:\tau; \sigma'}
  {\sigma <: \sigma'}\\[5ex]  

\end{array}
\]

$\fbox{$\mu : \Sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(T-StoreEmpty)}]
  {\varnothing : \varnothing}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Store)}]
  {\mu,~l \mapsto \{ x \Rightarrow d_v \}_s~:~\Sigma,~l : \{ \sigma \}_s}
  {\mu : \Sigma & x : \{ \sigma \}_s~|~\Sigma \vdash d_v : \sigma}\\[5ex]

\end{array}
\]

$\fbox{$E[e]~|~\mu \longrightarrow E[e']~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Congruence)}]
  {E[e]~|~\mu \longrightarrow E[e']~|~\mu'}
  {e~|~\mu \longrightarrow e'~|~\mu'}\\[5ex]  
\end{array}
\]


$\fbox{$e~|~\mu \longrightarrow e'~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-New)}]
  {\keywadj{new}_{s}(x \Rightarrow d_v)~|~\mu \longrightarrow l~|~\mu, l \mapsto \{ x \Rightarrow d_v \}_{s}}
  {l \not\in dom(\mu)}\\[5ex]

\infer[\textsc{(E-Meth)}]
  {l.m(l_1)~|~\mu \longrightarrow l.m(l_1) \rhd [l_1/y][l/x]e~|~\mu}
  {l \mapsto \{ x \Rightarrow d_v \}_{s} \in \mu & \keyw{def} m(y : \tau_1) : \tau = e \in d_v}\\[5ex]

\infer[\textsc{(E-Field)}]
  {l.f~|~\mu \longrightarrow l_1~|~\mu}
  {l \mapsto \{ x \Rightarrow d_v \}_{s} \in \mu & \keyw{var} f:\tau = l_1 \in d_v}\\[5ex]

\infer[\textsc{(E-Assign)}]
  {l.f = l_2~|~\mu \longrightarrow l_2~|~\mu'}
  {\def\arraystretch{1.6}
  \begin{array}{c}
l \mapsto \{ x \Rightarrow d_v \}_{s} \in \mu~~~~~~~~~~~\keyw{var} f:\tau = l_1 \in d_v \\
d_v' = [\keyw{var} f:\tau = l_2/\keyw{var} f:\tau = l_1]d_v~~~~~\mu' = [l \mapsto \{ x \Rightarrow d_v' \}_{s}/l \mapsto \{ x \Rightarrow d_v \}_{s}]\mu
  \end{array}}\\[5ex]

\infer[\textsc{(E-StackFrame)}]
  {l.m(l_1) \rhd l_2~|~\mu \longrightarrow l_2~|~\mu'}
  {}\\[5ex]
  
\end{array}
\]

\newpage

\section{Theorems}

\subsection{Preservation}

\begin{lemma}[Permutation]
If $\Gamma~|~\varnothing \vdash e : \tau$ and $\Delta$ is a permutation of $\Gamma$, then $\Delta~|~\varnothing \vdash e : \tau$, and the latter derivation has the same depth as the former.
\end{lemma}

\begin{proof}
Straightforward induction on typing derivations. \qed
\end{proof}


\begin{lemma}[Weakening]
If $\Gamma~|~\varnothing \vdash e : \tau$ and $x \not\in dom(\Gamma)$, then $\Gamma,~x : \tau'~|~\varnothing \vdash e : \tau$, and the latter derivation has the same depth as the former.
\end{lemma}

\begin{proof}
Straightforward induction on typing derivations. \qed
\end{proof}


\begin{lemma}[Preservation of types under substitution]
If $\Gamma,~v_1 : \tau'~|~\Sigma \vdash e : \tau$ and $\Gamma~|~\varnothing \vdash v_2 : \tau'$, where $v_1$ and $v_2$ are both values, then $\Gamma~|~\Sigma \vdash [v_2/v_1]e : \tau$.
\end{lemma}

\begin{proof} The proof is by induction on a derivation of the statements $\Gamma,~v_1 : \tau'~|~\Sigma \vdash e : \tau$ and $\Gamma,~v_1 : \tau'~|~\Sigma \vdash_s d : \sigma$. For a given derivation, we proceed by cases on the final typing rule used in the proof:

\begin{pcases}
\pcase[\textsc{T-Var}]
$e = x$ and, from the premise, we get 
\[
x : \tau \in (\Gamma,~v_1 : \tau')
\]

There are two sub-cases to consider, depending on whether $x$ is $y$ or another variable. If $x = y$, then $[z/y]x = z$. The required result is then $\Gamma~|~\varnothing \vdash z : \tau'$, which is among the assumptions of the lemma. Otherwise, $[z/y]x = x$, and the desired result is immediate.
\\
\pcase[\textsc{T-Loc}] This case is invalid since we cannot make substitutions in a location.
\\
\pcase[\textsc{T-New}]
$e = \keywadj{new}_{s}(x \Rightarrow d)$ and, from the premise, we get
\[
\Gamma,~x : \{ \sigma \}_{s},~y : \tau'~|~\Sigma \vdash d : \sigma
\]
Here, $d$ is a sequence of declarations each of which are either a method declaration or a field, and so we consider each of the two possibilities in order next.
\\
\begin{itemize}
\item[] \textit{Case} \textsc{DT-Def}\textit{:} $d = \keyw{def} m(x : \tau_1) : \tau_2 = e$. We do substitution on the method body expression, which is subject to alpha-conversion. There are two cases: either the method is pure or it is stateful:
\\
\begin{itemize}
\item[] \textit{Case} \textsc{DT-DefPure}\textit{:} From the premise, we get
\[
\Gamma_{stateful} = \{x : \{ \sigma \}_{\keyw{stateful}} ~|~ x : \{ \sigma \}_{\keyw{stateful}} \in \Gamma\}~~~~~\Gamma_{pure} = \Gamma \setminus \Gamma_{stateful}
\]\[
\Gamma_{pure},~x : \tau_1,~y : \tau'~|~\Sigma \vdash e : \tau_2~~~~~~~~~~\Gamma_{pure},~y : \tau'~|~\Sigma \vdash_s d : \sigma
\]
By the induction hypothesis, $\Gamma_{pure},~x : \tau_1~|~\Sigma \vdash [z/y]e : \tau_2$, and substituting $z$ for $y$ in $d$ preserves the original types. (The latter can be trivially proved by induction on $d$ starting with the end of the sequence when $d = \epsilon$.) Then, by \textsc{DT-DefPure}, $\Gamma~|~\Sigma \vdash_{\keyw{pure}} \keyw{def} m(x : \tau_1) : \tau_2 = [z/y]e; [z/y]d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma$, i.e. $\Gamma~|~\Sigma \vdash_{\keyw{pure}} [z/y](\keyw{def} m(x : \tau_1) : \tau_2 = e; d)~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma$.
\\
\item[] \textit{Case} \textsc{DT-DefStateful}\textit{:} From the premise, we get
\[
\Gamma, x : \tau_1,~y : \tau'~|~\Sigma \vdash e : \tau_2~~~~~\Gamma,~y : \tau'~|~\Sigma \vdash_s d : \sigma
\]
By the induction hypothesis, $\Gamma, x : \tau_1~|~\Sigma \vdash [z/y]e : \tau_2$, and substituting $z$ for $y$ in $d$ preserves the original types. (The latter can be trivially proved by induction on $d$ starting with the end of the sequence when $d = \epsilon$.) Then, by \textsc{DT-DefStateful}, $\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{def} m(x : \tau_1) : \tau_2 = [z/y]e; [z/y]d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma$, i.e. $\Gamma~|~\Sigma \vdash_{\keyw{stateful}} [z/y](\keyw{def} m(x : \tau_1) : \tau_2 = e; d)~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma$.
\\
\end{itemize}

\item[] \textit{Case} \textsc{DT-Var}\textit{:} $d = \keyw{var} f : \tau = v$. There are two possibilities for $v$: If $v$ is a location $l$, it is not affected by the substitution, and the desired result is immediate. If $v$ is a variable $x$, the from the premise of the rule, we get
\[
\Gamma,~y : \tau'~|~\Sigma \vdash x : \tau~~~~~\Gamma,~y : \tau'~|~\Sigma \vdash_s d : \sigma
\]
Because $y$ and $z$ are values, by \textsc{T-Var}, $\Gamma~|~\Sigma \vdash [z/y]x : \tau$, and substituting $z$ for $y$ in $d$ preserves the original types. (The latter can be trivially proved by induction on $d$ starting with the end of the sequence when $d = \epsilon$.) Then, by \textsc{DT-Var}, $\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{var} f : \tau = [z/y]x; [z/y]d~:~\keyw{var} f : \tau; \sigma$, i.e. $\Gamma~|~\Sigma \vdash_{\keyw{stateful}} [z/y](\keyw{var} f : \tau = x; d)~:~\keyw{var} f : \tau; \sigma$.
\\
\end{itemize}

Having considered all the possibilities for $d$, we see that $\Gamma,~x : \{ \sigma \}_{s}~|~\Sigma \vdash [z/y]d : \sigma$. Then, by \textsc{T-New}, $\Gamma~|~\Sigma \vdash \keywadj{new}_{s}(x \Rightarrow [z/y]d) : \{ \sigma \}_{s}$, i.e. $\Gamma~|~\Sigma \vdash [z/y](\keywadj{new}_{s}(x \Rightarrow d)) : \{ \sigma \}_{s}$.
\\
\pcase[\textsc{T-Meth}]
$e = e_1.m(e_2)$ and, from the premise, we get
\[
\Gamma,~y : \tau_3~|~\Sigma \vdash e_1 : \{\sigma\}_s~~~~~\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \sigma~~~~~\Gamma,~y : \tau_3~|~\Sigma \vdash e_2 : \tau_2
\]
By the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e_1 : \{\sigma\}_s$, $\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \sigma$, and $\Gamma~|~\Sigma \vdash [z/y]e_2 : \tau_2$. Then, by \textsc{T-Meth}, $\Gamma~|~\Sigma \vdash [z/y]e_1.m([z/y]e_2) : \tau_1$, i.e. $\Gamma~|~\Sigma \vdash [z/y](e_1.m(e_2)) : \tau_1$.
\\
\pcase[\textsc{T-Field}]
$e = e_1.f$ and, from the premise, we get
\[
\Gamma,~y : \tau'~|~\Sigma \vdash e_1 : \{\sigma\}_s~~~~~\keyw{var}~ f : \tau \in \sigma
\]
By the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e_1 : \{\sigma\}_s$ and $\keyw{var}~ f : \tau \in \sigma$. Then, by \textsc{T-Field}, $\Gamma~|~\Sigma \vdash ([z/y]e_1).f : \tau_2$, i.e. $\Gamma~|~\Sigma \vdash [z/y](e_1.f) : \tau_2$.
\\
\pcase[\textsc{T-Assign}]
$e = e_1.f=e_2$ and, from the premise, we get
\[
\Gamma,~y : \tau_3~|~\Sigma \vdash e_1 : \{\sigma\}_s~~~~~\keyw{var}~ f:\tau_2 \in \sigma~~~~~\Gamma,~y : \tau_3~|~\Sigma \vdash e_2 : \tau_2
\]
By the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e_1 : \{\sigma\}_s$, $\keyw{var}~ f:\tau_2 \in \sigma$, and $\Gamma~|~\Sigma \vdash [z/y]e_2 : \tau_2$. Then, by \textsc{T-Assign}, $\Gamma~|~\Sigma \vdash  [z/y]e_1.f = [z/y]e_2 : \tau_2$, i.e. $\Gamma~|~\Sigma \vdash [z/y](e_1.f=e_2) : \tau_2$.
\\
\pcase[\textsc{T-StackFrame}]
$e = l.m(l_1) \rhd e_2$ and, from the premise, we get
\[
\Gamma,~y : \tau_3~|~\Sigma \vdash l : \{\sigma\}_s~~~~~\keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma~~~~~\Gamma,~y : \tau_3~|~\Sigma \vdash l_1 : \tau_1~~~~~\Gamma,~y : \tau_3~|~\Sigma \vdash e_2 : \tau_2
\]
Locations are not affected by the substitution, and by the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e_2 : \tau_2$. Then, by \textsc{T-StackFrame}, $\Gamma~|~\Sigma \vdash l.m(l_1) \rhd [z/y]e : \tau_2$, i.e. $\Gamma~|~\Sigma \vdash [z/y](l.m(l_1) \rhd e) : \tau_2$.
\\
\pcase[\textsc{T-Sub}]
$e = e'$ and, from the premise, we get
\[
\Gamma,~y : \tau_3~|~\Sigma \vdash e' : \tau_1~~~~~\tau_1 <: \tau_2
\]
By the induction hypothesis, $\Gamma~|~\Sigma \vdash [z/y]e' : \tau_1$ and $\tau_1 <: \tau_2$. Then, by \textsc{T-Sub}, $\Gamma~|~\Sigma \vdash [y/z]e' : \tau_2$.
\end{pcases}

\noindent Thus, substituting terms in a well-typed expression preserves the typing. \qed
\end{proof}

\vspace{15pt}

\begin{theorem}[Preservation]
If
\begin{enumerate}
\item $\Gamma~|~\Sigma \vdash e : \tau$,
\item $\mu : \Sigma$, and
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\end{enumerate}
then
\begin{enumerate}
\item $\exists \Sigma' \supseteq \Sigma$,
\item $\mu' : \Sigma'$,
\item $\Gamma~|~\Sigma' \vdash e' : \tau'$, and
\item $\tau'<:\tau$.
\end{enumerate}

\end{theorem}

\begin{proof} The proof is by induction on a derivation of $\Gamma~|~\Sigma \vdash e : \tau$, with a case analysis on the last typing rule used. The cases when $e$ is a variable (\textsc{T-Var}) or a location (\textsc{T-Loc}) cannot arise, since we assumed $e \longrightarrow e'$, and there are no evaluation rules corresponding to variables or locations. For the other cases, we argue as follows:

\begin{pcases}
\pcase[\textsc{T-New}] ...
\\
\pcase[\textsc{T-Meth}]
$e = e_1.m(e_2)$ and, from the premise, we have
\[
\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s~~~~~\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \sigma~~~~~\Gamma~|~\Sigma \vdash e_2 : \tau_2
\]
By the definition of the evaluation relation, there are three subcases:
\\
\begin{itemize}
\item[]  \textit{Subcase 1:} $e_1 \longrightarrow e_1'$
\\
Then, the result follows from the induction hypothesis and \textsc{T-Meth}.
\\
\item[]  \textit{Subcase 2:} $e_1$ is a value and $e_2 \longrightarrow e_2'$
\\
Similarly to the previous subcase, the result follows from the induction hypothesis and \textsc{T-Meth}.
\\
\item[]  \textit{Subcase 3:} both $e_1$ and $e_2$ are values
\\
By the preservation under subsumption lemma, ...
\\
\end{itemize}

\pcase[\textsc{T-Field}]
$e = e_1.f$ and, from the premise, we have
\[
\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s~~~~~\keyw{var}~ f : \tau \in \sigma
\]
...
\\
\end{pcases}

\end{proof}


\subsection{Progress}

\begin{theorem}[Progress]
If $\varnothing~|~\Sigma \vdash e : \tau$ (i.e., $e$ is a closed, well-typed expression), then either
\begin{enumerate}
\item $e$ is a value or
\item $\forall \mu$ such that $\mu : \Sigma$,
   $\exists e', \mu'$ such that $e~|~\mu \longrightarrow e'~|~\mu'$.
\end{enumerate}
\end{theorem}
\begin{proof} The proof is by induction on the derivation of $\varnothing~|~\Sigma \vdash e : \tau$, with a case analysis on the last typing rule used. The case when $e$ is a variable (\textsc{T-Var}) cannot occur, and the case when $e$ is a location (\textsc{T-Loc}) is immediate, since in that case $e$ is a value. For the other cases, we argue as follows:

\begin{pcases}
\pcase[\textsc{T-New}]
$e = \keywadj{new}_{s}(x \Rightarrow d)$ and, from the premise, we have
\[
\Gamma,~x : \{ \sigma \}_{s}~|~\Sigma \vdash d : \sigma
\]
By the induction hypothesis, either $d$ is a value or else it can make a step of evaluation. If $d$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step. If $d$ is a value, then the rule \textsc{E-New} applies to $e$, and $e$ is a value (a location).
\\
\pcase[\textsc{T-Meth}]
$e = e_1.m(e_2)$ and, from the premise, we have
\[
\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s~~~~~\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \sigma~~~~~\Gamma~|~\Sigma \vdash e_2 : \tau_2
\]
By the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation, and likewise $e_2$. If $e_1$ can take a step or if $e_1$ is a value and $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step. If both $e_1$ and $e_2$ are values, then the rule \textsc{E-Meth} applies to $e$, and $e$ can take a step.
\\
\pcase[\textsc{T-Field}]
$e = e_1.f$ and, from the premise, we have
\[
\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s~~~~~\keyw{var}~ f : \tau \in \sigma
\]
By the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation. If $e_1$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step. If $e_1$ is a value, then the rule \textsc{E-Field} applies to $e$, and $e$ is a value (a location).
\\
\pcase[\textsc{T-Assign}]
$e = e_1.f=e_2$ and, from the premise, we have
\[
\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s~~~~~\keyw{var}~ f:\tau_2 \in \sigma~~~~~\Gamma~|~\Sigma \vdash e_2 : \tau_2
\]
By the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation, and likewise $e_2$. If $e_1$ can take a step or if $e_1$ is a value and $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step. If both $e_1$ and $e_2$ are values, then the rule \textsc{E-Assign} applies to $e$, and $e$ is a value.
\\
\pcase[\textsc{T-StackFrame}]
$e = l.m(l_1) \rhd e_2$ and, from the premise, we have
\[
\Gamma~|~\Sigma \vdash l : \{\sigma\}_s~~~~~\keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma~~~~~\Gamma~|~\Sigma \vdash l_1 : \tau_1~~~~~\Gamma~|~\Sigma \vdash e_2 : \tau_2
\]
By the induction hypothesis, either $e_2$ is a value or else it can make a step of evaluation. If $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step. If $e_2$ is a value, then the rule \textsc{E-StackFrame} applies to $e$, and $e$ is a value (a location).
\\
\pcase[\textsc{T-Sub}]
The result follows directly from the induction hypothesis.

\end{pcases}

\noindent Thus, the program written in this language never gets stuck. \qed

\end{proof}

\newpage

\subsection{Authority}

\[
\begin{array}{c}
\infer[\textsc{(auth-config)}]
  {auth(l,\mu \circ e) = auth_{store}(l,\mu) \cup auth_{stack}(l,e,\mu)}
  {}\\[5ex]

\infer[\textsc{(auth-store)}]
  {auth_{store}(l,\mu) = pointsto(d,\mu)}
  {\mu(l) = \{ x \Rightarrow d \}_{s}}\\[5ex]
  
\infer[\textsc{(auth-stack)}]
  {auth_{stack}(l,E[l.m(l') \rhd e'],\mu) = pointsto(e',\mu) \cup auth_{stack}(l,e',\mu)}
  {l.m(l'') \rhd E' \not\in E}\\[5ex]
  
\infer[\textsc{(auth-stack-nocall)}]
  {auth_{stack}(l,e,\mu) = \varnothing}
  {l.m(l') \rhd e' \not\in e}\\[5ex]
  
\infer[\textsc{(pointsto-def)}]
  {pointsto(\keyw{def} m(x:\tau):\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-var)}]
  {pointsto(\keyw{var} f:\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-principal)}]
  {pointsto(l,\mu) = \{ l \}}
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-data)}]
  {pointsto(l,\mu) = \varnothing }
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{pure}}\\[5ex]

\infer[\textsc{(pointsto-call-principal)}]
  {pointsto(l.m(l') \rhd e,\mu) = \{l\} }
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-call-data)}]
  {pointsto(l.m(l') \rhd e,\mu) = pointsto(e,\mu)}
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{pure}}\\[5ex]
  
\infer[\textsc{(pointsto-new)}]
  {pointsto(\keywadj{new}_{s}(x \Rightarrow d),\mu) = pointsto(d,\mu) }
  {}\\[5ex]
  
\infer[\textsc{(pointsto-otherexp)}]
  {pointsto(e,\mu) = pointsto(subexprs(e),\mu) }
  {\textit{when $e$ is not one of the expression forms defined above}}\\[5ex]

\end{array}
\]

note: the last rule is a shorthand; the rest of the \textit{pointsto} rules for expressions are just congruence - look inside the e's

To Do:

\begin{itemize}
\item add a textual description to give intuition
\item write some examples (all but Darya will do)
\end{itemize}

\newpage

\subsection{Theory}

\textbf{Theorem [Authority Safety].}  If $\Sigma \vdash \mu$, $\bullet, \Sigma \vdash e : \tau$, and $\mu \circ e \stepsto \mu' \circ e'$ then $\forall l \in domain(\mu)$ if $auth(l,\mu' \circ e') \supset auth(l,\mu \circ e)$ then one of the following holds:

\begin{itemize}
  \item \textbf{Creation.} $e = E[\keywadj{new}_p(x \Rightarrow d)]$, $e' = E[l']$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ l' \}$.  \textit{check that the creator was $l$}
  \item \textbf{Call.} $e = E[l.m(l')]$, $e' = E[l.m(l') \rhd e]$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ pointsto(l',\mu) \}$  \textit{check that the caller previously had the authority that $l$ gained}
  \item \textbf{Return.}
\end{itemize}

Here, the Authority Safety theorem follows the definition in Maffeis et al. 2010.


\end{document}