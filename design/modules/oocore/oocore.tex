\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
 
%\pagestyle{headings}
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=15pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}

\begin{document}


\section{Modules}

\subsection{Syntax}

\[
\begin{array}{lll}
\begin{array}{lllr}
v & ::= & x & values \\
   & | & l \\
e & ::= & v & expressions \\
& | & \keywadj{new}_{s}(x \Rightarrow d) \\
& | & e.m(e)\\
& | & e.f \\
& | & e.f = e \\
& | & l.m(l) \rhd e & (run\mbox{-}time~form)\\
&&\\
s & ::= & \keyw{stateful} | ~\keyw{pure} \\
&&\\
\tau & ::= & \{ \sigma \}_{s} & types \\
&&\\
d & ::= & \epsilon & declarations \\
  & |   & \keyw{def} m(x:\tau):\tau = e; d \\
  & |   & \keyw{var} f:\tau = v; d \\
&&\\
\sigma & ::= & \epsilon & decl.~ types \\
       & |   & \keyw{def} m:\tau \rightarrow \tau; \sigma \\
       & |   & \keyw{var} f:\tau; \sigma \\
&&\\
\end{array}
& ~~~~~~
&
\begin{array}{lllr}
\Gamma & :: = & \varnothing & contexts\\
& | & \Gamma,~x : \tau\\
&&\\
\mu & :: = & \varnothing & store\\
& | & \mu,~l \mapsto \{ x \Rightarrow d \}_{s}\\
&&\\
\Sigma & :: = & \varnothing & store~type\\
& | & \Sigma,~l : \tau\\
&&\\
E & ::= & [~] & eval.~ contexts\\
  & |   & \keywadj{new}_{s}(x \Rightarrow D) \\
  & |   & E.m(e)\\
  & |   & l.m(E)\\
  & |   & E.f \\
  & |   & E.f = e \\
  & |   & l.f = E \\
  & |   & l.m(l) \rhd E \\
&&\\
D & ::= & \keyw{def} m(x:\tau):\tau = e; D & decl.~ contexts\\
  & |   & \keyw{var} f:\tau = E; d \\
  & |   & \keyw{var} f:\tau = l; D \\
&&\\
\end{array}
\end{array}
\]

Notes:

\begin{itemize}
\item The $s$ tag indicates whether an object is stateful (i.e. captures mutable state) or pure (i.e. captures no mutable state)
\end{itemize}


\newpage

\subsection{Semantics}

$\fbox{$\Gamma~|~\Sigma \vdash e : \tau$}$
\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
  {\Gamma~|~\Sigma \vdash x : \tau}
  {x : \tau \in \Gamma}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Loc)}]
  {\Gamma~|~\Sigma \vdash l : \tau}
  {l : \tau \in \Sigma}\\[5ex]

\infer[\textsc{(T-New)}]
	{\Gamma~|~\Sigma \vdash \keywadj{new}_{s}(x \Rightarrow d) : \{ \sigma \}_{s}}
	{\Gamma,~x : \{ \sigma \}_{s}~|~\Sigma \vdash d : \sigma} \\[5ex]

\infer[\textsc{(T-Meth)}]
	{\Gamma~|~\Sigma \vdash e.m(e_1) : \tau_2} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s  & \keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma & \Gamma~|~\Sigma \vdash e_1 : \tau_1}\\[5ex]

\infer[\textsc{(T-Field)}]
	{\Gamma~|~\Sigma \vdash  e.f : \tau} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s & \keyw{var}~ f : \tau \in \sigma}\\[5ex]
	
\infer[\textsc{(T-Assign)}]
	{\Gamma~|~\Sigma \vdash  e.f=e_1 : \tau_1} 
	{\Gamma~|~\Sigma \vdash e : \{\sigma\}_s & \keyw{var}~ f:\tau_1 \in \sigma & \Gamma~|~\Sigma \vdash e_1 : \tau_1 }\\[5ex]

\infer[\textsc{(T-StackFrames)}]
	{\Gamma~|~\Sigma \vdash l.m(l_1) \rhd e : \tau_2}
	{\Gamma~|~\Sigma \vdash l : \{\sigma\}_s & \keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma & \Gamma~|~\Sigma \vdash l_1 : \tau_1 & \Gamma~|~\Sigma \vdash e : \tau_2} \\[5ex]

\infer[\textsc{(T-Sub)}]
  {\Gamma~|~\Sigma \vdash e : \tau_2}
  {\Gamma~|~\Sigma \vdash e : \tau_1 & \tau_1 <: \tau_2}\\[5ex]

\end{array}
\]

$\fbox{$\Gamma~|~\Sigma \vdash_s d : \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(DT-DefPure)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{pure}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\def\arraystretch{1.6}
  \begin{array}{c}
\Gamma_{stateful} = \{x : \{ \sigma \}_{\keyw{stateful}} ~|~ x : \{ \sigma \}_{\keyw{stateful}} \in \Gamma\} \\
\Gamma_{pure} = \Gamma \setminus \Gamma_{stateful}~~~~~~~~~~\Gamma_{pure}, x : \tau_1~|~\Sigma \vdash e : \tau_2~~~~~~~~~~\Gamma_{pure}~|~\Sigma \vdash_s d : \sigma
  \end{array}}\\[5ex]

\infer[\textsc{(DT-DefStateful)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{def} m(x : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
  {\Gamma, x : \tau_1~|~\Sigma \vdash e : \tau_2 & \Gamma~|~\Sigma \vdash_s d : \sigma}\\[5ex]

\infer[\textsc{(DT-Var)}]
  {\Gamma~|~\Sigma \vdash_{\keyw{stateful}} \keyw{var} f : \tau = v; d~:~\keyw{var} f : \tau; \sigma}
  {\Gamma~|~\Sigma \vdash v : \tau & \Gamma~|~\Sigma \vdash_s d : \sigma}\\[5ex]

\end{array}
\]

$\fbox{$\tau <: \tau'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl)}]
  {\tau <: \tau}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans)}]
  {\tau_1 <: \tau_3}
  {\tau_1 <: \tau_2 & \tau_2 <: \tau_3}\\[5ex]

\infer[\textsc{(S-State)}]
  {\{ \sigma \}_{\keyw{pure}} <: \{ \sigma' \}_{\keyw{stateful}}}
  {\sigma <: \sigma'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(S-Obj)}]
  {\{ \sigma \}_{s} <: \{ \sigma' \}_{s}}
  {\sigma <: \sigma'}\\[5ex]  

\end{array}
\]

$\fbox{$\sigma <: \sigma'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl)}]
  {\sigma <: \sigma}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans)}]
  {\sigma_1 <: \sigma_3}
  {\sigma_1 <: \sigma_2 & \sigma_2 <: \sigma_3}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Eps)}]
  {\sigma <: \epsilon}
  {}\\[5ex]

\infer[\textsc{(S-Def)}]
  {\keyw{def} m:\tau_1 \rightarrow \tau_2; \sigma <: \keyw{def} m:\tau_1' \rightarrow \tau_2'; \sigma'}
  {\tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \sigma <: \sigma'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(S-Var)}]
  {\keyw{var} f:\tau; \sigma <: \keyw{var} f:\tau; \sigma'}
  {\sigma <: \sigma'}\\[5ex]  

\end{array}
\]

$\fbox{$\mu : \Sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(T-StoreEmpty)}]
  {\varnothing : \varnothing}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Store)}]
  {\mu, l \mapsto \{ x \Rightarrow d \}~:~\Sigma,~l : \{ \sigma \}_s}
  {\mu : \Sigma & x : \{ \sigma \}_s~|~\Sigma \vdash d : \sigma}\\[5ex]

\end{array}
\]

$\fbox{$E[e]~|~\mu \longrightarrow E[e']~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Congruence)}]
  {E[e]~|~\mu \longrightarrow E[e']~|~\mu'}
  {e~|~\mu \longrightarrow e'~|~\mu'}\\[5ex]  
\end{array}
\]


$\fbox{$e~|~\mu \longrightarrow e'~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-New)}]
  {\keywadj{new}_{s}(x \Rightarrow d)~|~\mu \longrightarrow l~|~\mu, l \mapsto \{ x \Rightarrow d \}_{s}}
  {l \not\in \mu}\\[5ex]
  
\infer[\textsc{(E-Meth)}]
  {l.m(l_1)~|~\mu \longrightarrow l.m(l_1) \rhd [l_1/y][l/x]e~|~\mu}
  {l \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{def} m(y : \tau_1) : \tau = e \in d}\\[5ex]

\infer[\textsc{(E-Field)}]
  {l.f~|~\mu \longrightarrow l_1~|~\mu}
  {l \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{var} f:\tau = l_1 \in d}\\[5ex]

\infer[\textsc{(E-Assign)}]
  {l.f = v~|~\mu \longrightarrow [l/x]v~|~\mu}
  {l \mapsto \{ x \Rightarrow d \}_{s} \in \mu & \keyw{var} f:\tau = v \in d}\\[5ex]

\infer[\textsc{(E-StackFrame)}]
  {l.m(l_1) \rhd l_2~|~\mu \longrightarrow l_2~|~\mu'}
  {}\\[5ex]
  
\end{array}
\]

\newpage

\subsection{Type Safety}


%\begin{theorem}[Preservation]
%If $\Gamma~|~\Sigma \vdash e : \tau$ and
%   	$e~|~\mu \rightarrow e'~|~\mu'$, where
%	$\Gamma~|~\varnothing \vdash \mu : \Sigma$, then 
% 	$\exists \Gamma', \Sigma', \tau'$ such that
%	$\Gamma' \supseteq \Gamma$,
%	$\Sigma' \supseteq \Sigma$,
%	$\Gamma'~|~\varnothing \vdash \tau'<:\tau$, and
%	$\Gamma'~|~\Sigma' \vdash e' : \tau'$.
%\end{theorem}
%%\begin{proof} TBD
%%\end{proof}
%
%\vspace{15pt}


%\[
%\begin{array}{c}
%\infer[\textsc{(T-Sub)}]
%  {\Gamma~|~\Sigma \vdash e : \tau_2}
%  {\Gamma~|~\Sigma \vdash e : \tau_1 & \tau_1 <: \tau_2}\\[5ex]
%
%\end{array}
%\]


\begin{theorem}[Progress]
If $\Gamma~|~\Sigma \vdash e : \tau$, then either
\begin{enumerate}
\item $e$ is a value or
\item $\forall \mu$ such that $\Gamma~|~\varnothing \vdash \mu : \Sigma$,
   $\exists e', \mu'$ such that $e~|~\mu \rightarrow e'~|~\mu'$.
\end{enumerate}
\end{theorem}
\begin{proof} The proof is by induction on the derivation of $\Gamma~|~\Sigma \vdash e : \tau$, with a case analysis on the last typing rule used. The cases when $e$ is a variable ($x$) or a location ($l$) are immediate, since in that case $e$ is a value. For the other cases, we argue as follows:

\begin{case}[\textsc{T-New}]
$e = \keywadj{new}_{s}(x \Rightarrow d)$ and $\Gamma,~x : \{ \sigma \}_{s}~|~\Sigma \vdash d : \sigma$

\noindent By the induction hypothesis, either $d$ is a value or else it can make a step of evaluation. If $d$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If $d$ is a value, then the rule \textsc{E-New} applies to $e$, and $e$ is a value (a location).
\end{case}

\begin{case}[\textsc{T-Meth}]
$e = e_1.m(e_2)$ and $\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s$, $\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \sigma$, $\Gamma~|~\Sigma \vdash e_2 : \tau_2$

\noindent By the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation, and likewise $e_2$. If $e_1$ can take a step or if $e_1$ is a value and $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If both $e_1$ and $e_2$ are values, then the rule \textsc{E-Meth} applies to $e$, and $e$ can take a step.
\end{case}

\begin{case}[\textsc{T-Field}]
$e = e_1.f$ and $\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s$, $\keyw{var}~ f : \tau \in \sigma$

\noindent By the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation. If $e_1$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If $e_1$ is a value, then the rule \textsc{E-Field} applies to $e$, and $e$ is a value (a location).
\end{case}

\begin{case}[\textsc{T-Assign}]
$e = e_1.f=e_2$ and $\Gamma~|~\Sigma \vdash e_1 : \{\sigma\}_s$, $\keyw{var}~ f:\tau_2 \in \sigma$, $\Gamma~|~\Sigma \vdash e_2 : \tau_2$

\noindent By the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation, and likewise $e_2$. If $e_1$ can take a step or if $e_1$ is a value and $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If both $e_1$ and $e_2$ are values, then the rule \textsc{E-Assign} applies to $e$, and $e$ is a value.
\end{case}

\begin{case}[\textsc{T-StackFrame}]
$e = l.m(l_1) \rhd e_2$ and $\Gamma~|~\Sigma \vdash l : \{\sigma\}_s$, $\keyw{def}~ m : \tau_1 \rightarrow \tau_2 \in \sigma$, $\Gamma~|~\Sigma \vdash l_1 : \tau_1$, $\Gamma~|~\Sigma \vdash e_2 : \tau_2$

\noindent By the induction hypothesis, either $e_2$ is a value or else it can make a step of evaluation. If $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$. If $e_2$ is a value, then the rule \textsc{E-StackFrame} applies to $e$, and $e$ is a value (a location).
\end{case}

\end{proof}

\newpage

\subsection{Authority}

\[
\begin{array}{c}
\infer[\textsc{(auth-config)}]
  {auth(l,\mu \circ e) = auth_{store}(l,\mu) \cup auth_{stack}(l,e,\mu)}
  {}\\[5ex]

\infer[\textsc{(auth-store)}]
  {auth_{store}(l,\mu) = pointsto(d,\mu)}
  {\mu(l) = \{ x \Rightarrow d \}_{s}}\\[5ex]
  
\infer[\textsc{(auth-stack)}]
  {auth_{stack}(l,E[l.m(l') \rhd e'],\mu) = pointsto(e',\mu) \cup auth_{stack}(l,e',\mu)}
  {l.m(l'') \rhd E' \not\in E}\\[5ex]
  
\infer[\textsc{(auth-stack-nocall)}]
  {auth_{stack}(l,e,\mu) = \varnothing}
  {l.m(l') \rhd e' \not\in e}\\[5ex]
  
\infer[\textsc{(pointsto-def)}]
  {pointsto(\keyw{def} m(x:\tau):\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-var)}]
  {pointsto(\keyw{var} f:\tau = e; d,\mu) = pointsto(e,\mu) \cup pointsto(d,\mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-principal)}]
  {pointsto(l,\mu) = \{ l \}}
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-data)}]
  {pointsto(l,\mu) = \varnothing }
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{pure}}\\[5ex]

\infer[\textsc{(pointsto-call-principal)}]
  {pointsto(l.m(l') \rhd e,\mu) = \{l\} }
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{stateful}}\\[5ex]
  
\infer[\textsc{(pointsto-call-data)}]
  {pointsto(l.m(l') \rhd e,\mu) = pointsto(e,\mu)}
  {\mu(l) = \{ x \Rightarrow d \}_\keywadj{pure}}\\[5ex]
  
\infer[\textsc{(pointsto-new)}]
  {pointsto(\keywadj{new}_{s}(x \Rightarrow d),\mu) = pointsto(d,\mu) }
  {}\\[5ex]
  
\infer[\textsc{(pointsto-otherexp)}]
  {pointsto(e,\mu) = pointsto(subexprs(e),\mu) }
  {\textit{when $e$ is not one of the expression forms defined above}}\\[5ex]

\end{array}
\]

note: the last rule is a shorthand; the rest of the \textit{pointsto} rules for expressions are just congruence - look inside the e's

To Do:

\begin{itemize}
\item add a textual description to give intuition
\item write some examples (all but Darya will do)
\end{itemize}

\newpage

\subsection{Theory}

\textbf{Theorem [Authority Safety].}  If $\Sigma \vdash \mu$, $\bullet, \Sigma \vdash e : \tau$, and $\mu \circ e \stepsto \mu' \circ e'$ then $\forall l \in domain(\mu)$ if $auth(l,\mu' \circ e') \supset auth(l,\mu \circ e)$ then one of the following holds:

\begin{itemize}
  \item \textbf{Creation.} $e = E[\keywadj{new}_p(x \Rightarrow d)]$, $e' = E[l']$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ l' \}$.  \textit{check that the creator was $l$}
  \item \textbf{Call.} $e = E[l.m(l')]$, $e' = E[l.m(l') \rhd e]$, and $auth(l,\mu' \circ e') = auth(l,\mu \circ e) \cup \{ pointsto(l',\mu) \}$  \textit{check that the caller previously had the authority that $l$ gained}
  \item \textbf{Return.}
\end{itemize}

Here, the Authority Safety theorem follows the definition in Maffeis et al. 2010.


\end{document}