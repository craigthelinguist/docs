\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\allowdisplaybreaks
 
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\textit{Case}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{
  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~#1}
  \fi
  \item
}

\begin{document}

\section{Syntax}

\[
\begin{array}{lll}
\begin{array}{lllr}
e & ::= & x & expressions \\
& | & \keywadj{new}_{s}(x \Rightarrow \overline{d}) \\
& | & e.m(e)\\
& | & e.f \\
& | & e.f = e \\
& | & \keyw{bind} x = e~\keyw{in} e \\
& | & l & (run\mbox{-}time~forms)\\
%& | & \keywadj{new}_{s}(x \Rightarrow d_v)\\
& | & l.m(l) \rhd e \\
&&\\
s & ::= & \keyw{stateful} | ~\keyw{pure} \\
&&\\
d & ::= & \keyw{def} m(x:\tau):\tau = e & declarations \\
  & |   & \keyw{var} f:\tau = x \\
  & |   & \keyw{var} f:\tau = l & (run\mbox{-}time~form)\\
&&\\
%d_v & ::= & \epsilon & decl.~values \\
%  & |   & \keyw{def} m(x:\tau):\tau = e; d_v \\
%  & |   & \keyw{var} f:\tau = l; d_v \\
%&&\\
\tau & ::= & \{ \overline{\sigma} \}_{s} & types \\
&&\\
\sigma & ::= & \keyw{def} m:\tau \rightarrow \tau & decl.~ types \\
       & |   & \keyw{var} f:\tau \\
%&&\\
%\sigma_e & ::= & \keyw{def} m:\tau \rightarrow \tau & external~decl.~ types \\
&&\\
\end{array}
& ~~~~~~
&
\begin{array}{lllr}
\Gamma & :: = & \varnothing & contexts\\
& | & \Gamma,~x : \tau\\
&&\\
\mu & :: = & \varnothing & store\\
%& | & \mu,~l \mapsto \{ x \Rightarrow d_v \}_{s}\\
& | & \mu,~l \mapsto \{ x \Rightarrow \overline{d} \}_{s}\\
&&\\
\Sigma & :: = & \varnothing & store~type\\
& | & \Sigma,~l : \tau\\
&&\\
E & ::= & [~] & evaluation~ contexts\\
%  & |   & \keywadj{new}_{s}(x \Rightarrow D) \\
%  & |   & \keywadj{new}_{s}(x \Rightarrow d) \\
  & |   & E.m(e)\\
  & |   & l.m(E)\\
  & |   & E.f \\
  & |   & E.f = e \\
  & |   & \keyw{bind} x = E~\keyw{in} e \\
  & |   & l.f = E \\
  & |   & l.m(l) \rhd E \\
&&\\
%D & ::= & [~] & decl.~eval.~ contexts\\
%  & |   & \keyw{def} m(x:\tau):\tau = e; D \\
%  & |   & \keyw{var} f:\tau = E; d \\
%  & |   & \keyw{var} f:\tau = l; D \\
%&&\\
\end{array}
\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
\item The $s$ tag indicates whether an object is stateful (i.e. captures mutable state) or pure (i.e. captures no mutable state).
\item Example of how to initialize and use object declarations (and potentially encode modules):
\[
\keywadj{new}_{s}(x \Rightarrow \keyw{def} m(y : \tau) : \tau' = \keywadj{new}_{s}(x \Rightarrow \keyw{var} f_1 : \tau = y;~\keyw{var} f_2 : \tau = y;~\keyw{var} f_3 : \tau = y)).m(\keywadj{new}_{s} (x \Rightarrow \epsilon))
\]
which in memory looks like 
\[
l_2 \mapsto \{l_1,l_1,l_1\},~l_1 \mapsto \varnothing
\]
\item In the \textsc{DT-DefPure} rule, the argument $x$ may be stateful, but because all other variables in $\Gamma$ are pure, $x$ cannot be used (e.g. be assigned to a variable) inside $e$.
\item In the preservation of types under substitution lemma, $y$ and $z$ have to be values because we don't have $\keyw{var} f:\tau = e; d$ and instead have a more restrictive $\keyw{var} f:\tau = l;d$.
\item Substitution rules for $\keyw{bind}$ and $\keyw{let}$:
\[
    [l/x](\keyw{bind} y = e_1~\keyw{in} e_2) = \keyw{bind} y = [l/x]e_1~\keyw{in} e_2
\]
\[
    [l/x](\keyw{let} y = e_1~\keyw{in} e_2) = 
\begin{cases}
    \keyw{let} y = [l/x]e_1~\keyw{in} [l/x]e_2, & \text{if } x \not= y\\
    \keyw{let} y = [l/x]e_1~\keyw{in} e_2, & \text{if } x = y
\end{cases}
\]

Although the two constructs look similar, there is an important semantical difference between them. The $\keywadj{bind}$ construct is more restrictive as its body $e_2$ is type checked in the context that contains only the preamble $e_1$ (see \textsc{T-Bind}). Then, in both cases, substitution of $l$ for $x$ happens only in the preamble $e_1$ and not in the body $e_2$. In contrast, in $\keywadj{let}$, when $x \not= y$, $l$ is substituted for $x$ in both the preamble $e_1$ and the body $e_2$, and when $x = y$, $l$ is substituted for $x$ in the preamble $e_1$, and then $y$ shadows $x$ in the body $e_2$, and thus, $e_2$ does not change. 

\item Encoding of $\keyw{let}$:
\[
\keyw{let} y = e_1~\keyw{in} e_2~~~\equiv~~~\keywadj{new}_s(x \Rightarrow \keyw{def} m(y) = e_2).m(e_1)
\]

\item There is no $\tau \rightarrow \tau$ type in $\tau$ because we don't want fields ($\keywadj{var}$s) to be able to store methods.
\item The annotation on the turnstile represents the current or future (in case of an object creation) receiver of the enclosing method.

\end{itemize}



\section{Semantics}

$\fbox{$\Gamma~|~\Sigma \vdash^e e : \tau$}$
\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
  {\Gamma~|~\Sigma \vdash^e x : \tau}
  {x : \tau \in \Gamma}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-New)}]
	{\Gamma~|~\Sigma \vdash^e \keywadj{new}_{s}(x \Rightarrow \overline{d}) : \{ \overline{\sigma} \}_{s}}
	{\Gamma,~x : \{ \overline{\sigma} \}_{s}~|~\Sigma \vdash^x_s \overline{d} : \overline{\sigma}} \\[5ex]

\infer[\textsc{(T-Method)}]
	{\Gamma~|~\Sigma \vdash^e e_1.m(e_2) : \tau_1} 
	{\Gamma~|~\Sigma \vdash^e e_1 : \{ \overline{\sigma} \}_s  & \keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \overline{\sigma} & \Gamma~|~\Sigma \vdash^e e_2 : \tau_2}\\[5ex]

\infer[\textsc{(T-Field)}]
	{\Gamma~|~\Sigma \vdash^e e.f : \tau} 
	{\Gamma~|~\Sigma \vdash^e e : \{ \overline{\sigma} \}_s & \keyw{var}~ f : \tau \in \overline{\sigma}}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Assign)}]
	{\Gamma~|~\Sigma \vdash^{e_1}  e_1.f=e_2 : \tau} 
	{\Gamma~|~\Sigma \vdash^{e_1} e_1 : \{ \overline{\sigma} \}_s & \keyw{var}~ f : \tau \in \overline{\sigma} & \Gamma~|~\Sigma \vdash^{e_1} e_2 : \tau}\\[5ex]

\infer[\textsc{(T-Bind)}]
  {\Gamma~|~\Sigma \vdash^e \keyw{bind} x = e_1~\keyw{in} e_2 : \tau_2}
  {\Gamma~|~\Sigma \vdash^e e_1 : \tau_1 & x : \tau_1~|~\Sigma \vdash^e e_2 : \tau_2}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Loc)}]
  {\Gamma~|~\Sigma \vdash^e l : \tau}
  {l : \tau \in \Sigma}\\[5ex]

\infer[\textsc{(T-StackFrame)}]
	{\Gamma~|~\Sigma \vdash^{e'} l_1.m(l_2) \rhd e : \tau_1}
	{\Gamma~|~\Sigma \vdash^{e'} l_1 : \{ \overline{\sigma} \}_s & \keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \overline{\sigma} & \Gamma~|~\Sigma \vdash^{e'} l_2 : \tau_2 & \Gamma~|~\Sigma \vdash^{l_1} e : \tau_1} \\[5ex]

\infer[\textsc{(T-Sub)}]
  {\Gamma~|~\Sigma \vdash^{e'} e : \tau_2}
  {\Gamma~|~\Sigma \vdash^{e'} e : \tau_1 & \tau_1 <: \tau_2}\\[5ex]

\end{array}
\]

$\fbox{$\Gamma~|~\Sigma \vdash^z_s \overline{d} : \overline{\sigma}$}$
\[
\begin{array}{c}
\infer[\textsc{(T-Decls)}]
  {\Gamma~|~\Sigma \vdash^z_{s} \overline{d}~:~\overline{\sigma}}
  {\forall j,~d_j \in \overline{d},~\sigma_{j} \in \overline{\sigma},~\Gamma~|~\Sigma \vdash^z_{s} d_j : \sigma_{j}}\\[5ex]

\end{array}
\]

$\fbox{$\Gamma~|~\Sigma \vdash^z_s d : \sigma$}$
\[
\begin{array}{c}

%\infer[\textsc{(DT-Empty)}]
%  {\Gamma~|~\Sigma \vdash_s \epsilon~; d~:~\epsilon~; \sigma}
%  {\Gamma~|~\Sigma \vdash_s d : \sigma}\\[3.5ex]

%\infer[\textsc{(DT-DefPure)}]
%  {\Gamma~|~\Sigma \vdash_{\keywadj{pure}} \keyw{def} m(y : \tau_1) : \tau_2 = e; d~:~\keyw{def} m : \tau_1 \rightarrow \tau_2; \sigma}
%  {\def\arraystretch{1.5}
%  \begin{array}{c}
%\Gamma_{stateful} = \{x : \{ \sigma \}_{\keywadj{stateful}} ~|~ x : \{ \sigma \}_{\keywadj{stateful}} \in \Gamma\} \\
%\Gamma_{pure} = \Gamma \setminus \Gamma_{stateful}~~~~~~~\Gamma_{pure},~y : \tau_1~|~\Sigma \vdash e : \tau_2~~~~~~~\Gamma~|~\Sigma \vdash_{\keywadj{pure}} d : \sigma
%  \end{array}}\\[5ex]
  
\infer[\textsc{(DT-DefPure)}]
  {\Gamma~|~\Sigma \vdash^z_{\keywadj{pure}} \keyw{def} m(y : \tau_1) : \tau_2 = e~:~\keyw{def} m : \tau_1 \rightarrow \tau_2}
  {\Gamma_{stateful} = \{x : \{ \overline{\sigma} \}_{\keywadj{stateful}} ~|~ x : \{ \overline{\sigma} \}_{\keywadj{stateful}} \in \Gamma\} & \Gamma_{pure} = \Gamma \setminus \Gamma_{stateful} & \Gamma_{pure},~y : \tau_1~|~\Sigma \vdash^z e : \tau_2}\\[5ex]

\infer[\textsc{(DT-DefStateful)}]
  {\Gamma~|~\Sigma \vdash^z_{\keywadj{stateful}} \keyw{def} m(x : \tau_1) : \tau_2 = e~:~\keyw{def} m : \tau_1 \rightarrow \tau_2}
  {\Gamma,~x : \tau_1~|~\Sigma \vdash^z e : \tau_2}\\[5ex]

\infer[\textsc{(DT-Varx)}]
  {\Gamma~|~\Sigma \vdash^z_{\keywadj{stateful}} \keyw{var} f : \tau = x~:~\keyw{var} f : \tau}
  {\Gamma~|~\Sigma \vdash^z x : \tau}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(DT-Varl)}]
  {\Gamma~|~\Sigma \vdash^z_{\keywadj{stateful}} \keyw{var} f : \tau = l~:~\keyw{var} f : \tau}
  {\Gamma~|~\Sigma \vdash^z l : \tau}\\[5ex]

\end{array}
\]

$\fbox{$\tau <: \tau'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl1)}]
  {\tau <:\tau}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans1)}]
  {\tau_1 <: \tau_3}
  {\tau_1 <: \tau_2 & \tau_2 <: \tau_3}\\[5ex]

\infer[\textsc{(S-State)}]
  {\{ \overline{\sigma} \}_{\keyw{pure}} <: \{ \overline{\sigma} \}_{\keyw{stateful}}}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Perm)}]
  {\{ \sigma_{j}^{j \in 1..n} \}_{s} <: \{ \sigma_{j}'^{j \in 1..n} \}_{s}}
  {\{ \sigma_{j}^{j \in 1..n} \}_{s}~is~a~permutation~of~\{ \sigma_{j}'^{j \in 1..n} \}_{s}}\\[5ex]

\infer[\textsc{(S-Width)}]
  {\{ \sigma_{j}^{j \in 1..n + k} \}_{s} <: \{ \sigma_{j}^{j \in 1..n} \}_{s}}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Depth)}]
  {\{ \sigma_{j}^{j \in 1..n} \}_{s} <: \{ \sigma_{j}^{j \in 1..n} \}_{s}}
  {\forall j,~\sigma_{j} <: \sigma_{j}'}\\[5ex]

\end{array}
\]

\vspace{-3pt}
$\fbox{$\sigma <: \sigma'$}$
\[
\begin{array}{c}
\infer[\textsc{(S-Refl2)}]
  {\sigma <: \sigma}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(S-Trans2)}]
  {\sigma_{1} <: \sigma_{3}}
  {\sigma_{1} <: \sigma_{2} & \sigma_{2} <: \sigma_{3}}\\[5ex]
%~~~~~~~~~~
%\infer[\textsc{(S-Eps)}]
%  {\sigma <: \epsilon}
%  {}\\[5ex]

\infer[\textsc{(S-Def)}]
  {\keyw{def} m:\tau_1 \rightarrow \tau_2 <: \keyw{def} m:\tau_1' \rightarrow \tau_2'}
  {\tau_1' <: \tau_1 & \tau_2 <: \tau_2'}%\\[5ex]  
~~~~~~~~~~
\infer[\textsc{(S-Var)}]
  {\keyw{var} f:\tau <: \keyw{var} f:\tau'}
  {\tau <: \tau'}\\[5ex]  

\end{array}
\]

$\fbox{$\mu : \Sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(T-StoreEmpty)}]
  {\varnothing : \varnothing}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-Store)}]
  {\mu,~l \mapsto \{ x \Rightarrow \overline{d} \}_s~:~\Sigma,~l : \{ \overline{\sigma} \}_s}
  {\mu : \Sigma & x : \{ \overline{\sigma} \}_s~|~\Sigma \vdash^z_s \overline{d} : \overline{\sigma}}\\[5ex]

\end{array}
\]

$\fbox{$E[e]~|~\mu \longrightarrow E[e']~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Congruence)}]
  {E[e]~|~\mu \longrightarrow E[e']~|~\mu'}
  {e~|~\mu \longrightarrow e'~|~\mu'}\\[5ex]  
\end{array}
\]


$\fbox{$e~|~\mu \longrightarrow e'~|~\mu'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-New)}]
  {\keywadj{new}_{s}(x \Rightarrow \overline{d})~|~\mu \longrightarrow l~|~\mu, l \mapsto \{ x \Rightarrow \overline{d} \}_{s}}
  {l \not\in dom(\mu) & \keywadj{new}_{s}(x \Rightarrow \overline{d})~is~closed}\\[5ex]

\infer[\textsc{(E-Method)}]
  {l_1.m(l_2)~|~\mu \longrightarrow l_1.m(l_2) \rhd [l_2/y][l_1/x]e~|~\mu}
  {l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu & \keyw{def} m(y : \tau_1) : \tau_2 = e \in \overline{d}}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(E-Field)}]
  {l.f~|~\mu \longrightarrow l_1~|~\mu}
  {l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu & \keyw{var} f:\tau = l_1 \in \overline{d}}\\[5ex]

\infer[\textsc{(E-Assign)}]
  {l_1.f = l_2~|~\mu \longrightarrow l_2~|~\mu'}
  {\def\arraystretch{1.6}
  \begin{array}{c}
l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu~~~~~~~~~~~\keyw{var} f:\tau = l \in \overline{d} \\
\overline{d}' = [\keyw{var} f:\tau = l_2/\keyw{var} f:\tau = l]\overline{d}~~~~~\mu' = [l_1 \mapsto \{ x \Rightarrow \overline{d}' \}_{s}/l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s}]\mu
  \end{array}}\\[5ex]

\infer[\textsc{(E-Bind)}]
  {\keyw{bind} x = l_1~\keyw{in} e_2~|~\mu \longrightarrow [l_1/x]e_2~|~\mu}
  {}%\\[5ex]
~~~~~~~~~~
\infer[\textsc{(E-StackFrame)}]
  {l.m(l_1) \rhd l_2~|~\mu \longrightarrow l_2~|~\mu}
  {}\\[5ex]
  
\end{array}
\]

\newpage
\section{Properties}

\begin{property}
\label{prop:no-rt-forms}
The run-time expression forms $l$ and $l.m(l) \rhd e$ do not appear in the program source code.
\end{property}

\begin{proof}
This property is enforced by the syntactic check of the source code of a program.
\end{proof}


\begin{property}
\label{prop:mcsf-def-bind}
Method call stack frames ($l.m(l) \rhd e$) do not appear in method definitions and the bodies of the $\keywadj{bind}$ constructs.
\end{property}

\begin{proof}
The proof is by induction over execution steps.

\noindent\underline{\textit{Base case:}} By Property~\ref{prop:no-rt-forms}, there are no method call stack frames in the program source code.

\noindent\underline{\textit{Inductive case:}} The absence of method call stack frames in the method definitions and the bodies of the $\keywadj{bind}$ constructs is maintained by all evaluation rules. Cases of \textsc{E-Method} and \textsc{E-Bind} involve substitution; however, substituted expression is a value (location), and thus, substitution preserves the property.\qed
\end{proof}


\begin{property}
\label{prop:fields-private}
Object fields are private to the objects they belong to and access to them can occur only inside methods of the objects to which they belong.
\end{property}

\begin{proof}
\noindent The typing rules contain information about what object is (or will be, in case of an object creation) the receiver of the enclosing method. Then, from the \textsc{T-Field} and \textsc{T-Assign} rules, it can be seen that, for a field access to occur, the receiver must be the object to which the field belongs.
\end{proof}


\newpage
\section{Theorems}

\subsection{Preservation}

\begin{lemma}[Permutation]
If $\Gamma~|~\varnothing \vdash^{e'} e : \tau$ and $\Delta$ is a permutation of $\Gamma$, then $\Delta~|~\varnothing \vdash^{e'} e : \tau$, and the latter derivation has the same depth as the former.
\end{lemma}

\begin{proof}
Straightforward induction on typing derivations. \qed
\end{proof}

\vspace{6pt}

\begin{lemma}[Weakening]
If $\Gamma~|~\varnothing \vdash^{e'} e : \tau$ and $x \not\in dom(\Gamma)$, then $\Gamma,~x : \tau'~|~\varnothing \vdash^{e'} e : \tau$, and the latter derivation has the same depth as the former.
\end{lemma}

\begin{proof}
Straightforward induction on typing derivations. \qed
\end{proof}

\vspace{6pt}

\begin{lemma}[Preservation of types under substitution]
If $\Gamma,~z : \tau'~|~\Sigma \vdash^{e''} e : \tau$ and $\Gamma~|~\Sigma \vdash^{e''} e' : \tau'$, then $\Gamma~|~\Sigma \vdash^{e''} [e'/z]e : \tau$. Furthermore, if $\Gamma,~z : \tau'~|~\Sigma \vdash^{x'}_s d : \sigma$ and $\Gamma~|~\Sigma \vdash^{x'} e' : \tau'$, then $\Gamma~|~\Sigma \vdash^{x'}_s [e'/z]d : \sigma$.
\end{lemma}

\begin{proof} The proof is by simultaneous induction on a derivation of $\Gamma,~z : \tau'~|~\Sigma \vdash^{e''}e : \tau$ and $\Gamma,~z : \tau'~|~\Sigma \vdash^{x'}_s d : \sigma$. For a given derivation, we proceed by cases on the final typing rule used in the proof:

\begin{pcases}
\pcase[\textsc{T-Var}]
$e = x$, and by inversion on \textsc{T-Var}, we get $x : \tau \in (\Gamma,~z : \tau')$. There are two subcases to consider, depending on whether $x$ is $z$ or another variable. If $x = z$, then $[e'/z]x = e'$. The required result is then $\Gamma~|~\Sigma \vdash^{e''} e' : \tau'$, which is among the assumptions of the lemma. Otherwise, $[e'/z]x = x$, and the desired result is immediate.
\\
\pcase[\textsc{T-New}]
$e = \keywadj{new}_{s}(x \Rightarrow \overline{d})$, and by inversion on \textsc{T-New}, we get $\Gamma,~x : \{ \overline{\sigma} \}_{s}~|~\Sigma \vdash^x_s \overline{d} : \overline{\sigma}$. By the induction hypothesis, $x : \{ \overline{\sigma} \}_{s}~|~\Sigma \vdash^x_s [e'/z]\overline{d} : \overline{\sigma}$. Then, by \textsc{T-New}, $\Gamma~|~\Sigma \vdash^{e''} \keywadj{new}_{s}(x \Rightarrow [e'/z]\overline{d}) : \{ \overline{\sigma} \}_{s}$, i.e. $\Gamma~|~\Sigma \vdash^{e''} [e'/z](\keywadj{new}_{s}(x \Rightarrow \overline{d})) : \{ \overline{\sigma} \}_{s}$.
\\
\pcase[\textsc{T-Method}]
$e = e_1.m(e_2)$, and by inversion on \textsc{T-Method}, we get
\[
\Gamma,~z : \tau'~|~\Sigma \vdash^{e''} e_1 : \{ \overline{\sigma} \}_s~~~~~\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \overline{\sigma}~~~~~\Gamma,~z : \tau'~|~\Sigma \vdash^{e''} e_2 : \tau_2
\]
By the induction hypothesis, $\Gamma~|~\Sigma \vdash^{e''} [e'/z]e_1 : \{ \overline{\sigma} \}_s$ and $\Gamma~|~\Sigma \vdash^{e''} [e'/z]e_2 : \tau_2$. Then, by \textsc{T-Method}, $\Gamma~|~\Sigma \vdash^{e''} [e'/z]e_1.m([e'/z]e_2) : \tau_1$, i.e. $\Gamma~|~\Sigma \vdash^{e''} [e'/z](e_1.m(e_2)) : \tau_1$.
\\
\pcase[\textsc{T-Field}]
$e = e_1.f$, and by inversion on \textsc{T-Field}, we get $\Gamma,~z : \tau'~|~\Sigma \vdash^{e_1} e_1 : \{ \overline{\sigma} \}_s$ and $\keyw{var}~ f : \tau \in \overline{\sigma}$. By the induction hypothesis, $\Gamma~|~\Sigma \vdash^{e_1} [e'/z]e_1 : \{ \overline{\sigma} \}_s$. Then, by \textsc{T-Field}, $\Gamma~|~\Sigma \vdash^{e_1} ([e'/z]e_1).f : \tau$, i.e. $\Gamma~|~\Sigma \vdash^{e_1} [e'/z](e_1.f) : \tau$.
\\
\pcase[\textsc{T-Assign}]
$e = (e_1.f = e_2)$, and by inversion on \textsc{T-Assign}, we get
\[
\Gamma,~z : \tau'~|~\Sigma \vdash^{e_1} e_1 : \{ \overline{\sigma} \}_s~~~~~\keyw{var}~ f : \tau \in \overline{\sigma}~~~~~\Gamma,~z : \tau'~|~\Sigma \vdash^{e_1} e_2 : \tau
\]
By the induction hypothesis, $\Gamma~|~\Sigma \vdash^{e_1} [e'/z]e_1 : \{ \overline{\sigma} \}_s$ and $\Gamma~|~\Sigma \vdash^{e_1} [e'/z]e_2 : \tau$. Then, by \textsc{T-Assign}, $\Gamma~|~\Sigma \vdash^{e_1}  [e'/z]e_1.f = [e'/z]e_2 : \tau$, i.e. $\Gamma~|~\Sigma \vdash^{e_1} [e'/z](e_1.f=e_2) : \tau$.
\\
\pcase[\textsc{T-Bind}]
$e = \keyw{bind} x = e_1~\keyw{in} e_2 : \tau_2$, and $[e'/z](\keyw{bind} x = e_1~\keyw{in} e_2) = \keyw{bind} x = [e'/z]e_1~\keyw{in} e_2$. By inversion on \textsc{T-Bind}, we get $\Gamma,~z : \tau'~|~\Sigma \vdash^{e''} e_1 : \tau_1$, and by the induction hypothesis, $\Gamma~|~\Sigma \vdash^{e''} [e'/z]e_1 : \tau_1$. Then, by \textsc{T-Bind}, $\Gamma~|~\Sigma \vdash^{e''} \keyw{bind} x = [e'/z]e_1~\keyw{in} e_2 : \tau_2$, i.e. $\Gamma~|~\Sigma \vdash^{e''} [e'/z](\keyw{bind} x = e_1~\keyw{in} e_2) : \tau_2$.
\\
\pcase[\textsc{T-Loc}]
$e = l$, $[e'/z]l = l$, and the desired result is immediate.
\\
\pcase[\textsc{T-StackFrame}]
$e = l_1.m(l_2) \rhd e_1$, and by inversion on \textsc{T-StackFrame}, we get
\[
\Gamma,~z : \tau'~|~\Sigma \vdash^{e''} l_1 : \{ \overline{\sigma} \}_s~~~~~\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \overline{\sigma}~~~~~\Gamma,~z : \tau'~|~\Sigma \vdash^{e''} l_2 : \tau_2~~~~~\Gamma,~l_2 : \tau_2,~z : \tau'~|~\Sigma \vdash^{l_1} e_1 : \tau_1
\]
Locations are not affected by the substitution, and by the induction hypothesis, $\Gamma,~l_2 : \tau_2~|~\Sigma \vdash^{e''} [e'/z]e_1 : \tau_1$. Then, by \textsc{T-StackFrame}, $\Gamma~|~\Sigma \vdash^{e''} l_1.m(l_2) \rhd [e'/z]e_1 : \tau_1$, i.e. $\Gamma~|~\Sigma \vdash^{e''} [e'/z](l_1.m(l_2) \rhd e_1) : \tau_1$.
\\
\pcase[\textsc{T-Sub}]
$e = e_1$, and by inversion on \textsc{T-Sub}, we get $\Gamma,~z : \tau'~|~\Sigma \vdash^{e''} e_1 : \tau_1$ and $\tau_1 <: \tau_2$. By the induction hypothesis, $\Gamma~|~\Sigma \vdash^{e''} [e'/z]e_1 : \tau_1$ and $\tau_1 <: \tau_2$. Then, by \textsc{T-Sub}, $\Gamma~|~\Sigma \vdash^{e''} [e'/z]e_1 : \tau_2$.
\\
\pcase[\textsc{T-Decls}]
By inversion on \textsc{T-Decls}, we get $\forall j,~d_j \in \overline{d},~\sigma_j \in \overline{\sigma},~\Gamma, z : \tau'~|~\Sigma \vdash^{x'}_{s} d_j : \sigma_j$. By the induction hypothesis, $\forall j,~d_j \in \overline{d},~\sigma_j \in \overline{\sigma},~\Gamma~|~\Sigma \vdash^{x'}_{s} [e'/z]d_j : \sigma_{j}$. Then, by \textsc{T-Decls}, $\Gamma~|~\Sigma \vdash^{x'}_{s} [e'/z]\overline{d} : \overline{\sigma}$.
\\
\pcase[\textsc{DT-DefPure}]
$d = \keyw{def} m(y : \tau_1) : \tau_2 = e$. There are two subcases depending on whether $z$ is in $\Gamma_{pure}$:

\begin{itemize}
\item[] \textit{Subcase $z \in \Gamma_{pure}$}: By inversion on \textsc{DT-DefPure}, we get
\[
\Gamma_{stateful} = \{x : \{ \overline{\sigma} \}_{\keyw{stateful}} ~|~ x : \{ \overline{\sigma} \}_{\keyw{stateful}} \in \Gamma\}~~~~~\Gamma_{pure} = \Gamma \setminus \Gamma_{stateful}~~~~~\Gamma_{pure},~y : \tau_1~|~\Sigma \vdash^{x'} e : \tau_2
\]
and the desired result is immediate.

\item[] \textit{Subcase $z \not\in \Gamma_{pure}$}: By inversion on \textsc{DT-DefPure}, we get
\[
\Gamma_{stateful} = \{x : \{ \overline{\sigma} \}_{\keyw{stateful}} ~|~ x : \{ \overline{\sigma} \}_{\keyw{stateful}} \in \Gamma\}~~~~~\Gamma_{pure} = \Gamma \setminus \Gamma_{stateful}~~~~~\Gamma_{pure},~y : \tau_1,~z : \tau'~|~\Sigma \vdash^{x'} e : \tau_2
\]
By the induction hypothesis, $\Gamma_{pure},~y : \tau_1~|~\Sigma \vdash^{x'} [e'/z]e : \tau_2$. Then, by \textsc{DT-DefPure}, $\Gamma~|~\Sigma \vdash^{x'}_{\keywadj{pure}} \keyw{def} m(y : \tau_1) : \tau_2 = [e'/z]e~:~\keyw{def} m : \tau_1 \rightarrow \tau_2$, i.e. $\Gamma~|~\Sigma \vdash^{x'}_{\keyw{pure}} [e'/z](\keyw{def} m(y : \tau_1) : \tau_2 = e)~:~\keyw{def} m : \tau_1 \rightarrow \tau_2$.
\end{itemize}

Thus, in both cases, the type of $d$ is preserved under substitution.
\\
\pcase[\textsc{DT-DefStateful}]
$d = \keyw{def} m(x : \tau_1) : \tau_2 = e$, and by inversion on \textsc{DT-DefStateful}, we get $\Gamma, x : \tau_1,~z : \tau'~|~\Sigma \vdash^{x'} e : \tau_2$. By the induction hypothesis, $\Gamma, x : \tau_1~|~\Sigma \vdash^{x'} [e'/z]e : \tau_2$. Then, by \textsc{DT-DefStateful}, $\Gamma~|~\Sigma \vdash^{x'}_{\keyw{stateful}} \keyw{def} m(x : \tau_1) : \tau_2 = [e'/z]e~:~\keyw{def} m : \tau_1 \rightarrow \tau_2$, i.e. $\Gamma~|~\Sigma \vdash^{x'}_{\keyw{stateful}} [e'/z](\keyw{def} m(x : \tau_1) : \tau_2 = e)~:~\keyw{def} m : \tau_1 \rightarrow \tau_2$.
\\
\pcase[\textsc{DT-Varx}]
$d = \keyw{var} f : \tau = x$, and by inversion on \textsc{DT-Varx}, we get $\Gamma,~z : \tau'~|~\Sigma \vdash^{x'} x : \tau$. There are two subcases to consider, depending on whether $x$ is $z$ or another variable. If $x = z$, then $\Gamma,~z : \tau'~|~\Sigma \vdash^{x'} [e'/z]x : \tau$ yields $\Gamma,~z : \tau'~|~\Sigma \vdash^{x'} e' : \tau$ and $\tau = \tau'$. Thus, $\Gamma~|~\Sigma \vdash^{x'}_{\keyw{stateful}} \keyw{var} f : \tau = e'~:~\keyw{var} f : \tau$ as required. If $x \not = z$, then $\Gamma,~z : \tau'~|~\Sigma \vdash^{x'} [e'/z]x : \tau$ yields $\Gamma,~z : \tau'~|~\Sigma \vdash^{x'} x : \tau$, and the desired result is immediate.
\\
\pcase[\textsc{DT-Varl}]
$d = \keyw{var} f : \tau = l$, i.e. the field is resolved to a location $l$. This is not affected by the substitution, and the desired result is immediate.

\end{pcases}

\noindent Thus, substituting terms in a well-typed expression preserves the typing. \qed
\end{proof}

%\newpage
\vspace{6pt}

\begin{theorem}[Preservation]
If $\Gamma~|~\Sigma \vdash^{e''} e : \tau$, $\mu : \Sigma$, and $e~|~\mu \longrightarrow e'~|~\mu'$, then $\exists \Sigma' \supseteq \Sigma$, $\mu' : \Sigma'$, and $\Gamma~|~\Sigma' \vdash^{e''} e' : \tau$.

\end{theorem}

\begin{proof} The proof is by induction on a derivation of $\Gamma~|~\Sigma \vdash^{e''} e : \tau$. At each step of the induction, we assume that the desired property holds for all subderivations and proceed by case analysis on the final rule in the derivation. Since we assumed $e~|~\mu \longrightarrow e'~|~\mu'$ and there are no evaluation rules corresponding to variables or locations, the cases when $e$ is a variable (\textsc{T-Var}) or a location (\textsc{T-Loc}) cannot arise. For the other cases, we argue as follows:
\\

\noindent\textit{Case \textsc{T-New}}:
$e = \keywadj{new}_{s}(x \Rightarrow \overline{d})$, and by inversion on \textsc{T-New}, we get $\Gamma,~x : \{ \overline{\sigma} \}_{s}~|~\Sigma \vdash^x_s \overline{d} : \overline{\sigma}$. The store changes from $\mu$ to $\mu' = \mu,~l \mapsto \{ x \Rightarrow \overline{d} \}_s$, i.e. the new store is the old store augmented with a new mapping for the location $l$, which was not in the old store. From the premise of the theorem, we know that $\mu : \Sigma$, and by the induction hypothesis, all expressions of $\Gamma$ are properly allocated in $\Sigma$. Then, by \textsc{T-Store}, we have $\mu,~l \mapsto \{ x \Rightarrow \overline{d} \}_s~:~\Sigma,~l : \{ \overline{\sigma} \}_s$, which implies that $\Sigma' = \Sigma,~l : \{ \overline{\sigma} \}_s$. Finally, by \textsc{T-Loc}, $\Gamma~|~\Sigma \vdash l : \{ \overline{\sigma} \}_s$. Thus, the right-hand side is well typed.
\\

\noindent\textit{Case \textsc{T-Method}}:
$e = e_1.m(e_2)$, and by the definition of the evaluation relation, there are two subcases:

\textit{Subcase} \textsc{E-Congruence}\textit{:} In this case, either $e_1~|~\mu \longrightarrow e_1'~|~\mu'$ or $e_1$ is a value and $e_2~|~\mu \longrightarrow e_2'~|~\mu'$. Then, the result follows from the induction hypothesis and \textsc{T-Method}.

\textit{Subcase} \textsc{E-Method}\textit{:} In this case, both $e_1$ and $e_2$ are values, namely locations $l_1$ and $l_2$ respectively. Then, by inversion on \textsc{T-Method}, we get that $\Gamma~|~\Sigma \vdash^{e''} l_1 : \{ \overline{\sigma} \}_s$, $\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \overline{\sigma}$, and $\Gamma~|~\Sigma \vdash^{e''} l_2 : \tau_2$. The store $\mu$ does not change, and since \textsc{T-Store} has been applied throughout, the store is well typed, and thus, \mbox{$\Gamma~|~\Sigma \vdash^{e''}_s \keyw{def}~ m(l_2 : \tau_2) : \tau_1 = e~:~\keyw{def}~ m : \tau_2 \rightarrow \tau_1$}. Then, by inversion on both \textsc{DT-DefPure} and \textsc{DT-DefStateful}, we know that $\Gamma,~l_2 : \tau_2~|~\Sigma \vdash^{e''} e : \tau_1$, and by \textsc{T-StackFrame}, we have $\Gamma,~l_2 : \tau_2~|~\Sigma \vdash^{e''} l_1.m(l_2) \rhd e : \tau_1$. Finally, by the preservation under subsumption lemma, substituting locations for variables in $e$ preserve its type, and therefore, the right-hand side is well typed.
\\

\noindent\textit{Case \textsc{T-Field}}:
$e = e_1.f$, and by the definition of the evaluation relation, there are two subcases:

\textit{Subcase} \textsc{E-Congruence}\textit{:} In this case, $e_1~|~\mu \longrightarrow e_1'~|~\mu'$, and the result follows from the induction hypothesis and \textsc{T-Field}.

\textit{Subcase} \textsc{E-Field}\textit{:} In this case, $e_1$ is a value, i.e. a location $l$. Then, by inversion on  \textsc{T-Field}, we have $\Gamma~|~\Sigma \vdash^l l : \{ \overline{\sigma} \}_s$ and $\keyw{var}~ f : \tau \in \overline{\sigma}$. The store $\mu$ does not change, and since \textsc{T-Store} has been applied throughout, the store is well typed, and thus, \mbox{$\Gamma~|~\Sigma \vdash^l_s \keyw{var}~ f : \tau = l_1~:~\keyw{var}~ f : \tau$}. Then, by inversion on \textsc{DT-Varl}, we know that $\Gamma~|~\Sigma \vdash^l l_1 : \tau$, and the right-hand side is well typed.
\\

\noindent\textit{Case \textsc{T-Assign}}:
$e = (e_1.f = e_2)$, and by the definition of the evaluation relation, there are two subcases:

\textit{Subcase} \textsc{E-Congruence}\textit{:} In this case, either $e_1~|~\mu \longrightarrow e_1'~|~\mu'$ or $e_1$ is a value and $e_2~|~\mu \longrightarrow e_2'~|~\mu'$. Then, the result follows from the induction hypothesis and \textsc{T-Assign}.

\textit{Subcase} \textsc{E-Assign}\textit{:} In this case, both $e_1$ and $e_2$ are values, namely locations $l_1$ and $l_2$ respectively. Then, by inversion on \textsc{T-Assign}, we get that $\Gamma~|~\Sigma \vdash^{l_1} l_1 : \{ \overline{\sigma} \}_s$, $\keyw{var}~ f : \tau \in \overline{\sigma}$, and $\Gamma~|~\Sigma \vdash^{l_1} l_2 : \tau$. The store changes as follows: $\mu' = [l_1 \mapsto \{ x \Rightarrow \overline{d}' \}_{s}/l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s}]\mu$, where $\overline{d}' = [\keyw{var} f:\tau = l_2/\keyw{var} f : \tau = l]\overline{d}$. However, since \textsc{T-Store} has been applied throughout and the substituted location has the type expected by \textsc{T-Store}, the new store is well typed (as well as the old store), and thus, \mbox{$\Gamma~|~\Sigma \vdash^{l_1}_s \keyw{var}~ f : \tau = l_2~:~\keyw{var}~ f : \tau$}. Then, by inversion on \textsc{DT-Varl}, we know that $\Gamma~|~\Sigma \vdash^{l_1} l_2 : \tau$, and the right-hand side is well typed.
\\

\noindent\textit{Case \textsc{T-Bind}}:
$e = \keyw{bind} x = e_1~\keyw{in} e_2$, and by the definition of the evaluation relation, there are two subcases:

\textit{Subcase} \textsc{E-Congruence}\textit{:} In this case, $e_1~|~\mu \longrightarrow e_1'~|~\mu'$, and the result follows from the induction hypothesis and \textsc{T-Bind}.

\textit{Subcase} \textsc{E-Bind}\textit{:} In this case, $e_1$ is a value, namely a locations $l_1$, and the result follows directly from the inversion on \textsc{T-Bind} and the preservation of types under substitution lemma.
\\

\noindent\textit{Case \textsc{T-StackFrame}}:
$e = l.m(l_1) \rhd e_2$, and by the definition of the evaluation relation, there are two subcases:

\textit{Subcase} \textsc{E-Congruence}\textit{:} In this case, $e~|~\mu \longrightarrow e'~|~\mu'$, and the result follows from the induction hypothesis and \textsc{T-StackFrame}.

\textit{Subcase} \textsc{E-StackFrame}\textit{:} In this case, $e_2$ is a value, i.e. a location $l_2$, and the result follows directly from the inversion on \textsc{T-StackFrame}.
\\

\noindent\textit{Case \textsc{T-Sub}}:
The result follows directly from the induction hypothesis.
\\

\noindent Thus, the program written in this language is always well typed. \qed

\end{proof}


\subsection{Progress}

\begin{theorem}[Progress]
If $\varnothing~|~\Sigma \vdash^{e''} e : \tau$ (i.e. $e$ is a closed, well-typed expression), then either
\begin{enumerate}
\item $e$ is a value (i.e. a location) or
\item $\forall \mu$ such that $\mu : \Sigma$,
   $\exists e', \mu'$ such that $e~|~\mu \longrightarrow e'~|~\mu'$.
\end{enumerate}
\end{theorem}
\begin{proof} The proof is by induction on the derivation of $\Gamma~|~\Sigma \vdash^{e''} e : \tau$, with a case analysis on the last typing rule used. The case when $e$ is a variable (\textsc{T-Var}) cannot occur, and the case when $e$ is a location (\textsc{T-Loc}) is immediate, since in that case $e$ is a value. For the other cases, we argue as follows:
\\

\noindent\textit{Case \textsc{T-New}}:
$e = \keywadj{new}_{s}(x \Rightarrow \overline{d})$, and by \textsc{E-New}, $e$ can make a step of evaluation if the $\keywadj{new}$ expression is closed and there is a location available that is not in the current store $\mu$. From the premise of the theorem, we know that the expression is closed, and there are infinitely many available new locations, and therefore, $e$ indeed can take a step and become a value (i.e. a location $l$). Then, the new store $\mu'$ is $\mu, l \mapsto \{ x \Rightarrow \overline{d} \}_{s}$, and all the declarations in $\overline{d}$ are mapped in the new store.
\\

\noindent\textit{Case \textsc{T-Method}}:
$e = e_1.m(e_2)$, and by the induction hypothesis applied to $\Gamma~|~\Sigma \vdash^{e''} e_1 : \{ \overline{\sigma} \}_s$, either $e_1$ is a value or else it can make a step of evaluation, and, similarly, by the induction hypothesis applied to $\Gamma~|~\Sigma \vdash^{e''} e_2 : \tau_2$, either $e_2$ is a value or else it can make a step of evaluation. Then, there are two subcases:

\textit{Subcase $e_1~|~\mu \longrightarrow e_1'~|~\mu'$ or $e_1$ is a value and $e_2~|~\mu \longrightarrow e_2'~|~\mu'$:} If $e_1$ can take a step or if $e_1$ is a value and $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step.

\textit{Subcase $e_1$ and $e_2$ are values:} If both $e_1$ and $e_2$ are values, i.e. they are locations $l_1$ and $l_2$ respectively, then by inversion on \textsc{T-Method}, we have $\Gamma~|~\Sigma \vdash^{e''} l_1 : \{ \overline{\sigma} \}_s$ and $\keyw{def}~ m : \tau_2 \rightarrow \tau_1 \in \overline{\sigma}$. By inversion on \textsc{T-Loc}, we know that the store contains an appropriate mapping for the location $l_1$, and since \textsc{T-Store} has been applied throughout, the store is well typed and $l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ with $\keyw{def} m(y : \tau_1) : \tau_2 = e \in \overline{d}$. Therefore, the rule \textsc{E-Method} applies to $e$, $e$ can take a step, and $\mu' = \mu$.
\\

\noindent\textit{Case \textsc{T-Field}}:
$e = e_1.f$, and by the induction hypothesis, either $e_1$ can make a step of evaluation or it is a value. Then, there are two subcases:

\textit{Subcase $e_1~|~\mu \longrightarrow e_1'~|~\mu'$:} If $e_1$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step.

\textit{Subcase $e_1$ is a value:} If $e_1$ is a value, i.e. a location $l$, then by inversion on \textsc{T-Field}, we have $\Gamma~|~\Sigma \vdash^l l : \{ \overline{\sigma} \}_s$ and $\keyw{var}~ f : \tau \in \overline{\sigma}$. By inversion on \textsc{T-Loc}, we know that the store contains an appropriate mapping for the location $l$, and since \textsc{T-Store} has been applied throughout, the store is well typed and $l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ with $\keyw{var} f : \tau = l_1 \in \overline{d}$. Therefore, the rule \textsc{E-Field} applies to $e$, $e$ can take a step, and $\mu' = \mu$.
\\

\noindent\textit{Case \textsc{T-Assign}}:
$e = (e_1.f = e_2)$, and by the induction hypothesis, either $e_1$ is a value or else it can make a step of evaluation, and likewise $e_2$. Then, there are two subcases:

\textit{Subcase $e_1~|~\mu \longrightarrow e_1'~|~\mu'$ or $e_1$ is a value and $e_2~|~\mu \longrightarrow e_2'~|~\mu'$:} If $e_1$ can take a step or if $e_1$ is a value and $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step.

\textit{Subcase $e_1$ and $e_2$ are values:} If both $e_1$ and $e_2$ are values, i.e. they are locations $l_1$ and $l_2$ respectively, then by inversion on \textsc{T-Assign}, we have $\Gamma~|~\Sigma \vdash^{l_1} l_1 : \{ \overline{\sigma} \}_s$, $\keyw{var}~ f : \tau \in \overline{\sigma}$, and $\Gamma~|~\Sigma \vdash^{l_1} l_2 : \tau$. By inversion on \textsc{T-Loc}, we know that the store contains an appropriate mapping for the locations $l_1$ and $l_2$, and since \textsc{T-Store} has been applied throughout, the store is well typed and $l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu$ with $\keyw{var} f : \tau = l \in \overline{d}$. A new well-typed store can be created as follows: $\mu' = [l_1 \mapsto \{ x \Rightarrow \overline{d}' \}_{s}/l_1 \mapsto \{ x \Rightarrow \overline{d} \}_{s}]\mu$, where $\overline{d}' = [\keyw{var} f : \tau = l_2/\keyw{var} f : \tau = l]\overline{d}$. Then, the rule \textsc{E-Assign} applies to $e$, and $e$ can take a step.
\\

\noindent\textit{Case \textsc{T-Bind}}:
$e =  \keyw{bind} x = e_1~\keyw{in} e_2$, and by the induction hypothesis, either $e_1$ can make a step of evaluation or it is a value. Then, there are two subcases:

\textit{Subcase $e_1~|~\mu \longrightarrow e_1'~|~\mu'$:} If $e_1$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step.

\textit{Subcase $e_1$ is a value:} If $e_1$ is a value, i.e. a location $l_1$, the rule \textsc{E-Bind} applies, and $e$ can take a step.
\\

\noindent\textit{Case \textsc{T-StackFrame}}:
$e = l.m(l_1) \rhd e_2$, and by the induction hypothesis, either $e_2$ can make a step of evaluation or it is a value. Then, there are two subcases:

\textit{Subcase $e_2~|~\mu \longrightarrow e_2'~|~\mu'$:} If $e_2$ can take a step, then rule \textsc{E-Congruence} applies to $e$, and $e$ can take a step.

\textit{Subcase $e_2$ is a value:} If $e_2$ is a value, i.e. a location $l_2$, the rule \textsc{E-StackFrame} applies, and $e$ can take a step.
\\

\noindent\textit{Case \textsc{T-Sub}}:
The result follows directly from the induction hypothesis.
\\

\noindent Thus, the program written in this language never gets stuck. \qed

\end{proof}

\newpage

\section{Module Translation}

\subsection{Code Example 1}

\begin{tabular}{p{0.53\textwidth}p{0.47\textwidth}}
\begin{minipage}[t]{\textwidth}
\begin{lstlisting}
resource signature sigA =
  var f : Int
  def m(y : Int) : Int

resource signature sigB =
  var k : Int

resource signature sigC =
  def n(Unit) : Int

resource signature sigD =
  def m(y : Int) : Int

resource module A : sigA
  var f : Int = 3
  def m(y : Int) : Int = y

module D : sigD
  def m(y : Int) : Int = 42

resource module B : sigB
  import D as myD
  require sigA as myA
  var k : Int = myA.m(3)

resource module C : sigC
  require sigA as myA
  def n(Unit) : Int = myA.m(5)

resource module Main
  instantiate A() as copyOfAForB 
  instantiate A() as copyOfAForC 
  instantiate B(copyOfAForB)
  instantiate C(copyOfAForC)

\end{lstlisting}
\end{minipage}
&
\hspace{-10ex}
\begin{minipage}[t]{\textwidth}
\begin{lstlisting}
resource signature sigA =
  var f : Int
  def m : Int -> Int

resource signature sigB =
  var k : Int

resource signature sigC =
  def n : Unit -> Int

resource signature sigD =
  def m : Int -> Int
  
val A : Unit -> sigA = fn _ : Unit =>
    bind in
    new (A =>
        var f : Int = 3
        def m(y : Int) : Int = y
    )
    
val D : sigD =
    bind in
    new (D =>
        def m(y : Int) : Int = 42
    )

val B : sigA -> sigB = fn myA : sigA =>
  bind
     val myD : sigD = D
  in
  new(B =>
    var k : Int = myA.m(3)
  )

val C : sigA -> sigC = fn myA : sigA =>
  bind in
  new(C =>
    def n (Unit) : Int = myA.m(5)
  )

val Main = fn _ : Unit =>
    bind
        val copyOfAForB = A()
        val copyOfAForC = A()
        val B = B(copyOfAForB)
        val C = C(copyOfAForC)
    in
        // nothing
        
\end{lstlisting}
\end{minipage}
\end{tabular}

\newpage

\subsection{Code Example 2}

\begin{tabular}{p{0.6\textwidth}p{0.6\textwidth}}
\begin{minipage}[t]{\textwidth}
\begin{lstlisting}
signature sigA = 
  def a(Unit) : Int

signature sigB =
  def b(y : Int) : Int

resource signature sigC =
  var c : Int

resource signature sigD =
  var d : Int

resource signature sigE =
  var e : Int
  
resource signature sigF =
  def f(y : Int) : Int
  
resource signature sigG =
  def g(Unit) : Int

resource signature sigX =
  def sumX(y : Int) : Int


module A : sigA
  def a(Unit) : Int = 42

module B : sigB
  def b(y : Int) : Int = y

resource module C : sigC
  var c : Int = 2

resource module D : sigD
  var d : Int = 0
  
\end{lstlisting}
\end{minipage}
&
\hspace{-10ex}
\begin{minipage}[t]{\textwidth}
\begin{lstlisting}
resource module X : sigX

  resource module E : sigE
    var e : Int = 5

  resource module F : sigF
    require sigE as myE
    def f(y : Int) = y + myE.e

  resource module G : sigG
    require sig E as myE
    def g(Unit) = myE.e

  import sigA as myA
  import sigB as myB
  require sigC as myC
  require sigD as myD
  instantiate E() as myE
  instantiate E() as eForF
  instantiate E() as eForG
  instantiate F(eForF) as myF
  instantiate G(eForG) as myG

  def sumX(y : Int) : Int = 
      myA.a() + myB.b(y) + myC.c + myD.d
      + myE.E + myF.f(y) + myG.g()


resource module Main
  instantiate C() as cForX
  instantiate D() as dForX
  instantiate X(cForX, dForX) as x
// instantiate X(instantiate C(), instantiate D())



\end{lstlisting}
\end{minipage}
\end{tabular}


\newpage

\subsection{Abstract Grammar}
\[
\begin{array}{cllr}
p & ::= & e & program \\
&&\\
m & ::= & h~\overline{i}~\overline{d} & module \\
&&\\
h & ::= & [\keywadj{resource}]~\keyw{module} x : t & module~header \\
&&\\
i & ::= & \keyw{import} x~[\keyw{as} y] \\
  & |   & \keyw{instantiate} x(\overline{y})~[\keyw{as} y] \\
  & |   & \keyw{require} t~[\keyw{as} y]\\
&&\\
sm & ::= & [\keywadj{resource}]~\keyw{signature} x = \tau; sm &~~~signatures~module \\
&&\\
d & ::= & ... & declarations \\
&&\\
e & ::= & ... & expressions \\
&&\\
\end{array}
\]

\noindent\textbf{Notes:}
\begin{itemize}
\item The program is an expression $e$, which is syntactic sugar for

$\keywadj{new}_s(x \Rightarrow \keyw{def} m(y : Unit) : \tau = e).m(\keywadj{new}_{\keywadj{pure}}(x \Rightarrow \epsilon))$.
\item Declarations and expressions (static forms, except for $\keywadj{bind}$) are defined by regular Wyvern.
\item $sm$ is a module that defines only module signatures.
\item Signatures are translated to top-level type abbreviations.
\item All module signatures are declared in the signatures module (even if the modules are nested).
\item Module names ($x$s in the grammar) are specified by URIs.
\item $t$ is a type variable.
\item $\keywadj{import}$ is for non-resource modules whose implementation you specify directly.
\item $\keywadj{instantiate}$ is for specifying the parameter of some parameterized module and for creating a resource module. (It is assumed that modules can call native code only if they are an FFI module.)
\item In $\keywadj{instantiate}$, $\overline{y}$ must come either from $\keywadj{import}$s or $\keywadj{require}$s.
\item $\keyw{instantiate} X(\keyw{instantiate} Y_1(), \keyw{instantiate} Y_2())$ can be used as a shorthand.
\item $\keywadj{instantiate}$ can be used not only in the main module, but also in other modules, which provides a higher level of abstraction.
\item $\keywadj{require}$ is used to specify module parameters; the $t$ is the module signature (type variable).

\end{itemize}


\newpage

\subsection{Translation Rules}

$\textit{trans}(\keyw{def} m(x : \tau_1) : \tau_2) \equiv \keyw{def} m : \tau_1 \rightarrow \tau_2$\\
\\
$\textit{trans}(\keyw{signature} M = \overline{\sigma}) \equiv \keyw{signature} M = trans(\overline{\sigma})$ \\
$\textit{trans}(\keyw{signature} \keyw{resource} M = \overline{\sigma}) \equiv \keyw{signature} \keyw{resource} M = trans(\overline{\sigma})$ \\

\noindent$trans(\keyw{module} M : \tau; d) \equiv \keyw{val} M : \tau = \keyw{bind} \keyw{in} \keywadj{new}(M \Rightarrow \overline{d})$
\\\\
\noindent$\textit{trans}(\overline{i}) \equiv$\\
\indent if $\keyw{import} M_1~\keyw{as} M; \overline{i'}$ then $\keyw{val} M = M_1; trans(\overline{i'})$\\
\indent if $\keyw{instantiate} M_1(\overline{M_2})~\keyw{as} M; \overline{i'}$ then $ \keyw{val} M = M_1(\overline{M_2}); trans(\overline{i'})$\\
\indent if $\keyw{require} \tau~\keyw{as} M; \overline{i'}$ then $ M : \tau,~trans(\overline{i'})$\\
\\
$filterImportsAndInstantiates(\overline{i}) = $\\
\indent if $\keyw{import} M_1~\keyw{as} M; \overline{i'}$ then return $\keyw{import} M_1~\keyw{as} M; filterImportsAndInstantiates(\overline{i'})$\\
\indent if $\keyw{instantiate} M_1(\overline{M_2})~\keyw{as} M; \overline{i'}$ then return $\keyw{instantiate} M_1(\overline{M_2})~\keyw{as} M; filterImportsAndInstantiates(\overline{i'})$\\
\indent if $\keyw{require} \tau~\keyw{as} M; \overline{i'}$ then return $filterImportsAndInstantiates(\overline{i'})$\\
\indent if $\overline{i}$ is empty then return $\varnothing$ \\

\noindent$filterRequires(\overline{i}) = $\\
\indent if $\keyw{import} M_1~\keyw{as} M; \overline{i'}$ then return $filterRequires(\overline{i'})$\\
\indent if $\keyw{instantiate} M_1(\overline{M_2})~\keyw{as} M; \overline{i'}$ then return $filterRequires(\overline{i'})$\\
\indent if $\keyw{require} \tau~\keyw{as} M; \overline{i'}$ then return $\keyw{require} \tau~\keyw{as} M; filterRequires(\overline{i'})$\\
\indent if $\overline{i}$ is empty then return $\keyw{require} \keyw{Unit} \keyw{as} \_$ \\

\noindent$getTypes(\overline{x : \tau}) = $ if $\overline{x : \tau}$ is empty return $\keywadj{Unit}$, otherwise return $\overline{\tau}$\\

\noindent$trans(\keyw{resource} \keyw{module} M : \tau; \overline{i}; \overline{d}) \equiv$

$\keyw{val} M : getTypes(trans(filterRequires(\overline{i}))) \rightarrow \tau = $

$\keyw{fn} trans(filterRequires(\overline{i})) \Rightarrow~\keyw{bind} trans(filterImportsAndInstantiates(\overline{i})~\keyw{in} \keywadj{new}(M \Rightarrow \overline{d})$\\

\noindent If the module does not require or instantiate any modules, then its translation is simplified as follows:
\\\\
\noindent$trans(\keyw{resource} \keyw{module} M : \tau; \overline{d}) \equiv \keyw{val} M : \keyw{Unit} \rightarrow \tau = \keyw{fn} \_ : \keyw{Unit} \Rightarrow~\keyw{bind} \keyw{in} \keywadj{new}(M \Rightarrow \overline{d})$
\\\\
Translation of module signatures: $\keyw{type} t = \tau~\keyw{in} e \equiv [\tau / t]e$
\\\\
Translation of $\keywadj{fn}$s in module objects: \mbox{$\keywadj{fn}_s~y : \tau \Rightarrow e \equiv \keywadj{new}_s(x \Rightarrow \keyw{def} apply(y : \tau) : \tau' = e)$}, where \\ \mbox{$\Gamma~|~\Sigma \vdash \keywadj{fn}_s~y : \tau \Rightarrow e~:~\tau'$}. Then, $e(e') \equiv e.apply(e')$.
\\\\
Translation of $\keywadj{val}$s in an object: $\keyw{val} f : \tau = l \equiv \keyw{def} f() : \tau = l$

\newpage

\section{Authority}

\subsection{Rules}

$\fbox{$~pointsto(e, \mu)~$}$
\[
\begin{array}{c}
\infer[\textsc{(pointsto-empty)}]
  {pointsto(\varnothing, \mu) = \varnothing}
  {}\\[5ex]
%~~~~~~~~~~
\infer[\textsc{(pointsto-var)}]
  {pointsto(E[x],\mu) = pointsto(subexps(E), \mu)}
  {l.m(l') \rhd E' \not\in E}\\[5ex]
%~~~~~~~~~~
\infer[\textsc{(pointsto-new)}]
  {pointsto(E[\keywadj{new}_{s}(x \Rightarrow \overline{d})],\mu) = pointsto(\overline{d},\mu) \cup pointsto(subexps(E), \mu)}
  {l.m(l') \rhd E' \not\in E}\\[5ex]

%\infer[\textsc{(pointsto-method)}]
%  {pointsto(E[e.m(e')],\mu) = pointsto(e,\mu) \cup pointsto(e',\mu) \cup pointsto(subexps(E), \mu)}
%  {l.m(l') \rhd E' \not\in E}\\[5ex]
%
%\infer[\textsc{(pointsto-field)}]
%  {pointsto(E[e.f],\mu) = pointsto(e,\mu) \cup pointsto(subexps(E), \mu)}
%  {l.m(l') \rhd E' \not\in E}\\[5ex]
%
%\infer[\textsc{(pointsto-assign)}]
%  {pointsto(E[e.f = e'],\mu) = pointsto(e,\mu) \cup pointsto(e',\mu) \cup pointsto(subexps(E), \mu)}
%  {l.m(l') \rhd E' \not\in E}\\[5ex]
%
%\infer[\textsc{(pointsto-bind)}]
%  {pointsto(E[\keyw{bind} x = e~\keyw{in} e'],\mu) = pointsto(e,\mu) \cup pointsto(e',\mu) \cup pointsto(subexps(E), \mu)}
%  {l.m(l') \rhd E' \not\in E}\\[5ex]

\infer[\textsc{(pointsto-principal)}]
  {pointsto(E[l],\mu) = \{ l \} \cup pointsto(subexps(E), \mu)}
  {l \mapsto \{ x \Rightarrow \overline{d} \}_\keywadj{stateful} \in \mu & l'.m(l'') \rhd E' \not\in E}\\[5ex]
%~~~~~~~~~~
\infer[\textsc{(pointsto-pure)}]
  {pointsto(E[l],\mu) = pointsto(subexps(E), \mu)}
  {l \mapsto \{ x \Rightarrow \overline{d} \}_\keywadj{pure} \in \mu & l'.m(l'') \rhd E' \not\in E}\\[5ex]

\infer[\textsc{(pointsto-call-principal)}]
  {pointsto(E[l.m(l') \rhd e],\mu) = \{ l \} \cup pointsto(subexps(E), \mu)}
  {l \mapsto \{ x \Rightarrow \overline{d} \}_\keywadj{stateful} \in \mu & l''.m'(l''') \rhd E' \not\in E}\\[5ex]

\infer[\textsc{(pointsto-call-pure)}]
  {pointsto(E[l.m(l') \rhd e],\mu) = pointsto(e,\mu) \cup pointsto(subexps(E), \mu)}
  {l \mapsto \{ x \Rightarrow \overline{d} \}_\keywadj{pure} \in \mu & l''.m'(l''') \rhd E' \not\in E}\\[5ex]

%\infer[\textsc{(pointsto-otherexp)}]
%  {pointsto(E[e],\mu) = \bigcup pointsto(subexps(e),\mu)}
%  {\textit{$e$ is not one of the expression forms defined above}}\\[5ex]

\end{array}
\]

$\fbox{$~pointsto(\overline{d}, \mu)~$}$
\[
\begin{array}{c}
\infer[\textsc{(pointsto-decls)}]
  {pointsto(\overline{d}, \mu) = \bigcup_{d \in \overline{d}} pointsto(d, \mu)}
  {}\\[5ex]
  
\end{array}
\]

$\fbox{$~pointsto(d, \mu)~$}$
\[
\begin{array}{c}
%\infer[\textsc{(pointsto-emptydecl)}]
%  {pointsto(\epsilon,\mu) = \varnothing}
%  {}\\[5ex]

\infer[\textsc{(pointsto-def)}]
  {pointsto(\keyw{def} m(x : \tau_1) : \tau_2 = e, \mu) = pointsto(e, \mu)}
  {}\\[5ex]
  
\infer[\textsc{(pointsto-varx)}]
  {pointsto(\keyw{var} f:\tau = x,\mu) = \varnothing}
  {}\\[5ex]
%~~~~~~~~~~
\infer[\textsc{(pointsto-varl)}]
  {pointsto(\keyw{var} f:\tau = l,\mu) = pointsto(l,\mu)}
  {}\\[5ex]

\end{array}
\]

$\fbox{$~auth()~$}$
\[
\begin{array}{c}
\infer[\textsc{(auth-store)}]
  {auth_{store}(l,\mu) = pointsto(l, \mu) \cup pointsto(\overline{d},\mu)}
  {l \mapsto \{ x \Rightarrow \overline{d} \}_{s} \in \mu}\\[5ex]

\infer[\textsc{(auth-stack-nocall)}]
  {auth_{stack}(l, e, \mu) = \varnothing}
  {l.m(l') \rhd e' \not\in e}\\[5ex]
%~~~~~~~~~~
\infer[\textsc{(auth-stack)}]
  {auth_{stack}(l, e, \mu) = pointsto(e',\mu) \cup auth_{stack}(l,e',\mu)}
  {e = E[l.m(l') \rhd e'] & l.m'(l'') \rhd E' \not\in E}\\[5ex]
  
\infer[\textsc{(auth-config)}]
  {auth(l,e, \mu) = auth_{store}(l,\mu) \cup auth_{stack}(l,e,\mu)}
  {}\\[5ex]

\end{array}
\]

$\fbox{$~subexps(E)~$}$
\[
\begin{array}{c}
\infer[\textsc{(subexps-e-empty)}]
  {subexps([~]) = \varnothing}
  {}\\[5ex]
%~~~~~~~~~~
\infer[\textsc{(subexps-e-method1)}]
  {subexps(E.m(e)) = \{ e \} \cup subexps(E)}
  {}\\[5ex]
  
\infer[\textsc{(subexps-e-method2)}]
  {subexps(l.m(E)) = \{ l \} \cup subexps(E)}
  {}\\[5ex]
%~~~~~~~~~~
\infer[\textsc{(subexps-e-field)}]
  {subexps(E.f) = subexps(E)}
  {}\\[5ex]

\infer[\textsc{(subexps-e-assign1)}]
  {subexps(E.f = e) = \{ e \} \cup subexps(E)}
  {}\\[5ex]
%~~~~~~~~~~
\infer[\textsc{(subexps-e-bind)}]
  {subexps(\keyw{bind} x = E~\keyw{in} e) = \{ e \} \cup subexps(E)}
  {}\\[5ex]  

\infer[\textsc{(subexps-e-assign2)}]
  {subexps(l.f = E) = \{ l \} \cup subexps(E)}
  {}\\[5ex]
%~~~~~~~~~~
\infer[\textsc{(subexps-e-stackframe)}]
  {subexps(l.m(l') \rhd E) = \{ l \} \cup \{ l' \} \cup subexps(E)}
  {}\\[5ex]
\end{array}
\]

$\fbox{$~lookupCaller(E)~$}$
\[
\begin{array}{c}
\infer[\textsc{(lookupCaller)}]
  {lookupCaller(E) = l}
  {l.m(l') \rhd E' \in E & l''.m'(l''') \rhd E'' \not\in E'}\\[5ex]
\end{array}
\]

\newpage
\subsection{Definitions}
\label{sec:definitions}

\begin{itemize}
\item A \textit{principal} is a stateful object.
\item A \textit{pure} object is an object that captures no mutable state.
\item An object can \emph{directly access} a principal if the object either has a reference to the principal or can access the principal via methods (e.g. when the principal is passed in as a parameter).
\item ``$pointsto(e, \mu) = \{ ... \}$'' means that, in the context of memory $\mu$, the expression $e$ can directly access principals identified (pointed to) by locations in $\{ ... \}$.
\item ``$auth_{store}(l, \mu) = \{ ... \}$'' means that, in the context of memory $\mu$, the principal identified by $l$ can directly access the other principals identified by locations in $\{ ... \}$, by virtue of $l$'s (static) state.
\item ``$auth_{stack}(l, e, \mu) = \{ ... \}$'' means that, in the context of memory $\mu$, the principal identified by $l$ can directly access the other principals identified by locations in $\{ ... \}$, by virtue of the execution state of methods of $l$ executing in $e$.
\item The difference in meaning between $auth_{store}(l, \mu)$ and $pointsto(l, \mu)$ is that, in the latter, $l$ is treated as an expression, not a principal, and so the only location it can access is $l$.
\item The difference between $auth_{store}()$ and $auth_{stack}()$ is that, in the latter: 1) arguments are concrete, and 2) the method body may have been re-written to something else that may have new principals (due to acquiring access to a new location pointing to a principal via a return, creating new temporary variables with such new locations (three address code), etc.).
\item The expression $l.m(l_1) \rhd e$ means that we are currently executing a method $m$ of the receiver (object) $l$ having given it an argument $l_1$, and the method body is $e$. This expression was introduced to to keep track of that the LHS expression has access to.
\item The \textsc{pointsto-otherexp} rule is a shorthand; the rest of the \textit{pointsto} rules for expressions are just congruence---look inside the $e$s.
\item In the \textsc{auth-stack} rule, $l''$ represents the concrete argument that was passed in, and $l'$ can be arbitrary since it is substituted with $l''$ right away.  It is likely that $l$ is part of $e'$. In the conclusion, it is possible that the argument was not used, or it was used but is not being used any more, in which case, $l$ no longer has authority over $l'$. The premise makes sure that, as we go down the stack, we do not miss any calls to methods of $l$. (To see why, one could try applying the rule to a stack that has two calls and try to make it match the inner rather than the outer one. This is possible without the premise, but impossible with it.)
\item Specification for $lookupCaller(E)$:
\item[] \emph{Input:} evaluation context $E$
\item[] \emph{Output:} Let $E''$ be the innermost evaluation context of $E$ that has the form $l.m(l') \rhd E'$. Return $l$.

\end{itemize}


\subsubsection{Authority safety}

\begin{itemize}
\item Authority can be possessed by either a principal (a stateful object) or an expression. (See $pointsto()$ rules.)

\item Our definition of an \emph{object} comes directly from object-oriented programming and means an encapsulation of state and functionality. Then, having \emph{authority over a principal} means having access to the principal's state and functionality.

\item \emph{Authority} is the upper bound on the set of principals (stateful objects) that a subject (another principal or an expression) can access and act upon.

\item The \emph{authority of an object or an expression} is the union of the set of all principals (stateful objects) the current principal or expression has access to.

\item The authority of an object can change due to actions performed by other objects. For example:
\begin{itemize}
\item If an object A creates a new object B, A gains authority over B.
\item If a principal A, authority for which an object B does not have, is passed in as an argument to the object B's method by some caller object C, which has authority over A, then B (perhaps only temporarily) gains authority over A.
\item If a principal A, authority for which an object B does not have, was returned from a method call that B initiated, then B gains authority over A.
\end{itemize}

\item The authority of an expression can change as the expression is being executed.

\item The authority of an object (with respect to the store) can be statically determined by the code stored in the object. (See the \textsc{auth-store} rule.)

\item A principal can lose authority and become a pure object, e.g. on a reassignment of a principal's field (if the field ceased to hold a principal) or on a return of a principal's method (if the method received some authority via arguments and did not save the authority within the principal).

\end{itemize}


\newpage

\subsection{Theory}

\begin{mdframed}
\begin{lemma}
\label{l:ses-e}
If $l.m(l') \rhd E' \not\in E$, then $pointsto(E[e], \mu) = pointsto(e, \mu) \cup pointsto(subexps(E), \mu)$.
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the $pointsto(e, \mu)$ rules.

\noindent\underline{\textit{Case \textsc{pointsto-empty}:}} By \textsc{subexps-e-empty}, $subexps([~]) = \varnothing$, and the result is immediate.

\noindent\underline{\textit{Case \textsc{pointsto-var}:}} $pointsto(x, \mu) = \varnothing~~~~~~~~~~~~~~~~~~~~~~~~~~(\textsc{pointsto-var}, \textsc{pointsto-empty})~[1]$
\vspace{-7pt}
\begin{align*}
pointsto(E[x], \mu) &= pointsto(subexps(E), \mu) & (\textsc{pointsto-var})\\
&= pointsto(x, \mu) \cup pointsto(subexps(E), \mu) & (by~[1])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-new}:}} $pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}), \mu) = pointsto(\overline{d}, \mu)~~~~(\textsc{pointsto-new}, \textsc{pointsto-empty})~[2]$
\vspace{-7pt}
\begin{align*}
pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) &= pointsto(\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-new})\\
&= pointsto(\keywadj{new}_s(x \Rightarrow \overline{d}), \mu) \cup pointsto(subexps(E), \mu) & (by~[2])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-principal}:}} By inversion on \textsc{pointsto-principal}, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}}$.
\vspace{-7pt}
\begin{align*}
pointsto(l, \mu) &= \{ l \} & (\textsc{pointsto-principal}, \textsc{pointsto-empty})~[3]\\
pointsto(E[l], \mu) &= \{ l \} \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-principal})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (by~[3])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-pure}:}} By inversion on \textsc{pointsto-pure}, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{pure}}$.
\vspace{-7pt}
\begin{align*}
pointsto(l, \mu) &= \varnothing & (\textsc{pointsto-pure}, \textsc{pointsto-empty})~[4]\\
pointsto(E[l], \mu) &= pointsto(subexps(E), \mu) & (\textsc{pointsto-pure})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (by~[4])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-call-principal}:}} By inversion on \textsc{pointsto-call-principal}, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}}$.

\noindent$~~~~~pointsto(l.m(l') \rhd e', \mu) = \{ l \}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(\textsc{pointsto-call-principal}, \textsc{pointsto-empty})~[5]$
\vspace{-7pt}
\begin{align*}
pointsto(E[l.m(l') \rhd e'], \mu) &= \{ l \} \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-principal})\\
&= pointsto(l.m(l') \rhd e', \mu) \cup pointsto(subexps(E), \mu) & (by~[5])
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-call-pure}:}} By inversion on \textsc{pointsto-call-pure}, we get $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{pure}}$.

$~~~pointsto(l.m(l') \rhd e', \mu) = pointsto(e', \mu)~~~~~~~~~~~~~~~~~~~~~(\textsc{pointsto-call-pure}, \textsc{pointsto-empty})~[6]$
\vspace{-7pt}
\begin{align*}
pointsto(E[l.m(l') \rhd e'], \mu) &= pointsto(e', \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-call-pure})\\
&= pointsto(l.m(l') \rhd e', \mu) \cup pointsto(subexps(E), \mu) & (by~[6])
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:simplify-a-stack}
If $l.m(l') \rhd E' \not\in E$, then $auth_{stack}(E[l.m(l') \rhd e'], \mu) = auth_{stack}(l.m(l') \rhd e', \mu)$.
\end{lemma}
\end{mdframed}

\begin{proof} $~~auth_{stack}(E[l.m(l') \rhd e'], \mu) = pointsto(e', \mu) \cup auth_{stack}(l, e', \mu)~~~~~~~~~~~~~~~(\textsc{auth-stack})$
\vspace{-7pt}
\begin{align*}
auth_{stack}(l.m(l') \rhd e', \mu) &= pointsto(e', \mu) \cup auth_{stack}(l, e', \mu)& (\textsc{auth-stack})
\end{align*}
Thus, $auth_{stack}(E[l.m(l') \rhd e'], \mu) = auth_{stack}(l.m(l') \rhd e', \mu)$.
\qed
\end{proof}


\newpage
\begin{mdframed}
\begin{lemma}
\label{l:pt-all-pure}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l.m(l') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item for $1 \leq i \leq k$, $l_i \mapsto \{ x \Rightarrow \overline{d_i} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{70pt} [callers in all method call stack frames are pure]}
\end{enumerate}
then
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup^k_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)
\end{align*}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $E_0[e]$ on the stack.

\noindent\underline{\textit{Base case:}} $k = 1$\\
\noindent$pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(subexps(E_1), \mu) \cup pointsto(E_0[e], \mu) & (\textsc{pointsto-call-pure}) \\
&= pointsto(subexps(E_1), \mu) \cup pointsto(subexps(E_0), \mu) \cup pointsto(e, \mu) & (Lemma~\textit{\ref{l:ses-e}}) \\
&= \bigcup^1_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)
\end{align*}

\noindent\underline{\textit{Inductive case:}} $k > 1$\\
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(subexps(E_k), \mu) & (\textsc{pointsto-call-pure}) \\
& \cup pointsto(E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= pointsto(subexps(E_k), \mu) \cup pointsto(subexps(E_{k-1}), \mu)& (\textsc{pointsto-call-pure}) \\
& \cup pointsto(E_{k-2}[l_{k-2}.m_{k-2}(l_{k-2}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
%&= \bigcup^k_{i = 2} pointsto(subexps(E_i), \mu) \cup pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{pointsto-call-pure} \times (k - 3)) \\
&= \bigcup^k_{i = 1} pointsto(subexps(E_i), \mu) \cup pointsto(E_0[e], \mu) & (\textsc{pointsto-call-pure} \times (k - 2)) \\
&= \bigcup^k_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) & (Lemma~\textit{\ref{l:ses-e}})
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:pt-has-stateful}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l.m(l') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $\exists j$, such that $1 \leq j \leq k$, $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$
\intuition{\newline [there is at least one method call stack frame that has a principal caller]}
\end{enumerate}
then
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup^k_{i = p} pointsto(subexps(E_i), \mu) \cup \{ l_p\},
\end{align*}
where $1 \leq p \leq k$ and $p$ is the greatest index, such that $l_p \mapsto \{ x \Rightarrow \overline{d_p} \}_{\keywadj{stateful}} \in \mu$.

\intuition{\noindent[$l_p$ is the first (furthest from $e$) principal method caller on the stack]}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $E_0[e]$ on the stack.

\noindent\underline{\textit{Base case:}} $k = 1$, and since $l_1$ is the only method call stack frame, $l_1 \mapsto \{ x \Rightarrow \overline{d_1} \}_{\keywadj{stateful}} \in \mu$ and $p = 1$.
\begin{align*}
pointsto(E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) &= pointsto(subexps(E_1), \mu) \cup \{ l_1 \} & (\textsc{pointsto-call-principal})
\end{align*}

\noindent\underline{\textit{Inductive case:}} $k > 1$\\
\noindent$pointsto(E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(subexps(E_k), \mu) & (\textsc{pointsto-call-pure}) \\
& \cup pointsto(E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= pointsto(subexps(E_k), \mu) \cup pointsto(subexps(E_{k-1}), \mu)& (\textsc{pointsto-call-pure}) \\
& \cup pointsto(E_{k-2}[l_{k-2}.m_{k-2}(l_{k-2}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^k_{i = p+1} pointsto(subexps(E_i), \mu) & (\textsc{pointsto-call-pure} \times (k - p - 2)) \\
& \cup pointsto(E_p[l_p.m_p(l_p') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
%& \cup pointsto(E_p[l_p.m_p(l_p') \rhd E_{p-1}[l_{p-1}.m_{p-1}(l_{p-1}') \rhd \dots \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^k_{i = p} pointsto(subexps(E_i), \mu) \cup \{ l_p \} & (\textsc{pointsto-call-principal})
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:main-a-stack}
If
\begin{enumerate}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$ \intuition{\hspace{270pt} [$l$ is a principal]}
\item $\forall i$, such that $l_i = l$, $i \in \{ q_1, q_2, \dots, q_{r_1} \}$, where $0 \leq r_1 \leq k$ \intuition{\newline [the set of indices of all method call stack frames where $l$ is the caller; this set can be empty]}
\item $\forall i \in \{ q_1, q_2, \dots, q_{r_1} \}$, if $\exists j$, such that
\begin{enumerate}
\item $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$ and \intuition{\hspace{220pt} [$l_j$ is a principal]}
\item $\forall t$, such that $i > t > j$ and $l_t \mapsto \{ x \Rightarrow \overline{d_t} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{40pt} [all callers between $l_i$ and $l_j$ are pure]}
\end{enumerate}
$j \in \{ p_1, p_2, \dots, p_{r_2}\}$ where $0 \leq r_2 \leq r_1$
\intuition{\newline [the maximal set of indices of principal callers immediately after method call stack frames where $l$ is the caller; this set can be smaller than the one above only by one element; this set can also be empty; such principals can be $l$ itself]}
\end{enumerate}
then
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e, \mu)\\
\end{cases}
\end{align*}
\intuition{[If $r_2 < r_1$, then there are only pure principals after the last method call stack frame where $l$ is the caller. In other words, $l$ was the last principal caller on the stack.\\
If $r_2 = r_1$, then the last method call stack frame where $l$ is the caller is followed by a method call stack frame with a principal caller that is not $l$. If $r_2 = r_1 = 0$, then there are no method call stack frames with principal callers on the stack.\\
Since the set in 4(b) can include indices of method call stack frames where the caller is $l$, the difference between $r_1$ and $r_2$ is at most $1$, i.e. $r_2 \le r_1 \le r_2 + 1$.]}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $e$ on the stack.\\

\noindent\underline{\underline{\textit{Base case:}}} $k = 1$. Depending on the values of $r_1$ and $r_2$, there are two possibilities.

\noindent\underline{\textit{Case $r_2 < r_1$:}} $r_1 = 1$, $r_2 = 0$, and $l_1 = l$\\
\noindent$auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E_0[e], \mu) \cup auth_{stack}(l, E_0[e], \mu) & (\textsc{auth-stack}) \\
&= pointsto(E_0[e], \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}}) \\
&= pointsto(subexps(E_0), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:ses-e}})
\end{align*}

\noindent\underline{\textit{Case $r_2 = r_1$:}} $r_1 = r_2 = 0$, and $l_1 \neq l$
\vspace{-7pt}
\begin{align*}
auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) &= auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})
\end{align*}

\noindent\underline{\underline{\textit{Inductive case:}}} $k > 1$\\
\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_{q_1}.m_{q_1}(l_{q_1}') \rhd E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&= pointsto(E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd E_{q_1-2}[l_{q_1-2}.m_{q_1-2}(l_{q_1-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu) & (\textsc{auth-stack})\\
&\cup auth_{stack}(l, E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd E_{q_1-2}[l_{q_1-2}.m_{q_1-2}(l_{q_1-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (Lemma~\textit{\ref{l:pt-has-stateful}})\\
&\cup auth_{stack}(l, E_{q_1-1}[l_{q_1-1}.m_{q_1-1}(l_{q_1-1}') \rhd E_{q_1-2}[l_{q_1-2}.m_{q_1-2}(l_{q_1-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
& =\bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, l_{q_2}.m_{q_2}(l_{q_2}') \rhd E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} & (\textsc{auth-stack})\\
&\cup pointsto(E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd E_{q_2-2}[l_{q_2-2}.m_{q_2-2}(l_{q_2-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&\cup auth_{stack}(l, E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd E_{q_2-2}[l_{q_2-2}.m_{q_2-2}(l_{q_2-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&= \bigcup^{q_1-1}_{i = p_1} pointsto(subexps(E_i), \mu) \cup \{ l_{p_1} \} \bigcup^{q_2-1}_{i = p_2} pointsto(subexps(E_i), \mu) \cup \{ l_{p_2} \}& (Lemma~\textit{\ref{l:pt-has-stateful}})\\
&\cup auth_{stack}(l, E_{q_2-1}[l_{q_2-1}.m_{q_2-1}(l_{q_2-1}') \rhd E_{q_2-2}[l_{q_2-2}.m_{q_2-2}(l_{q_2-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&\vdots\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} \\
&\cup auth_{stack}(l, E_{q_{r_2}-1}[l_{q_{r_2}-1}.m_{q_{r_2}-1}(l_{q_{r_2}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)
%&\cup auth_{stack}(l, E_{q_{r_2}-1}[l_{q_{r_2}-1}.m_{q_{r_2}-1}(l_{q_{r_2}-1}') \rhd E_{q_{r_2}-2}[l_{q_{r_2}-2}.m_{q_{r_2}-2}(l_{q_{r_2}-2}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)
\end{align*}
Depending on the values of $r_1$ and $r_2$, there are two possibilities.

\noindent\underline{\textit{Case $r_2 < r_1$:}} There is no other stateful callers after $l_{q_{r_2+1}}$, i.e.\\
$\forall l_0.m_0(l_0') \rhd E''' \in E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}')  \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ]$, \mbox{$l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{pure}} \in \mu$}, which implies that there are also no method call stack frames with $l$ as the caller after $l_{q_{r_2+1}}$, i.e.\\
$l.m'(l'') \rhd E'' \not\in E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}')  \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ]$\\

\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, l_{q_{r_2+1}}.m_{q_{r_2+1}}(l_{q_{r_2+1}}') \rhd E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}')  \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (\textsc{auth-stack})\\
&\cup pointsto(E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&\cup auth_{stack}(l, E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:pt-all-pure}})\\
&\cup \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu)\\
&\cup auth_{stack}(l, E_{q_{r_2+1}-1}[l_{q_{r_2+1}-1}.m_{q_{r_2+1}-1}(l_{q_{r_2+1}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}

\noindent\underline{\textit{Case $r_2 = r_1$:}} There are no method call stack frames with $l$ as the caller after $l_{q_{r_2+1}}$, i.e.\\
$l.m'(l'') \rhd E'' \not\in E_{q_{r_2}-1}[l_{q_{r_2}-1}.m_{q_{r_2}-1}(l_{q_{r_2}-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ]$\\

\noindent$auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=  \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & (Lemma~\textit{\ref{l:simplify-a-stack}})\\
&\cup auth_{stack}(l, e, \mu)
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:pt-ses}
If $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$, then $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the $subexps(E)$ rules.\\

\noindent\underline{\textit{Case \textsc{subexps-e-empty}:}} By \textsc{pointsto-empty}, $pointsto(\varnothing, \mu') = pointsto(\varnothing, \mu) = \varnothing$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-method1}:}} $pointsto(subexps(E.m(e'')), \mu) = pointsto(e'', \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(E.m(e'')), \mu') = pointsto(e'', \mu') \cup pointsto(subexps(E), \mu')$.

Since we are considering small-step semantics and $e''$ is evaluated only after $E$ is fully evaluated, there were no changes to $e''$ at this evaluation steps, and $pointsto(e'', \mu') = pointsto(e'', \mu)$. By the induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus, $pointsto(subexps(E.m(e'')), \mu') =pointsto(subexps(E.m(e'')), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-method2}:}} $pointsto(subexps(l.m(E)), \mu) = pointsto(l, \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(l.m(E)), \mu') = pointsto(l, \mu') \cup pointsto(subexps(E), \mu')$.

By \textsc{pointsto-principal}, \textsc{pointsto-pure}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$. By the induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus, $pointsto(subexps(l.m(E)), \mu') =pointsto(subexps(l.m(E)), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-field}:}} $pointsto(subexps(E.f), \mu) = pointsto(subexps(E), \mu)$, and similarly,\\
$pointsto(subexps(E.f), \mu') = pointsto(subexps(E), \mu')$. By the induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$, and thus, $pointsto(subexps(E.f), \mu') =pointsto(subexps(E.f), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-assign1}:}} $pointsto(subexps(E.f = e''), \mu) = pointsto(e'', \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(E.f = e''), \mu') = pointsto(e'', \mu') \cup pointsto(subexps(E), \mu')$.

Since we are considering small-step semantics and $e''$ is evaluated only after $E$ is fully evaluated, there were no changes to $e''$ at this evaluation steps, and $pointsto(e'', \mu') = pointsto(e'', \mu)$. By the induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus, $pointsto(subexps(E.f = e''), \mu') =pointsto(subexps(E.f = e''), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-bind}:}} $pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu) = pointsto(e'', \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu') = pointsto(e'', \mu') \cup pointsto(subexps(E), \mu')$.

Since we are considering small-step semantics and $e''$ is evaluated only after $E$ is fully evaluated, there were no changes to $e''$ at this evaluation steps, and $pointsto(e'', \mu') = pointsto(e'', \mu)$. By the induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus, $pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu') =pointsto(subexps(\keyw{bind} x = E~\keyw{in} e''), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-assign2}:}} $pointsto(subexps(l.f = E), \mu) = pointsto(l, \mu) \cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(l.f = E), \mu') = pointsto(l, \mu') \cup pointsto(subexps(E), \mu')$.

By \textsc{pointsto-principal}, \textsc{pointsto-pure}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$. By the induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus, $pointsto(subexps(l.f = E), \mu') =pointsto(subexps(l.f = E), \mu)$.\\

\noindent\underline{\textit{Case \textsc{subexps-e-stackframe}:}} $pointsto(subexps(l.m(l') \rhd E), \mu) = pointsto(l, \mu) \cup pointsto(l', \mu)$\\
$\cup pointsto(subexps(E), \mu)$, and similarly, $pointsto(subexps(l.m(l') \rhd E), \mu') = pointsto(l, \mu') \cup pointsto(l', \mu) \cup pointsto(subexps(E), \mu')$.

By \textsc{pointsto-principal}, \textsc{pointsto-pure}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$ and\\
$pointsto(l', \mu') = pointsto(l', \mu)$. By the induction hypothesis, $pointsto(subexps(E), \mu') = pointsto(subexps(E), \mu)$.

Thus, $pointsto(subexps(l.m(l') \rhd E), \mu') =pointsto(subexps(l.m(l') \rhd E), \mu)$.
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:a-diff}
If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$ \intuition{\hspace{230pt} [$e$ can make a step of evaluation]}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$ \intuition{\hspace{270pt} [$l$ is a principal]}
\item $\forall i$, such that $l_i = l$, $i \in \{ q_1, q_2, \dots, q_{r_1} \}$, where $0 \leq r_1 \leq k$ \intuition{\newline [the set of indices of all method call stack frames where $l$ is the caller; this set can be empty]}
\item $\forall i \in \{ q_1, q_2, \dots, q_{r_1} \}$, if $\exists j$, such that
\begin{enumerate}
\item $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$ and \intuition{\hspace{220pt} [$l_j$ is a principal]}
\item $\forall t$, such that $i > t > j$ and $l_t \mapsto \{ x \Rightarrow \overline{d_t} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{40pt} [all callers between $l_i$ and $l_j$ are pure]}
\end{enumerate}
$j \in \{ p_1, p_2, \dots, p_{r_2}\}$ where $0 \leq r_2 \leq r_1$
\intuition{\newline [the maximal set of indices of principal callers immediately after method call stack frames where $l$ is the caller; this set can be smaller than the one above only by one element; this set can also be empty; such principals can be $l$ itself]}
\end{enumerate}
then
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e']] \dots ], \mu')$\\
$\setminus~auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & \text{if } r_2 < r_1\\
    \setminus~auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')& \text{if } r_2 = r_1\\
    \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{cases}
\end{align*}
\intuition{[If $r_2 < r_1$, then there are only pure principals after the last method call stack frame where $l$ is the caller. In other words, $l$ was the last principal caller on the stack.\\
If $r_2 = r_1$, then the last method call stack frame where $l$ is the caller is followed by a method call stack frame with a principal caller that is not $l$. If $r_2 = r_1 = 0$, then there are no method call stack frames with principal callers on the stack.\\
Since the set in 5(b) can include indices of method call stack frames where the caller is $l$, the difference between $r_1$ and $r_2$ is at most $1$, i.e. $r_2 \le r_1 \le r_2 + 1$.]}
\end{lemma}
\end{mdframed}

\begin{proof} The proof is by induction on the number of method call stack frames preceding $e$ and $e'$ on the stack.\\

\noindent\underline{\underline{\textit{Base case:}}} $k = 1$. Depending on the values of $r_1$ and $r_2$, there are two possibilities.

\noindent\underline{\textit{Case $r_2 < r_1$:}} $r_1 = 1$, $r_2 = 0$, and $l_1 = l$\\
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup pointsto(subexps(E_0), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:main-a-stack}})
\end{align*}
Similarly,
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu')$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup pointsto(subexps(E_0), \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu')\\
&= auth_{store}(l, \mu') \cup pointsto(subexps(E_0), \mu) \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & (Lemma~\textit{\ref{l:pt-ses}})
\end{align*}
Then, 
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu')~\setminus~auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') \setminus auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}


\noindent\underline{\textit{Case $r_2 = r_1$:}} $r_1 = r_2 = 0$, and $l_1 \neq l$\\
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) \cup auth_{stack}(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu) & (\textsc{auth-config})\\
&= auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu) & (Lemma~\textit{\ref{l:simplify-a-stack}})
\end{align*}
Similarly,
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu') = auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')$. Then,\\
\noindent$auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e']], \mu')~\setminus~auth(l, E_1[l_1.m_1(l_1') \rhd E_0[e]], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu') \setminus auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{align*}

\noindent\underline{\underline{\textit{Inductive case:}}} $k > 1$\\
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu) & (\textsc{auth-config})\\
&\cup auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)\\
&=
\begin{cases}
    auth_{store}(l, \mu)\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu)\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e, \mu)\\
\end{cases} & (Lemma~\textit{\ref{l:main-a-stack}})
\end{align*}
Similarly,
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e']] \dots ], \mu')$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') & (\textsc{auth-config})\\
&\cup auth_{stack}(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e']] \dots ], \mu')\\
&=
\begin{cases}
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu') \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu')\\\\
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu') \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e', \mu')\\
\end{cases} & (Lemma~\textit{\ref{l:main-a-stack}})\\
&=
\begin{cases}
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 < r_1\\
    \bigcup^{q_{r_2+1}-1}_{i = 0} pointsto(subexps(E_i), \mu) \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu')\\\\
    auth_{store}(l, \mu')\\
    \bigcup_{(q, p) \in \{ (q_1, p_1), (q_2, p_2), \dots (q_{r_2}, p_{r_2}) \}} \bigcup^{q-1}_{i = p} pointsto(subexps(E_i), \mu) \bigcup_{j \in \{ p_1, p_2, \dots, p_{r_2} \}} \{ l_j \} & \text{if } r_2 = r_1\\
    \cup auth_{stack}(l, e', \mu')\\
\end{cases} & (Lemma~\textit{\ref{l:pt-ses}})
\end{align*}
Then, 
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e']] \dots ], \mu') \setminus auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_1[l.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & \text{if } r_2 < r_1\\
    \setminus~auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')& \text{if } r_2 = r_1\\
    \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{cases}
\end{align*}
\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:sub-in-ses}
If $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$ and $z \in E$, then $subexps([l / z]E) = \{ l \} \cup subexps(E)$.
\end{lemma}
\end{mdframed}

\begin{proof}
The proof is by a straightforward induction on the $subexps(E)$ rules.\qed
\end{proof}


\begin{mdframed}
\begin{lemma}
\label{l:sub-in-pt}
If $l \mapsto \{ x \Rightarrow \overline{d} \}_s \in \mu$ and $l'.m'(l'') \rhd E \not\in e$, then
\[
pointsto([l / z]e, \mu) =
\begin{cases}
    pointsto(l, \mu) \cup pointsto(e, \mu) & \text{if } z \in e\\
    pointsto(e, \mu) & \text{if } z \not\in e\\
\end{cases}
\]
\end{lemma}
\end{mdframed}

\begin{proof} There are two cases depending on whether $z$ is in $e$ or not.\\

\noindent\underline{\underline{\textit{Case $z \in e$:}}} We prove this case by simultaneous induction on the $pointsto(d, \mu)$, $pointsto(\overline{d}, \mu)$, and $pointsto(e, \mu)$ rules.

\noindent\underline{\textit{Case \textsc{pointsto-def}:}}
\vspace{-7pt}
\begin{align*}
pointsto([l / z](\keyw{def} m(x : \tau_1) : \tau_2 = e')) &= pointsto(\keyw{def} m(x : \tau_1) : \tau_2 = [l / z]e', \mu)\\
&= pointsto([l / z]e', \mu) & (\textsc{pointsto-def})\\
&= pointsto(l, \mu) \cup pointsto(e', \mu) & (by~IH)\\
&= pointsto(l, \mu) \cup pointsto(\keyw{def} m(x : \tau_1) : \tau_2 = e', \mu) & (\textsc{pointsto-def})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-varx}:}} Since there is only one variable, $x = z$.
\vspace{-7pt}
\begin{align*}
pointsto([l / z](\keyw{var} f : \tau = x), \mu) &= pointsto(\keyw{var} f : \tau = l, \mu)\\
&= pointsto(l, \mu) & (\textsc{pointsto-varl})\\
&= pointsto(l, \mu) \cup pointsto(\keyw{var} f : \tau = x, \mu) & (\textsc{pointsto-varx})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-varl}:}} Since there are no variables, the substitution cannot take place, and the case is true by contradiction.

\noindent\underline{\textit{Case \textsc{pointsto-decls}:}} $pointsto([l / z]\overline{d}, \mu)$
\vspace{-7pt}
\begin{align*}
&= \bigcup_{d \in \overline{d}} pointsto([l / z]d, \mu) & (\textsc{pointsto-decls})\\
&= pointsto(l, \mu) \bigcup_{d \in \overline{d}} pointsto(d, \mu) & (by~cases~\textsc{pointsto-def}, \textsc{pointsto-varx},~and~\textsc{pointsto-varl})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) & (\textsc{pointsto-decls})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-empty}:}} $z \not\in \varnothing$ and the case is true by contradiction.

\noindent\underline{\textit{Case \textsc{pointsto-var}:}} $e = E[x]$. There are three subcases depending on whether $x = z$ and $z \in E$.

\noindent\underline{\textit{Subcase $x \neq z$ and $z \in E$:}} $[l / z]E[x] = E'[x]$, where $E' = [l / z]E$.
\begin{align*}
pointsto([l / z]E[x], \mu) &= pointsto(E'[x], \mu)\\
&= pointsto(subexps(E'), \mu) & (\textsc{pointsto-var})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[x], \mu) & (\textsc{pointsto-var})
\end{align*}

\noindent\underline{\textit{Subcase $x = z$ and $z \not\in E$:}} $[l / z]E[x] = E[l]$.\\
$pointsto([l / z]E[x], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E[l], \mu)\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-principal, pointsto-pure, pointsto-empty})\\
&= pointsto(l, \mu) \cup pointsto(E[x], \mu) & (\textsc{pointsto-var})
\end{align*}

\noindent\underline{\textit{Subcase $x = z$ and $z \in E$:}} $[l / z]E[x] = E'[l]$, where $E' = [l / z]E$.\\
$pointsto([l / z]E[x], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E'[l], \mu)\\
&= pointsto(l, \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-principal, pointsto-pure, pointsto-empty})\\
&= pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[x], \mu) & (\textsc{pointsto-var})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-principal} or \textsc{pointsto-pure}:}} $e = E[l']$ and $z \in E$. Then, $[l / z]E[l'] = E'[l']$, where \mbox{$E' = [l / z]E$}.\\
$pointsto([l / z]E[l'], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E'[l'], \mu)\\
&= pointsto(l', \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-principal, pointsto-pure, pointsto-empty})\\
&= pointsto(l', \mu) \cup pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[l'], \mu) & (\textsc{pointsto-principal, pointsto-pure, pointsto-empty})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-new}:}} There are three subcases depending on whether $z \in \overline{d}$ and $z \in E$.

\noindent\underline{\textit{Subcase $z \not\in \overline{d}$ and $z \in E$:}} $[l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})] = E'[\keywadj{new}_s(x \Rightarrow \overline{d})]$, where $E' = [l / z]E$.
\begin{align*}
pointsto([l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) &= pointsto(E'[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu)\\
&= pointsto(\overline{d}, \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-new})\\
&= pointsto(\overline{d}, \mu) \cup pointsto(l, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) & (\textsc{pointsto-new})
\end{align*}

\noindent\underline{\textit{Subcase $z \in \overline{d}$ and $z \not\in E$:}} $[l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})] = E[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})]$.\\
$pointsto([l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})], \mu)\\
&= pointsto([l / z]\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (\textsc{pointsto-new})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (by~case~\textsc{pointsto-decls})\\
&= pointsto(l, \mu) \cup pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) & (\textsc{pointsto-new})
\end{align*}

\noindent\underline{\textit{Subcase $z \in \overline{d}$ and $z \in E$:}} $[l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})] = E'[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})]$, where $E' = [l / z]E$.\\
$pointsto([l / z]E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(E'[\keywadj{new}_s(x \Rightarrow [l / z]\overline{d})], \mu)\\
&= pointsto([l / z]\overline{d}, \mu) \cup pointsto(subexps(E'), \mu) & (\textsc{pointsto-new})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(subexps(E'), \mu) & (by~case~\textsc{pointsto-decls})\\
&= pointsto(l, \mu) \cup pointsto(\overline{d}, \mu) \cup pointsto(subexps(E), \mu) & (Lemma~\textit{\ref{l:sub-in-ses}})\\
&= pointsto(l, \mu) \cup pointsto(E[\keywadj{new}_s(x \Rightarrow \overline{d})], \mu) & (\textsc{pointsto-new})
\end{align*}

\noindent\underline{\textit{Case \textsc{pointsto-call-principal} or \textsc{pointsto-call-pure}:}} Since both the cases have method call stack frames and the premise prohibits that, the cases are true by contradiction.\\

\noindent\underline{\underline{\textit{Case $z \not\in e$:}}} $[l / z]e = e$ and $pointsto([l / z]e, \mu) = pointsto(e, \mu)$.\\
\qed
\end{proof}



\newpage
\begin{theorem}[Authority Safety] If
\begin{enumerate}
\item $e~|~\mu \longrightarrow e'~|~\mu'$,
\item $l_0 \mapsto \{ x \Rightarrow \overline{d_0} \}_{\keywadj{stateful}} \in \mu'$,
\item $l \mapsto \{ x \Rightarrow \overline{d} \}_{\keywadj{stateful}} \in \mu$, and
\item $auth(l, e', \mu') \setminus auth(l, e, \mu) \supseteq \{ l_0 \}$,
\end{enumerate}
then one of the following must be true:
\begin{itemize}
\item \textbf{Object creation:}
\begin{enumerate}
\item $e = E[l.m(l') \rhd E'[\keywadj{new}_{\keywadj{stateful}}(x \Rightarrow \overline{d_0})]]$ and
\item $e' = E[l.m(l') \rhd E'[l_0]]$, where
\item $\forall l_a.m_a(l_a') \rhd E'' \in E'$, $l_a \mapsto \{ x \Rightarrow \overline{d_a}\}_{\keywadj{pure}} \in \mu$ \intuition{\newline [there are only pure principals after the last method call stack frame where $l$ is the caller.]}
\end{enumerate}

\item \textbf{Method call:}
\begin{enumerate}
\item $e = E[l.m(l_0)]$ and
\item $e' = E[l.m(l_0) \rhd [l_0/y][l/x]e'']$
\item $y \in e''$ \intuition{\hspace{100pt} [the passed-in argument $y$ is used in the method body $e''$]}
\end{enumerate}

\item \textbf{Method return:}
\begin{enumerate}
\item $e = E[l.m(l') \rhd E'[l_a.m_a(l_a') \rhd l_0]]$ and
\item $e' = E[l.m(l') \rhd E'[l_0]]$, where
\item $\forall l_b.m_b(l_b') \rhd E'' \in E'$, $l_b \mapsto \{ x \Rightarrow \overline{d_b}\}_{\keywadj{pure}} \in \mu$ \intuition{\newline [there are only pure principals after the last method call stack frame where $l$ is the caller.]}
\end{enumerate}
\end{itemize}

\end{theorem}

\begin{proof} The proof is by induction on a derivation of $e~|~\mu \longrightarrow e'~|~\mu'$. For a given derivation, we proceed by cases on the last evaluation rule used:\\

\sloppy

\noindent\fbox{\parbox{\widthof{Case \textsc{E-Congruence}:}}{Case \textsc{E-Congruence}:}} $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$

Let us enumerate method call stack frames in $E$:
\begin{align*}
E[e] &= E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ]\\
E[e'] &= E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e']] \dots ]
\end{align*}
where
\begin{enumerate}
\item for $0 \leq i \leq k$, $l'.m(l'') \rhd E' \not\in E_i$ \intuition{\hspace{150pt} [no method call stack frames in $E_i$]}
\item $\forall i$, such that $l_i = l$, $i \in \{ q_1, q_2, \dots, q_{r_1} \}$, where $0 \leq r_1 \leq k$ \intuition{\newline [the set of indices of all method call stack frames where $l$ is the caller; this set can be empty]}
\item $\forall i \in \{ q_1, q_2, \dots, q_{r_1} \}$, if $\exists j$, such that
\begin{enumerate}
\item $l_j \mapsto \{ x \Rightarrow \overline{d_j} \}_{\keywadj{stateful}} \in \mu$ and \intuition{\hspace{230pt} [$l_j$ is a principal]}
\item $\forall t$, such that $i > t > j$ and $l_t \mapsto \{ x \Rightarrow \overline{d_t} \}_{\keywadj{pure}} \in \mu$ \intuition{\hspace{60pt} [all callers between $l_i$ and $l_j$ are pure]}
\end{enumerate}
$j \in \{ p_1, p_2, \dots, p_{r_2}\}$ where $0 \leq r_2 \leq r_1$
\intuition{\newline [the maximal set of indices of principal callers immediately after method call stack frames where $l$ is the caller; this set can be smaller than the one above only by one element; this set can also be empty; such principals can be $l$ itself]}
\end{enumerate}
Then,
\noindent$auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e']] \dots ], \mu')$\\
$\setminus~auth(l, E_k[l_k.m_k(l_k') \rhd E_{k-1}[l_{k-1}.m_{k-1}(l_{k-1}') \rhd \dots \rhd E_2[l_2.m_2(l_2') \rhd E_1[l_1.m_1(l_1') \rhd E_0[e]] \dots ], \mu)$
\vspace{-7pt}
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu') \cup pointsto(e', \mu') \cup auth_{stack}(l, e', \mu') & \text{if } r_2 < r_1\\
    \setminus~auth_{store}(l, \mu) \cup pointsto(e, \mu) \cup auth_{stack}(l, e, \mu)\\\\
    auth_{store}(l, \mu') \cup auth_{stack}(l, e', \mu')& \text{if } r_2 = r_1\\
    \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, e, \mu)
\end{cases} & (Lemma~\textit{\ref{l:a-diff}})
\end{align*}
\intuition{[If $r_2 < r_1$, then there are only pure principals after the last method call stack frame where $l$ is the caller. In other words, $l$ was the last principal caller on the stack.\\
If $r_2 = r_1$, then the last method call stack frame where $l$ is the caller is followed by a method call stack frame with a principal caller that is not $l$. If $r_2 = r_1 = 0$, then there are no method call stack frames with principal callers on the stack.\\
Since the set in 3(b) can include indices of method call stack frames where the caller is $l$, the difference between $r_1$ and $r_2$ is at most $1$, i.e. $r_2 \le r_1 \le r_2 + 1$.]}\\
Thus, the changes in authority when $E[e]~|~\mu \longrightarrow E[e']~|~\mu'$ depend on what expressions are in $e~|~\mu \longrightarrow e'~|~\mu'$. Let us consider all possible $e$ and $e'$.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-New}:}}{Subcase \textsc{E-New}:}}
\mbox{$e = \keywadj{new}_s(x \Rightarrow \overline{d_a})$}, \mbox{$e' = l_a$}, and \mbox{$E[\keywadj{new}_s(x \Rightarrow \overline{d_a})]~|~\mu \longrightarrow E[l_a]~|~\mu'$}, where\\
\mbox{$\mu' = \mu, l_a \mapsto \{ x \Rightarrow \overline{d_a} \}_s$}.

By \textsc{auth-store}, $auth_{store}(l, \mu) = pointsto(l, \mu) \cup pointsto(\overline{d}, \mu)$ and $auth_{store}(l, \mu') = pointsto(l, \mu') \cup pointsto(\overline{d}, \mu')$. By \textsc{pointsto-principal}, \textsc{pointsto-pure}, and \textsc{pointsto-empty}, $pointsto(l, \mu') = pointsto(l, \mu)$. By \textsc{pointsto-decls} and the $pointsto(d, \mu)$ rules, $pointsto(\overline{d}, \mu)$ depends only on what is in $\overline{d}$ and whether it is stateful. Then, since the only change to the store was the addition of a new object $l_a$, and by inversion on \textsc{E-New}, $l_a \not\in dom(\mu)$ and $\keywadj{new}_s(x \Rightarrow \overline{d_a})$ is a closed term, i.e. it is fully defined and all objects in $\overline{d_a}$ must be in the store at the time of the object creation (\textsc{T-Store}), $pointsto(l_a, \mu) \not\in pointsto(\overline{d}, \mu')$. Thus, $auth_{store}(l, \mu') = auth_{store}(l, \mu)$.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_a, \mu') \cup auth_{stack}(l, l_a, \mu')\\
& \setminus pointsto(\keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu) \cup auth_{stack}(l, \keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu)\\
&= pointsto(l_a, \mu') \setminus pointsto(\keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= pointsto(l_a, \mu') \setminus pointsto(\overline{d_a}, \mu) & (\textsc{pointsto-new}, \textsc{pointsto-empty})
\end{align*}
There are two possibilities depending on whether $l_a$ is a principal or not.

\noindent\underline{\textit{Case $l_a$ is a principal:}}
\vspace{-7pt}
\begin{align*}
auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) &= \{ l_a \} \setminus pointsto(\overline{d_a}, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty}) 
\end{align*}
Since $l_a$ points to a fresh memory location and our language requires an object to be allocated in memory before it can be used, $\{ l_a \} \not\in pointsto(\overline{d_a}, \mu)$, the authority of $l$ increases, which is in accordance with the \textbf{\textit{object creation}} case, and the theorem holds.

\noindent\underline{\textit{Case $l_a$ is pure:}}
\vspace{-7pt}
\begin{align*}
auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) &= \varnothing \setminus pointsto(\overline{d_a}, \mu) & (\textsc{pointsto-pure}, \textsc{pointsto-empty})
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_a, \mu') \setminus auth_{stack}(l, \keywadj{new}_s(x \Rightarrow \overline{d_a}), \mu)\\
&= \varnothing & (\textsc{auth-stack-nocall} \times 2)
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Method}:}}{Subcase \textsc{E-Method}:}}
$e = l_a.m(l_b)$, \mbox{$e' = l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a$}, \mbox{$\mu' = \mu$}, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$. Since $e_a$ is a method definition, by Property~\ref{prop:mcsf-def-bind}, $e_a$ has no method call stack frames.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}} \noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\begin{align*}
&= pointsto(l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu)\\
&\setminus pointsto(l_a.m(l_b), \mu) \cup auth_{stack}(l, l_a.m(l_b), \mu)\\
&= pointsto(l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})\\
&\setminus pointsto(l_a.m(l_b), \mu)
\end{align*}
There are three possibilities depending on whether $l_a = l$ and whether it is a principal or not.

\noindent\underline{\textit{Case $l_a = l$:}} Since $l$ is a principal, $l_a$ is a principal too.\\
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= \{ l_a \} \cup auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) & (\textsc{pointsto-call-principal}, \textsc{pointsto-empty})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{subexps-e-method2})\\
&= \{ l_a \} \cup pointsto([l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
&= \{ l_a \} \cup pointsto([l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
&= pointsto(l_a, \mu) \cup pointsto([l_b / y][l_a / x]e_a, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
&\setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)
\end{align*}
\vspace{-25pt}
\begin{align*}
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x, y \not\in e_a
\end{cases} & (Lemma~\textit{\ref{l:sub-in-pt}} \times 2)\\
&=
\begin{cases}
    pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) & \text{if } x, y \not\in e_a
\end{cases}\\
&\subseteq pointsto(e_a, \mu)\\
&= auth_{store}(l, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu)
\end{align*}
By \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $auth_{store}(l, \mu) \supseteq pointsto(e_a, \mu)$, and therefore, $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) = \varnothing$. Thus, the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is a principal:}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= \{ l_a \} \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{pointsto-call-principal}, \textsc{pointsto-empty})\\
&= pointsto(l_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is pure:}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto([l_b / y][l_a / x]e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & (\textsc{pointsto-call-pure}, \textsc{pointsto-empty})
\end{align*}
\vspace{-25pt}
\begin{align*}
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu)\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(l_b, \mu) & \text{if } x, y \not\in e_a
\end{cases} & (Lemma~\textit{\ref{l:sub-in-pt}} \times 2)\\
&=
\begin{cases}
    pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_b, \mu) &\text{if } x, y \not\in e_a
\end{cases}\\
&\subseteq pointsto(e_a, \mu)\\
&= auth_{store}(l, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu)
\end{align*}
By \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $auth_{store}(l, \mu) \supseteq pointsto(e_a, \mu)$, and therefore, $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) = \varnothing$. Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}} \noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) \setminus auth_{stack}(l, l_a.m(l_b), \mu)\\
&= auth_{stack}(l, l_a.m(l_b) \rhd [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
There are two possibilities depending on whether $l_a = l$ or not.

\noindent\underline{\textit{Case $l_a = l$:}} Since $l$ is a principal, $l_a$ is a principal too.\\
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto([l_b / y][l_a / x]e_a, \mu) \cup auth_{stack}(l, [l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack})\\
&= pointsto([l_b / y][l_a / x]e_a, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
\begin{align*}
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x, y \in e_a\\
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a~~~~~~~~~(Lemma~\textit{\ref{l:sub-in-pt}} \times 2)\\
    pointsto(l_b, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    pointsto(e_a, \mu) & \text{if } x, y \not\in e_a
\end{cases}\\
&=
\begin{cases}
    auth_{store}(l, \mu) \cup pointsto(l_a, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \in e_a\\
    auth_{store}(l, \mu) \cup pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    auth_{store}(l, \mu) \cup pointsto(e_a, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \not\in e_a
\end{cases}
\end{align*}
Since $l_a = l$ and by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-def}, $auth_{store}(l, \mu) \supseteq pointsto(l_a, \mu) \cup pointsto(e_a, \mu)$. Then, $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\begin{align*}
&=
\begin{cases}
    auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \in e_a\\
    auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \in e_a\text{ and } y \not\in e_a\\
    auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \setminus auth_{store}(l, \mu) & \text{if } x \not\in e_a \text{ and } y \in e_a\\
    auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) & \text{if } x, y \not\in e_a
\end{cases}\\
&=
\begin{cases}
    pointsto(l_b, \mu) & \text{if } y \in e_a\\
    \varnothing & \text{if } y \not\in e_a\\
\end{cases}\\
&=
\begin{cases}
    \{ l_b \} & \text{if } y \in e_a \text{ and } l_b \text { is a principal}~~~(\textsc{pointsto-principal}, \textsc{pointsto-empty})\\
    \varnothing & \text{otherwise}\\
\end{cases}
\end{align*}
Thus, if $y \in e_a$ and $l_b$ is a principal, the authority of $l$ increases, which is in accordance with the \textbf{\textit{method call}} case, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$:}} $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) = \varnothing~~~~~~~~~~~~(\textsc{auth-stack-nocall})$\\
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Field}:}}{Subcase \textsc{E-Field}:}}
$e = l_a.f$, $e' = l_b$, $\mu' = \mu$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$.

By Property~\ref{prop:fields-private}, the object field that is being accessed must belong to the caller of the last method call stack frame on the stack. Then, $l_1 = l_a$, and by definition of a principal, since $l_1$ has fields, it is a principal.

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}} Since $l_1$ is a principal, $l = l_1 = l_a$.\\
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_b, \mu) \cup auth_{stack}(l, l_b, \mu) \setminus pointsto(l.f, \mu) \cup auth_{stack}(l, l.f, \mu)\\
&= pointsto(l_b, \mu) \setminus pointsto(l.f, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= auth_{store}(l, \mu) \cup pointsto(l_b, \mu) \setminus auth_{store}(l, \mu) \cup pointsto(l.f, \mu)
\end{align*}
By inversion on \textsc{E-Field}, $\keyw{var} f : \tau = l_b \in \overline{d}$. Then, by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu) \supseteq pointsto(l_b, \mu)$, and
\begin{align*}
auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu) &= auth_{store}(l, \mu) \setminus auth_{store}(l, \mu) \cup pointsto(l.f, \mu) = \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}} $auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_b, \mu) \setminus auth_{stack}(l, l_a.f, \mu)\\ 
&= \varnothing & (\textsc{auth-stack-nocall} \times 2)
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Assign}:}}{Subcase \textsc{E-Assign}:}}
$e = (l_a.f = l_b)$, $e' = l_b$, and by inversion on \textsc{E-Assign}, $l_a \mapsto \{ x \Rightarrow \overline{d_a} \}_{s} \in \mu$, \mbox{$\keyw{var} f : \tau = l_c \in \overline{d_a}$}, $\overline{d_a}' = [\keyw{var} f : \tau = l_b/\keyw{var} f : \tau = l_c]\overline{d_a}$, and $\mu' = [l_a \mapsto \{ x \Rightarrow \overline{d_a}' \}_{s}/l_a \mapsto \{ x \Rightarrow \overline{d_a} \}_{s}]\mu$.

By Property~\ref{prop:fields-private}, the object field that is being accessed must belong to the caller of the last method call stack frame on the stack. Then, $l_1 = l_a$, and by definition of a principal, since $l_1$ has fields, it is a principal.

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}} Since $l_1$ is a principal, in this case, $l = l_1 = l_a$.

Since in this step of evaluation, the only change to the store is the substitution of $l_c$ with $l_b$ in one of $l$'s fields, by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu') \setminus auth_{store}(l, \mu) \subseteq pointsto(l_b, \mu')$. [1]

By \textsc{pointsto-principal}, \textsc{pointsto-pure}, and \textsc{pointsto-empty}, $pointsto(l_b, \mu') = pointsto(l_b, \mu)$. \hspace{12pt} [2]

\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup pointsto(l_b, \mu') \cup auth_{stack}(l, l_b, \mu')\\
&\setminus~auth_{store}(l, \mu) \cup pointsto(l.f = l_b, \mu) \cup auth_{stack}(l, l.f = l_b, \mu)\\
&= auth_{store}(l, \mu') \cup pointsto(l_b, \mu') \setminus auth_{store}(l, \mu) \cup pointsto(l.f = l_b, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= auth_{store}(l, \mu') \cup pointsto(l_b, \mu') \setminus auth_{store}(l, \mu) \cup pointsto(l, \mu) \cup pointsto(l_b, \mu) & (\textsc{subexps-e-assign2})\\
&\subseteq pointsto(l_b, \mu') \setminus pointsto(l, \mu) \cup pointsto(l_b, \mu) & (by~[1])\\
&= \varnothing & (by~[2])
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}} Since $l_1$ is a principal and $l_1 = l_a$, in this case, $l \neq l_a$ and $r_2 = r_1 \neq 0$.

Since $l \neq l_a$ and, in this step of evaluation, the only change to the store is the substitution of $l_c$ with $l_b$ in one of $l_1$'s fields, by \textsc{auth-store}, \textsc{pointsto-decls}, and \textsc{pointsto-varl}, $auth_{store}(l, \mu') = auth_{store}(l, \mu)$. [3]

\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{store}(l, \mu') \cup auth_{stack}(l, l_b, \mu') \setminus~auth_{store}(l, \mu) \cup auth_{stack}(l, l_a.f = l_b, \mu)\\
&= auth_{store}(l, \mu') \setminus auth_{store}(l, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= \varnothing & (by~[3])
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-Bind}:}}{Subcase \textsc{E-Bind}:}}
$e = \keyw{bind} x = l_a~\keyw{in} e_a$, $e' = [l_a/x]e_a$, $\mu' = \mu$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$. Since $e_a$ is a method definition, by Property~\ref{prop:mcsf-def-bind}, $e_a$ has no method call stack frames.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto([l_a/x]e_a, \mu) \cup auth_{stack}(l, [l_a/x]e_a, \mu)\\
&\setminus pointsto(\keyw{bind} x = l_a~\keyw{in} e_a, \mu) \cup auth_{stack}(l, \keyw{bind} x = l_a~\keyw{in} e_a, \mu)\\
&= pointsto([l_a/x]e_a, \mu) \setminus pointsto(\keyw{bind} x = l_a~\keyw{in} e_a, \mu) & (\textsc{auth-stack-nocall} \times 2)\\
&= pointsto([l_a/x]e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & (\textsc{subexps-e-bind})\\
&=
\begin{cases}
    pointsto(l_a, \mu) \cup pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & \text{if } x \in e_a\\
    pointsto(e_a, \mu) \setminus pointsto(l_a, \mu) \cup pointsto(e_a, \mu) & \text{if } x \not\in e_a
\end{cases} & (Lemma~\textit{\ref{l:sub-in-pt}})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, [l_a/x]e_a, \mu) \setminus auth_{stack}(l, \keyw{bind} x = l_a~\keyw{in} e_a, \mu)\\
&= \varnothing & (\textsc{auth-stack-nocall} \times 2)
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\\


\noindent\fbox{\parbox{\widthof{Subcase \textsc{E-StackFrame}:}}{Subcase \textsc{E-Stackframe}:}}
$e = l_a.m(l_b) \rhd l_c$, $e' = l_c$, $\mu' = \mu$, and $auth_{store}(l, \mu') = auth_{store}(l, \mu)$.\\

\noindent\underline{\underline{\textit{Case $r_2 < r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu) \cup auth_{stack}(l, l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{auth-stack-nocall})
\end{align*}
There are three possibilities depending on whether $l_a = l$ and whether it is a principal or not.

\noindent\underline{\textit{Case $l_a = l$:}} Since $l$ is a principal, $l_a$ is a principal too.\\
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup pointsto(l_c, \mu) \cup auth_{stack}(l, l_c, \mu) & (\textsc{auth-stack})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is a principal:}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu)\\
& \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus \{ l_a \} \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{pointsto-call-principal}, \textsc{pointsto-empty})\\
&= pointsto(l_c, \mu) \setminus \{ l_a \} & (\textsc{auth-stack-nocall})\\
&=
\begin{cases}
    \{ l_c \} \setminus \{ l_a \} & \text{if } l_c \text{ is a principal}~~~(\textsc{pointsto-principal})\\
    \varnothing & \text{if } l_c \text{ is pure}~~~~~~~~~~~(\textsc{auth-stack-nocall})
\end{cases}
\end{align*}
Thus, if $l_a \neq l$, $l_a$ is a principal, and $l_c$ is a principal, then the authority of $l$ increases, which is in accordance with the \textbf{\textit{method return}} case, and the theorem holds. If $l_a \neq l$, $l_a$ is a principal, and $l_c$ is pure, then the authority of $l$ does not increase, and the theorem holds.

\noindent\underline{\textit{Case $l_a \neq l$ and $l_a$ is pure:}}
\noindent$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= pointsto(l_c, \mu) \setminus pointsto(l_a.m(l_b) \rhd l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= pointsto(l_c, \mu) \setminus pointsto(l_c, \mu) \cup auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{pointsto-call-pure}, \textsc{pointsto-empty})\\
&= \varnothing
\end{align*}
Thus, the authority of $l$ does not increase, and the theorem holds.\\

\noindent\underline{\underline{\textit{Case $r_2 = r_1$:}}}
$auth(l, E[e'], \mu') \setminus auth(l, E[e], \mu)$
\vspace{-7pt}
\begin{align*}
&= auth_{stack}(l, l_c, \mu) \setminus auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu)\\
&= \varnothing \setminus auth_{stack}(l, l_a.m(l_b) \rhd l_c, \mu) & (\textsc{auth-stack-nocall})\\
&= \varnothing
\end{align*}
Thus, $l$'s authority does not increase, and the theorem holds.\\
\qed
\end{proof}



\newpage

\subsection{Sample Scenarios}

\noindent\underline{\smash{\textbf{\textit{Object creation:}}}}

\vspace{16pt}

\noindent Program code:
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
new($l_p$ =>
  def m(y : typeOfD) : typeOfE =
    new($l_D$ => var xd : typeOfE = y)
).m(new($l_E$ => var xe : Int = 5))
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 1 (form before: $E.m(e)$, rule applied: \textsc{E-New}):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$ def m(y : typeOfD) : typeOfE =
          new($l_D$ => var xd : typeOfE = y) $\}$

$l_p$.m(new($l_E$ => var xe : Int = 5)
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 2 (form before: $l.m(E)$, rule applied: \textsc{E-New}):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$ def m(y : typeOfD) : typeOfE =
          new($l_D$ => var xd : typeOfE = y) $\}$
$l_E \rightarrow \{$ var xe : Int = 5 } // assume 5 is a location in memory representing the integer value

$l_p$.m($l_E$)
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 3 (form before: $l.m(l)$, rule applied: \textsc{E-Method}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p$.m($l_E$) $\rhd$ new($l_D$ => var xd : typeOfE = $l_E$)
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 4 (form before: $l.m(l) \rhd E$, rule applied: \textsc{E-New}):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$ def m(y : typeOfD) : typeOfE =
          new($l_D$ => var xd : typeOfE = y) $\}$
$l_E \rightarrow \{$ var xe : Int = 5 $\}$
$l_D \rightarrow \{$ var xd : typeOfE = $l_E$ $\}$

$l_p$.m($l_E$) $\rhd$ $l_D$
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 5 (form before: $l.m(l) \rhd l$, rule applied: \textsc{E-StackFrame}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_D$
\end{lstlisting}

\newpage

\noindent\textbf{$l_p$ gains authority over $l_D$ in evaluation step 4 when \textsc{E-New} is applied to create $l_D$:}\\

\noindent$e = E[\keywadj{new}_{\keywadj{stateful}}(l_D \Rightarrow \keyw{var} x_d : typeOfE = l_E)]$, $e' = E[l_D]$\\

\noindent$e = l_p.m(l_E) \rhd \keywadj{new}_{\keywadj{stateful}}(l_D \Rightarrow \keyw{var} x_d : typeOfE = l_E)$, $e' = l_p.m(l_E) \rhd l_D$\\

\noindent$auth(l_p, e', \mu') = auth(l_p, e, \mu) \cup \{ l_D \}$

\begin{align*}
auth(l_p, e', \mu') &= auth_{store}(l_p, \mu') \cup auth_{stack}(l_p, e', \mu') & (\textsc{auth-config})\\
auth_{store}(l_p, \mu') &= pointsto(l_p, \mu') \cup pointsto(\keyw{def} m~...~, \mu') & (\textsc{auth-store})\\
 &= \{ l_p \} \cup pointsto(\keyw{def} m(...) : typeOfE = \keywadj{new}(...), \mu') & (\textsc{pointsto-principal})\\
 &= \{ l_p \} \cup pointsto(\keywadj{new}(l_D \Rightarrow \keyw{var} x_d~...), \mu') & (\textsc{pointsto-def, -emptydecl})\\
 &= \{ l_p \} \cup pointsto(\keyw{var} x_d : typeOfE = l_E), \mu') & (\textsc{pointsto-new})\\
 &= \{ l_p \} \cup pointsto(l_E, \mu') & (\textsc{pointsto-varl, -emptydecl})\\ 
 &= \{ l_p,~l_E \} & (\textsc{pointsto-principal})\\
auth_{stack}(l_p, e', \mu') &= pointsto(l_D, \mu') \cup auth_{stack}(l_p, l_D, \mu') & (\textsc{auth-stack})\\
 &= \{ l_D \} \cup auth_{stack}(l_p, l_D, \mu') & (\textsc{pointsto-principal})\\
 &= \{ l_D \} & (\textsc{auth-stack-nocall})\\
auth(l_p, e', \mu') &= \{ l_p,~l_E,~l_D \} &\\
\end{align*}
\begin{align*}
auth(l_p, e, \mu) &= auth_{store}(l_p, \mu) \cup auth_{stack}(l_p, e, \mu) & (\textsc{auth-config})\\
auth_{store}(l_p, \mu) &= pointsto(l_p, \mu) \cup pointsto(\keyw{def} m~...~, \mu) & (\textsc{auth-store})\\
 &= \{ l_p \} \cup pointsto(\keyw{def} m(...) : typeOfE = \keywadj{new}(...), \mu) & (\textsc{pointsto-principal})\\
 &= \{ l_p \} \cup pointsto(\keywadj{new}(l_D \Rightarrow \keyw{var} x_d~...), \mu) & (\textsc{pointsto-def, -emptydecl})\\
 &= \{ l_p \} \cup pointsto(\keyw{var} x_d : typeOfE = l_E), \mu) & (\textsc{pointsto-new})\\
 &= \{ l_p \} \cup pointsto(l_E, \mu) & (\textsc{pointsto-varl, -emptydecl})\\ 
 &= \{ l_p,~l_E \} & (\textsc{pointsto-principal})\\
auth_{stack}(l_p, e, \mu) &= pointsto(\keywadj{new}(l_D \Rightarrow \keyw{var} x_d : typeOfE = l_E), \mu) &\\
 &\cup auth_{stack}(l_p, \keywadj{new}(l_D \Rightarrow \keyw{var} x_d : typeOfE = l_E), \mu) & (\textsc{auth-stack})\\
 &= pointsto(\keywadj{new}(l_D \Rightarrow \keyw{var} x_d : typeOfE = l_E), \mu) & (\textsc{auth-stack-nocall})\\
 &= pointsto(\keyw{var} x_d : typeOfE = l_E), \mu') & (\textsc{pointsto-new})\\
 &= pointsto(l_E, \mu') & (\textsc{pointsto-varl, -emptydecl})\\ 
 &= \{ l_E \} & (\textsc{pointsto-principal})\\
auth(l_p, e, \mu) &=  \{ l_p,~l_E\}&\\
\end{align*}


\newpage

\noindent\underline{\smash{\textbf{\textit{Method call:}}}}

\vspace{16pt}

\noindent Program code:
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
new($l_p$ =>
  def mp(yi : typeOfI, yh : typeOfH) : typeOfJ =
    new($l_J$ =>
      var xji : typeOfI = yi
      var xjh : typeOfH = yh
      def mj(Unit) : Int =
        xjh.mh(xji)))
.mp(new($l_I$ => var xi : Int = 3), new($l_H$ => def mh(y : typeOfI) : Int = y.xi))
.mj()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 1 (form before: $E.m(e)$, going deeper):\\
\indent\textit{Code same as above}

\vspace{12pt}
\noindent Evaluation step 2 (form before: $E.m(e)$, rule applied: \textsc{E-New}):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$   def mp(yi : typeOfI, yh : typeOfH) : typeOfJ =
         new($l_J$ =>
           var xji : typeOfI = yi
           var xjh : typeOfH = yh
           def mj(Unit) : Int =
             xjh.mh(xji)) $\}$

$l_p$.mp(new($l_I$ => var xi : Int = 3), new($l_H$ => def mh(y : typeOfI) : Int = y.xi)).mj()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 3 (form before: $l.m(E, E)$, rule applied: \textsc{E-New} x2):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$   def mp(yi : typeOfI, yh : typeOfH) : typeOfJ =
         new($l_J$ =>
           var xji : typeOfI = yi
           var xjh : typeOfH = yh
           def mj(Unit) : Int =
             xjh.mh(xji)) $\}$
$l_I \rightarrow \{$ var xi : Int = 3 } // assume 3 is a location in memory representing the integer value
$l_H \rightarrow \{$ def mh(y : typeOfI) : Int = y.xi $\}$

$l_p$.mp($l_I$, $l_H$).mj()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 4 (form before: $l.m(l, l)$, rule applied: \textsc{E-Method}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
($l_p$.mp($l_I$, $l_H$) $\rhd$ new($l_J$ =>
                    var xji : typeOfI = $l_I$
                    var xjh : typeOfH = $l_H$
                    def mj(Unit) : Int =
                      xjh.mh(xji)))
.mj()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 5 (form before: $l.m(l, l) \rhd E$, rule applied: \textsc{E-New}):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$   def mp(yi : typeOfI, yh : typeOfH) : typeOfJ =
         new($l_J$ =>
           var xji : typeOfI = yi
           var xjh : typeOfH = yh
           def mj(Unit) : Int =
             xjh.mh(xji)) $\}$
$l_I \rightarrow \{$ var xi : Int = 3 }
$l_H \rightarrow \{$ def mh(y : typeOfI) : Int = y.xi $\}$
$l_J \rightarrow \{$ var xji : typeOfI = $l_I$
        var xjh : typeOfH = $l_H$
        def mj(Unit) : Int =
          xjh.mh(xji) $\}$

($l_p$.mp($l_I$, $l_H$) $\rhd$ $l_J$).mj()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 6 (form before: $l.m(l) \rhd l$, rule applied: \textsc{E-StackFrame}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_J$.mj()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 7 (form before: $E.m(e)$, $E$ is already evaluated to an object):\\
\indent\textit{Code same as above}

\vspace{12pt}
\noindent Evaluation step 8 (form before: $l.m(E)$, a \lstinline{Unit} argument passed, $E$ is already fully evaluated):\\
\indent\textit{Code same as above}

\vspace{12pt}
\noindent Evaluation step 9 (form before: $l.m(l)$, rule applied: \textsc{E-Method}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_J$.mj() $\rhd$ xjh.mh(xji)
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 10 (form before: $l.m(l) \rhd E$, going deeper):\\
\textit{Code same as above}

\vspace{12pt}
\noindent Evaluation step 11 (forms before: $E.m(e)$, $l.m(E)$, substitution of concrete objects for variables x2):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_J$.mj() $\rhd$ $l_H$.mh($l_I$)
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 12 (form before: $l.m(l)$, rule applied: \textsc{E-Method}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_J$.mj() $\rhd$ ($l_H$.mh($l_I$) $\rhd$ $l_I$.xi)
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 13 (form before: $l.m(l) \rhd E$, rule applied: \textsc{E-Field}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_J$.mj() $\rhd$ ($l_H$.mh($l_I$) $\rhd$ 3)
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 14 (form before: $l.m(l) \rhd l$, rule applied: \textsc{E-StackFrame}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_J$.mj() $\rhd$ 3
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 15 (form before: $l.m(l) \rhd l$, rule applied: \textsc{E-StackFrame}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
3
\end{lstlisting}


\newpage

\noindent\textbf{$l_H$ gains authority over $l_I$ through $l_J$ when $l_I$ is passed in as an argument to $m_h()$ in evaluation step 12 when \textsc{E-Method} is applied:}\\

\noindent ($l_H$ is pure; $l_I$ and $l_J$ are stateful)\\

\noindent$e = E[l_H.m_h(l_I)]$, $e' = E[l_H.m_h(l_I) \rhd l_I.x_i]$\\

\noindent$e = l_J.m_j() \rhd l_H.m_h(l_I)$, $e' = l_J.m_j() \rhd (l_H.m_h(l_I) \rhd l_I.x_i)$\\

\noindent$auth(l_H, e', \mu') = auth(l_H, e, \mu) \cup \{ l_I \}$

\begin{align*}
auth(l_H, e', \mu') &= auth_{store}(l_H, \mu') \cup auth_{stack}(l_H, e', \mu') & (\textsc{auth-config})\\
auth_{store}(l_H, \mu') &= pointsto(l_H, \mu') \cup pointsto(\keyw{def} m_h~...~, \mu') & (\textsc{auth-store})\\
 &= pointsto(\keyw{def} m_h(y : typeOfI) : Int = y.x_i, \mu') & (\textsc{pointsto-pure})\\
 &= pointsto(y.x_i, \mu') & (\textsc{pointsto-def, -emptydecl})\\
 &= pointsto(y, \mu') & (\textsc{pointsto-otherexp})\\
 &= \varnothing & (\textsc{pointsto-var})\\
auth_{stack}(l_H, e', \mu') &= pointsto(l_I.x_i, \mu') \cup auth_{stack}(l_H, l_I.x_i, \mu') & (\textsc{auth-stack})\\
 &= pointsto(l_I.x_i, \mu') & (\textsc{auth-stack-nocall})\\
 &= pointsto(l_I, \mu') & (\textsc{pointsto-otherexp})\\
 &= \{ l_I \} & (\textsc{pointsto-principal})\\
auth(l_H, e', \mu') &= \{ l_I \} &\\
\end{align*}
\begin{align*}
auth(l_H, e, \mu) &= auth_{store}(l_H, \mu) \cup auth_{stack}(l_H, e, \mu) & (\textsc{auth-config})\\
auth_{store}(l_H, \mu) &= pointsto(l_H, \mu) \cup pointsto(\keyw{def} m_h~...~, \mu) & (\textsc{auth-store})\\
 &= pointsto(\keyw{def} m_h(y : typeOfI) : Int = y.x_i, \mu) & (\textsc{pointsto-pure})\\
 &= pointsto(y.x_i, \mu) & (\textsc{pointsto-def, -emptydecl})\\
 &= pointsto(y, \mu) & (\textsc{pointsto-otherexp})\\
 &= \varnothing & (\textsc{pointsto-var})\\
auth_{stack}(l_H, e, \mu) &= \varnothing & (\textsc{auth-stack-nocall})\\
auth(l_H, e, \mu) &=  \varnothing &\\
\end{align*}


\newpage

\noindent\underline{\smash{\textbf{\textit{Method return:}}}}

\vspace{16pt}

\noindent Program code:
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
new($l_p$ =>
  def mp(y : typeOfA) : typeOfC =
    new($l_C$ =>
      var xca : typeOfA = y
      def mc() : typeOfB =
        xca.ma()))
.mp(new($l_A$ => def ma() : typeOfB =
                  new($l_B$ => var xb : Int = 42)))
.mc()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 1 (form before: $E.m(e)$, going deeper):\\
\indent\textit{Code same as above}

\vspace{12pt}
\noindent Evaluation step 2 (form before: $E.m(e)$, rule applied: \textsc{E-New}):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$ def mp(y : typeOfA) : typeOfC =
         new($l_C$ =>
           var xca : typeOfA = y
           def mc() : typeOfB =
             xca.ma()) $\}$
$l_p$.mp(new($l_A$ => def ma() : typeOfB = new($l_B$ => var xb : Int = 42))).mc()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 3 (form before: $l.m(E)$, rule applied: \textsc{E-New}):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$ def mp(y : typeOfA) : typeOfC =
         new($l_C$ =>
           var xca : typeOfA = y
           def mc() : typeOfB =
             xca.ma()) $\}$
$l_A \rightarrow \{$ def ma() : typeOfB =
          new($l_B$ => var xb : Int = 42) $\}$

$l_p$.mp($l_A$).mc()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 4 (form before: $l.m(l)$, rule applied: \textsc{E-Method}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
($l_p$.mp($l_A$) $\rhd$ new($l_C$ =>
                var xca : typeOfA = $l_A$
                def mc() : typeOfB =
                  xca.ma())
.mc()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 5 (form before: $l.m(l) \rhd E$, rule applied: \textsc{E-New}):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$ def mp(y : typeOfA) : typeOfC =
         new($l_C$ =>
           var xca : typeOfA = y
           def mc() : typeOfB =
             xca.ma()) $\}$
$l_A \rightarrow \{$ def ma() : typeOfB =
          new($l_B$ => var xb : Int = 42) $\}$
$l_C \rightarrow \{$ var xca : typeOfA = $l_A$
        def mc() : typeOfB =
          xca.ma()) $\}$

($l_p$.mp($l_A$) $\rhd$ $l_C$).mc()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 6 (form before: $l.m(l) \rhd l$, rule applied: \textsc{E-StackFrame}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_C$.mc()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 7 (form before: $E.m(e)$, $E$ is already evaluated to an object):\\
\indent\textit{Code same as above}

\vspace{12pt}
\noindent Evaluation step 8 (form before: $l.m(E)$, a \lstinline{Unit} argument passed, $E$ is already fully evaluated):\\
\indent\textit{Code same as above}

\vspace{12pt}
\noindent Evaluation step 9 (form before: $l.m(l)$, rule applied: \textsc{E-Method}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_C$.mc() $\rhd$ xca.ma()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 10 (form before: $l.m(l) \rhd E$, going deeper):\\
\textit{Code same as above}

\vspace{12pt}
\noindent Evaluation step 11 (form before: $E.m(e)$, substitution of concrete object for variable):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_C$.mc() $\rhd$ $l_A$.ma()
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 12 (form before: $l.m(E)$, a \lstinline{Unit} argument passed, $E$ is already fully evaluated):\\
\indent\textit{Code same as above}

\vspace{12pt}
\noindent Evaluation step 13 (form before: $l.m(l)$, rule applied: \textsc{E-Method}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_C$.mc() $\rhd$ ($l_A$.ma() $\rhd$ new($l_B$ => var xb : Int = 42))
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 14 (form before: $l.m(l) \rhd E$, rule applied: \textsc{E-New}):
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_p \rightarrow \{$ def mp(y : typeOfA) : typeOfC =
         new($l_C$ =>
           var xca : typeOfA = y
           def mc() : typeOfB =
             xca.ma()) $\}$
$l_A \rightarrow \{$ def ma() : typeOfB =
          new($l_B$ => var xb : Int = 42) $\}$
$l_C \rightarrow \{$ var xca : typeOfA = $l_A$
        def mc() : typeOfB =
          xca.ma()) $\}$
$l_B \rightarrow \{$ var xb : Int = 42 $\}$

$l_C$.mc() $\rhd$ ($l_A$.ma() $\rhd$ $l_B$)
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 15 (form before: $l.m(l) \rhd l$, rule applied: \textsc{E-StackFrame}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_C$.mc() $\rhd$ $l_B$
\end{lstlisting}

\vspace{12pt}
\noindent Evaluation step 16 (form before: $l.m(l) \rhd l$, rule applied: \textsc{E-StackFrame}):\\
\vspace{-6pt}
\indent\textit{Memory same as above}\\
\vspace{-6pt}
\begin{lstlisting}[xleftmargin=20pt]
$l_B$
\end{lstlisting}


\newpage

\noindent\textbf{$l_C$ gains authority over $l_B$ due to a return from $l_A$'s method $m_a()$ in evaluation step 15 when \textsc{E-StackFrame} is applied:}\\

\noindent ($l_A$, $l_B$ and $l_C$ are stateful)\\

\noindent$e = E[l_A.m_a() \rhd l_B]$, $e' = E[l_B]$\\

\noindent$e = l_C.m_c() \rhd (l_A.m_a() \rhd l_B)$, $e' = l_C.m_c() \rhd l_B$\\

\noindent$auth(l_C, e', \mu') = auth(l_C, e, \mu) \cup \{ l_B \}$

\begin{align*}
auth(l_C, e', \mu') &= auth_{store}(l_C, \mu') \cup auth_{stack}(l_C, e', \mu') & (\textsc{auth-config})\\
auth_{store}(l_C, \mu') &= pointsto(l_C, \mu') \cup pointsto(\keyw{var} x_{ca}~...~, \mu') & (\textsc{auth-store})\\
 &= \{ l_C \} \cup pointsto(\keyw{var} x_{ca} : typeOfA = l_A;~\keyw{def} m_c~...~, \mu') & (\textsc{pointsto-principal})\\
 &= \{ l_C \} \cup pointsto(l_A, \mu) \cup pointsto(\keyw{def} m_c~...~, \mu') & (\textsc{pointsto-varl})\\
 &= \{ l_C, l_A \} \cup pointsto(\keyw{def} m_c() : typeOfB = x_{ca}.m_a(), \mu') & (\textsc{pointsto-principal})\\
 &= \{ l_C, l_A \} \cup pointsto(x_{ca}.m_a(), \mu') & (\textsc{pointsto-def, -emptydecl})\\
 &= \{ l_C, l_A \} \cup pointsto(x_{ca}, \mu') & (\textsc{pointsto-otherexp, -pure})\\
 &= \{ l_C,~l_A \} & (\textsc{pointsto-var})\\
auth_{stack}(l_C, e', \mu') &= pointsto(l_B, \mu') \cup auth_{stack}(l_C, l_B, \mu') & (\textsc{auth-stack})\\
 &= \{ l_B \} \cup auth_{stack}(l_C, l_B, \mu') & (\textsc{pointsto-principal})\\
 &= \{ l_B \} & (\textsc{auth-stack-nocall})\\
auth(l_C, e', \mu') &= \{ l_C,~l_A,~l_B \} &\\
\end{align*}
\begin{align*}
auth(l_C, e, \mu) &= auth_{store}(l_C, \mu) \cup auth_{stack}(l_C, e, \mu) & (\textsc{auth-config})\\
auth_{store}(l_C, \mu) &= pointsto(l_C, \mu) \cup pointsto(\keyw{var} x_{ca}~...~, \mu) & (\textsc{auth-store})\\
 &= \{ l_C \} \cup pointsto(\keyw{var} x_{ca} : typeOfA = l_A;~\keyw{def} m_c~...~, \mu) & (\textsc{pointsto-principal})\\
 &= \{ l_C \} \cup pointsto(l_A, \mu) \cup pointsto(\keyw{def} m_c~...~, \mu) & (\textsc{pointsto-varl})\\
 &= \{ l_C, l_A \} \cup pointsto(\keyw{def} m_c() : typeOfB = x_{ca}.m_a(), \mu) & (\textsc{pointsto-principal})\\
 &= \{ l_C, l_A \} \cup pointsto(x_{ca}.m_a(), \mu) & (\textsc{pointsto-def, -emptydecl})\\
 &= \{ l_C, l_A \} \cup pointsto(x_{ca}, \mu) & (\textsc{pointsto-otherexp, -pure})\\
 &= \{ l_C,~l_A \} & (\textsc{pointsto-var})\\
auth_{stack}(l_C, e, \mu) &= pointsto(l_A.m_a() \rhd l_B, \mu) \cup auth_{stack}(l_C, l_A.m_a() \rhd l_B, \mu) & (\textsc{auth-stack})\\
 &= \{ l_A \} \cup auth_{stack}(l_C, l_A.m_a() \rhd l_B, \mu) & (\textsc{pointsto-call-principal})\\
 &= \{ l_A \} & (\textsc{auth-stack-nocall})\\
auth(l_C, e, \mu) &=  \{ l_C,~l_A\}&\\
\end{align*}



\bibliographystyle{plain}
\bibliography{bibtex}

\end{document}